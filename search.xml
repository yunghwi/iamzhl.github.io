<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Deploy tale on Fedora27]]></title>
    <url>%2FDeploy-tale-on-Fedora27.html</url>
    <content type="text"><![CDATA[前言 什么是Nginx? Nginx类似于Apache和Tomcat，也是一种服务器软件。 Nginx是一个高性能的HTTP和反向代理服务器，也可以实现负载均衡的功能。 与Tomcat相比，Tomcat是一个Java实现的重量级服务器，而Nginx是一个轻量级服务器。 与Apache相比，Nginx能支持处理百万级的TCP连接，10万以上的并发连接。 准备工作 Fedora主机 ssh工具 开工Fedora安装ssh工具1$ yum install openssh-server -y 检查是否安装成功1$ rpm -qa | grep ssh-server 如下所示即安装成功 123456789[root@localhost athlonreg]# yum install openssh-server -y 上次元数据过期检查：1:43:17 前，执行于 2018年04月15日 星期日 07时49分48秒。软件包 openssh-server-7.5p1-5.fc27.x86_64 已安装，跳过依赖关系解决。无需任何处理。完毕！[root@localhost athlonreg]# rpm -qa | grep ssh-serveropenssh-server-7.5p1-5.fc27.x86_64[root@localhost athlonreg]# 远程主机网络相关配置配置好IP、网关、掩码以及DNS 本机连接到远程主机1$ ssh root@192.168.48.222 如图建立连接成功 其中命令格式为：1$ ssh user@ip 即远程连接的用户名@其IP地址，此处就是之前配置好的IP地址 Note: 此处往下内容，均为远程登录后本机终端对远程主机的操作 安装编译依赖工具以及库文件 gcc-c++ 1$ yum -y install gcc gcc-c++ autoconf automake pcre 1$ yum -y install pcre pcre-devel zlib 1$ yum -y install zlib zlib-devel 检查是否安装成功 1$ rpm -qa | grep gcc-c++ 1$ rpm -qa | grep pcre-devel 1$ rpm -qa | grep zlib-devel 安装Nginx下载1$ wget http://nginx.org/download/nginx-1.13.12.tar.gz 解压1$ tar -zxvf nginx-1.13.12.tar.gz 对Nginx进行配置部署 进入Nginx目录，执行configure 1$ cd nginx-1.13.12 &amp;&amp; ./configure 编译安装 1$ make &amp;&amp; make install 这里注意，如果遇到make或者make install报错，有能力的可以根据命令输出排错，也可以换个nginx的版本重新配置nginx，下面给出下载地址 http://nginx.org/download/ 检查nginx是否成功安装1$ ll -h /usr/local | grep nginx 如图，有结果输出表示安装完成 Nginx各文件简介 conf – 放置nginx的配置文件 html – 放置网页程序 logs – 放置日志文件 sbin – 放置Nginx可执行应用程序 Nginx的常用命令 启动(格式就是Nginx可执行文件地址 -c Nginx配置文件地址) 1$ /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf 重启(格式就是Nginx可执行文件地址 -s reload) 1$ /usr/local/nginx/sbin/nginx -s reload 杀死进程 1$ pkill -9 nginx 验证配置文件重启(格式就是Nginx可执行文件地址 -t) 1$ /usr/local/nginx/sbin/nginx -t 在启动nginx的同时测试配置文件是否正确 1$ /usr/local/nginx/sbin/nginx -tc /usr/local/nginx/conf/nginx.conf 部署Tale安装Java8运行环境 Tale是用Java实现的，所以需要Java环境 12$ cd ; mkdir /usr/java &amp;&amp; cd /usr/java $ yum install java-1.8.0-openjdk* -y 安装MySQL1$ cd &amp;&amp; yum install -y mysql-server mysql mysql-devel 如遇到上图所示报错，只需根据提示执行以下命令清除缓存即可 1$ dnf clean packages 1$ service mysqld restart 如遇报错，可用MariaDB代替 安装MariaDB 1$ yum install -y mariadb-server 启动MariaDB服务 1$ systemctl start mariadb.service 添加到开机启动 1$ systemctl enable mariadb.service 进行一些安全设置，以及修改数据库管理员密码 1$ mysql_secure_installation 安装Nginx服务器(与前面略有不同)1$ yum install nginx -y 启动nginx,可执行文件在/usr/sbin/下1$ /usr/sbin/nginx -t 新建数据库1$ mysql -u root -p 输入密码登录 1$ create database `tale` default character set utf8 collate utf8_general_ci; 1$ exit; 安装Tale博客1$ wget http://static.biezhi.me/tale-least.zip 1$ unzip tale-least.zip 1$ cd tale 1$ ./tale-cli start 最后在远程主机浏览器输入127.0.0.1:9000就可以开始你的博客历程了 本项目实战到此结束]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Tale</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Deploy tale on CentOS7]]></title>
    <url>%2FDeploy-tale-on-CentOS7.html</url>
    <content type="text"><![CDATA[前言 什么是Nginx? Nginx类似于Apache和Tomcat，也是一种服务器软件。 Nginx是一个高性能的HTTP和反向代理服务器，也可以实现负载均衡的功能。 与Tomcat相比，Tomcat是一个Java实现的重量级服务器，而Nginx是一个轻量级服务器。 与Apache相比，Nginx能支持处理百万级的TCP连接，10万以上的并发连接。 准备工作 CentOS主机 ssh工具 开工CentOS安装ssh工具1$ yum install openssh-server -y 检查是否安装成功1$ rpm -qa | grep ssh-server 如图所示即安装成功 1[root@localhost]/home/parallels# rpm -qa | grep ssh-server openssh-server-7.4p1-13.el7_4.x86_64 [root@localhost]/home/parallels# 打开虚拟机建立连接配置好IP、网关、掩码以及DNS 连接到远程主机1$ ssh parallels@192.168.46.226 如图建立连接成功 其中命令格式为：1$ ssh user@ip 即远程连接的用户名@其IP地址，此处就是之前配置好的IP地址 Note: 此处往下内容，均为远程登录后对远程主机的操作 切换root权限1$ sudo -s 安装编译依赖工具以及库文件 gcc-c++ 1$ yum -y install gcc gcc-c++ autoconf automake pcre 1$ yum -y install pcre pcre-devel zlib 1$ yum -y install zlib zlib-devel 检查是否安装成功 安装Nginx下载1$ wget http://nginx.org/download/nginx-1.12.0.tar.gz 解压1$ tar -zxvf nginx-1.12.0.tar.gz 对Nginx进行配置部署 进入Nginx目录，执行configure1$ cd nginx-1.12.0 &amp;&amp; ./configure 编译安装 1$ make &amp;&amp; make install 检查nginx是否成功安装1$ ll -h /usr/local | grep nginx 如图，有结果输出表示安装完成 Nginx各文件简介 conf – 放置nginx的配置文件 html – 放置网页程序 logs – 放置日志文件 sbin – 放置Nginx可执行应用程序 Nginx的常用命令 启动(格式就是Nginx可执行文件地址 -c Nginx配置文件地址) 1$ /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf 重启(格式就是Nginx可执行文件地址 -s reload) 1$ /usr/local/nginx/sbin/nginx -s reload 杀死进程 1$ pkill -9 nginx 验证配置文件重启(格式就是Nginx可执行文件地址 -t) 1$ /usr/local/nginx/sbin/nginx -t 在启动nginx的同时测试配置文件是否正确 1$ /usr/local/nginx/sbin/nginx -tc /usr/local/nginx/conf/nginx.conf 部署Tale安装Java8运行环境 Tale是用Java实现的，所以需要Java环境 12$ cd ; mkdir /usr/java &amp;&amp; cd /usr/java $ yum install java-1.8.0-openjdk* -y 安装MySQL1$ yum install -y mysql-server mysql mysql-devel 1$ service mysqld restart 1$ /usr/bin/mysqladmin -u root password &apos;123456&apos; 安装Nginx服务器(与前面略有不同)1$ yum install nginx -y 启动nginx,可执行文件在/usr/sbin/下1$ /usr/sbin/nginx -t 新建数据库1$ mysql -u root -p 输入密码登录 1$ create database `tale` default character set utf8 collate utf8_general_ci; 1$ exit; 安装Tale博客1$ wget http://static.biezhi.me/tale-least.zip 1$ unzip tale.zip 1$ cd tale 1$ ./tale-cli 最后在浏览器输入127.0.0.1:9000就可以开始你的博客历程了]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Tale</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Intro about iterator in struts2]]></title>
    <url>%2FIntro-about-iterator-in-struts2.html</url>
    <content type="text"><![CDATA[简单的Demo s:iterator 标签有三个属性： value: 被迭代的集合 id: 指定集合中元素的id status: 迭代元素的索引 jsp页面定义元素写法 数组或list123&lt;s:iterator value=&quot;&#123;&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;,&apos;5&apos;&#125;&quot; &gt; &lt;s:property value=&apos;number&apos;/&gt;A&lt;/s:iterator&gt; 打印结果为: 1A2A3A4A5A 索引的用法 如果指定了status，每次的迭代数据都有IteratorStatus的实例，它有以下几个方法 int getCount() – 返回当前迭代了几个元素 int getIndex() – 返回当前元素索引 boolean isEven() – 当前的索引是否偶数 boolean isFirst() – 当前是否第一个元素 boolean isLast() – 当前是否最后一个元素 boolean isOdd() – 当前元素索引是否奇数 123456&lt;s:iterator value=&quot;&#123;&apos;a&apos;,&apos;b&apos;,&apos;c&apos;&#125;&quot; status=&apos;st&apos;&gt; &lt;s:if test=&quot;#st.Even&quot;&gt; 现在的索引是奇数为:&lt;s:property value=&apos;#st.index&apos;/&gt; &lt;/s:if&gt; 当前元素值：&lt;s:property value=&apos;char&apos;/&gt;&lt;/s:iterator&gt; 遍历mapvalue可以直接定义为： 1value=&quot;#&#123;&quot;1&quot;:&quot;a&quot;,&quot;2&quot;:&quot;b&quot;&#125;&quot; 每个元素以逗号隔开，元素之间的key和value冒号隔开。 value也可以是数据栈里面的java.util.Map对象 遍历写法如下： 1234&lt;s:iterator value=&quot;map&quot; status=&quot;st&quot;&gt; key : &lt;s:property value=&apos;key&apos;/&gt; value:&lt;s:property vlaue=&apos;value&apos;/&gt;&lt;/s:iterator&gt; 当然key和value都可以是java的 Object。 遍历数据栈 – 简单的List类1234567891011List&lt;Attr&gt; class Attr&#123; String attrName; String getAttrName() &#123; return &quot;123&quot;; &#125;&#125;&lt;s:iterator value=&quot;label&quot; &gt; &lt;s:property value=&quot;#id.attrName&quot; /&gt;&lt;/s:iterator&gt; 当然value还可以写成value=&quot;%{label}&quot;，label可以用.操作label的属性List，可以写成value=&quot;%{label.list}&quot;，相当于: getLabel().getList()； 遍历 2 个list12List&lt;AttrName&gt; attrN &#123;color,size,style&#125;List&lt;AttrValue&gt; attrV &#123;red,20,gay&#125; 这 2 个list的元素是一一对应的，一个attrN对应一个attrV 12345678910111213&lt;s:iterator value=&quot;%&#123;attrN&#125;&quot; status=&quot;status&quot;&gt; index is : &lt;s:property value=&apos;status.index&apos;/&gt; attrName is : &lt;s:property value=&apos;id&apos;/&gt; or &lt;s:property value=&apos;%&#123;id&#125;&apos;/&gt; attrName is : &lt;s:property value=&apos;%&#123;attrV[#status.index]&#125;&apos;/&gt;&lt;/s:iterator&gt;&lt;s:bean&gt; &lt;s:param value=&quot;5&quot; /&gt; &lt;s:param value=&quot;10&quot; /&gt; &lt;s:iterator&gt; counter:&lt;s:property/&gt; &lt;/s:iterator&gt;&lt;/s:bean&gt; 这个标签主要的的作用就是迭代出集合。value属性表示需要跌代显示出来的值。status属性，又来保存迭代时的一些状态值。 注： 如果需要引用valueStack中的值，需要使用这样的形式。 1&lt;s:iterator value=&quot;#userList&quot; /&gt; //userList 在action部分被保存在Request中，所以使用#加属性名来引用值。 如果集合的值是通过action的方法，假设我们的action中有一个getListMenu方法，返回一个List集合。我们可以使用如下的形式来引用这个集合，并用s:iterator来输出。 1&lt;s:iterator value=&quot;listMenu&quot; /&gt; iterator的value使用定义好的方式，如： 1&lt;s:iterator value=&quot;&#123;1,2,3,4&#125;&quot; /&gt; //这样跌代输出的值就是1.2.3.4这四个值。 iterator中输出具体值如果，在上面我们的list中的对象，有两个属性，都是String类型，一个是name，一个是url。我们可以这样来引用。 1&lt;s:property value=&quot;name&quot; /&gt; //这样我们将可以输出迭代对象的name属性值。 如果我们希望使用&lt;s:url /&gt;来将跳转过后的url进行处理，该如何来做？ 12&lt;s:url value=&quot;%&#123;url&#125;&quot;/&gt; //%&#123;&#125;ognl的表达式，这样的值能够将url的值进行&lt;s:url/&gt;的处理实际上就是转为绝对路径。这样，我们就可以对付一些因跳转换产生的路径问题。 原因：因为&lt;s:iteratotr /&gt;以后，当前的对象应该就在ValueStack顶部了，这样当然的url实际上就是对象的url属性了。 使用ognl输出对应的值1&lt;s:textfield value=&quot;%&#123;#request.loginNames&#125;&quot;/&gt; 使用此表达式，会生成一个文本框，并且，如果request.attribute中有loginNames属性，将会做为些文本框的默认值。 如果只使用#request.loginNames在struts2的标签内部，是不会显示任何值的，注意外面加上的%{}符号，才会被正常的使用。 如果希望如EL语言一样直接输出文件，如在一个&lt;a&gt;&lt;/a&gt;之间的innerHTML文本为#request.loginNames的值，我们只要使用：&lt;s:property value=&quot;#request.loginNames&quot; /&gt;便可以正常使用！ 注： ${}是EL语言的%{}这样的形式是ognl表达式语言的，在struts2的标签内部，使用%{}这样的形式，在标签外部可以使用${} EL语言的方式。如果在struts2的标签内部使用${}这样的方式，会出现以下的错误提示： 1According to TLD or attribute directive in tag file, attribute value does not accept any expressions 2.很多时候，我们使用struts2的一些标签，属性是需要接受集合的，如果集合是保存在request,session，或者是值栈(非根对象的栈顶)，可以使用#变量名的方式，如果获取的值是在Action中通过特定的方法来获取，就需要使用如value=&quot;userList&quot;这样的方式，只是去掉了前面的#。 struts2中的OGNL用法User对象属性获取如User中有username和password字段 获取username属性 1&lt;s:property value=&quot;user.username&quot; /&gt; 获取password属性 1&lt;s:property value=&quot;user.password&quot; /&gt; 若User中又包含定义了address对象，address对象中包含有addr属性，则可以这样访问获取addr属性:1&lt;s:property value=&quot;user.address.addr&quot; /&gt; 若User中还包含一个get()的普通方法，可以这样调用1&lt;s:property value=&quot;user.get()&quot; /&gt; 以上是调用值栈中对象的普通方法，user为值栈中的对象 调用action中的静态方法get()，普通方法不能直接调用 1&lt;s:property value=&quot;@com.netshuai.action.ManagerAction@get()&quot; /&gt; 以上为调用非值栈中的静态方法 调用JDK中类的静态方法 1&lt;s:property value=&quot;@java.lang.Math@floor(32.56)&quot; /&gt; 上例也可写成 1&lt;s:property value=&quot;@@floor(32.56)&quot; /&gt; 省略前面的类则默认使用java.lang.Math类，其他类不可省略 调用普通类中的静态属性 1&lt;s:property value=&quot;@com.netshuai.model.Address@city&quot; /&gt; address中的city静态属性要用public声明 调用普通类的构造方法，如构造方法为 1234public User(String username)&#123; this.username=username;&#125; 调用方法为 1&lt;s:property value=&quot;new com.netshuai.model.User(&apos;hello&apos;).username&quot; /&gt; 则返回username值为hello 获取List 1&lt;s:property value=&quot;list&quot; /&gt; 获取List中的某一个元素 1&lt;s:property value=&quot;list[0]&quot; /&gt; 获取List的大小 1&lt;s:property value=&quot;list.size&quot; /&gt; 获取Set 1&lt;s:property value=&quot;set&quot; /&gt; 无法获取Set中的某一个元素，因为Set没有顺序 获取Map 1&lt;s:property value=&quot;map&quot; /&gt; 获取Map中所有key的值 1&lt;s:property value=&quot;map.keys&quot; /&gt; 获取Map中所有value的值 1&lt;s:property value=&quot;map.values&quot; /&gt; 获取Map中的某一个元素 1&lt;s:property value=&quot;map[&apos;k1&apos;]&quot; /&gt; 获取List所有对象 1&lt;s:property value=&quot;listObject&quot; /&gt; 需要重写toString()方法才能正常显示对象的值 利用投影获取List中所有对象的username属性 1&lt;s:property value=&quot;listObject.&#123;username&#125;&quot; /&gt; 利用投影获取List中第一个对象的username属性 1&lt;s:property value=&quot;listObject.&#123;username&#125;[0]&quot; /&gt; 利用选择获取List中年龄大于 30 的对象 1&lt;s:property value=&quot;listObject.&#123;?#this.age&gt;30&#125;&quot; /&gt; 利用选择获取List中年龄大于 30 的对象的username 1&lt;s:property value=&quot;listObject.&#123;?#this.age&gt;30&#125;.&#123;username&#125;&quot; /&gt; 利用选择获取List中年龄大于 30 的第一个对象的username 1&lt;s:property value=&quot;listObject.&#123;?#this.age&gt;30&#125;.&#123;username&#125;[0]&quot; /&gt; 或 1&lt;s:property value=&quot;listObject.&#123;^#this.age&gt;30&#125;.&#123;username&#125;&quot; /&gt; 利用选择获取List中年龄大于 30 的最后一个对象的username 1&lt;s:property value=&quot;listObject.&#123;$#this.age&gt;30&#125;.&#123;username&#125;&quot; /&gt; 获取parameters中的属性 1&lt;s:property value=&quot;#parameters.name&quot; /&gt; 获取request中的属性 1&lt;s:property value=&quot;#request.name&quot; /&gt; 获取session中的属性 1&lt;s:property value=&quot;#session.name&quot; /&gt; 获取application中的属性 1&lt;s:property value=&quot;#application.name&quot; /&gt; 按顺序遍历上面四个对象，然后返回首先找到的值 1&lt;s:property value=&quot;#attr.name&quot; /&gt; %{}可以取出存在值堆栈中的Action对象，直接调用它的方法，如%{getText(&#39;key&#39;)}可以取出国际化信息 ${}可以用在国际化资源文件中和struts2配置文件中 使用top获取值栈中第二个对象 1&lt;s:property value=&quot;[1].top.user&quot;/&gt; 使用top获取值栈中第二个对象的属性 1&lt;s:property value=&quot;[1].user&quot;/&gt; 调用值栈中action的静态方法(vs也可写做vs1) 1get()&lt;s:property value=&quot;@vs@get()&quot;/&gt; 调用值栈中第二个action的静态方法 1get()&lt;s:property value=&quot;@vs2@get()&quot;/&gt; 将一个对象放入值栈 1ActionContext.getContext().getValueStack().push(user); 转载自http://tomfish88.iteye.com/blog/1489506]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>struts2</tag>
        <tag>iterator</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OSI Model]]></title>
    <url>%2FOSI-Model.html</url>
    <content type="text"><![CDATA[定义OSI（Open System Interconnection）参考模型是国际标准化组织（ISO）制定的一个用于计算机或通信系统间互联的标准体系，一般称为OSI参考模型或七层模型。 模型图 各层描述物理层 设备之间的比特流传输、物理接口、电气特性等 物理层并不是物理媒体本身，它只是开放系统中利用物理媒体实现物理连接的功能描述和执行连接的规程。物理层提供用于建立、保持和断开物理连接的机械的、电气的、功能的和过程的条件。简而言之，物理层提供有关同步和全双工比特流在物理媒体上的传输手段，其典型的协议有RS 232C、RS 449/422/423、V.24和X.21、X.21bis等。 物理层是OSI的第一层，它虽然处于最底层，却是整个开放系统的基础。物理层为设备之间的数据通信提供传输媒体及互连设备，为数据传输提供可靠的环境。 为数据端设备提供传送数据的通路，数据通路可以是一个物理媒体，也可以是多个物理媒体连接而成。一次完整的数据传输，包括激活物理连接、传送数据和终止物理连接。所谓激活，就是不管有多少物理媒体参与，都要在通信的两个数据终端设备间连接起来，形成一条通路。 传输数据。物理层要形成适合数据传输需要的实体，为数据传送服务。一是要保证数据能在其上正确通过，二是要提供足够的带宽(带宽是指每秒钟内能通过的比特(Bit)数)，以减少信道上的拥塞。传输数据的方式能满足点到点，一点到多点，串行或并行，半双工或全双工，同步或异步传输的需要。 完成物理层的一些管理工作。 数据链路层 封装数据帧 数据链路可以粗略地理解为数据通道。物理层要为终端设备间的数据通信提供传输介质及其连接。介质是长期的，连接是有生存期的。在连接生存期内，收发两端可以进行不等的一次或多次数据通信。每次通信都要经过建立通信联络和拆除通信联络两个过程。这种建立起来的数据收发关系就叫做数据链路。而在物理媒体上传输的数据难免受到各种不可靠因素的影响而产生差错，为了弥补物理层上的不足，为上层提供无差错的数据传输，就要能对数据进行检错和纠错。数据链路的建立，拆除，对数据的检错，纠错是数据链路层的基本任务。 链路层是为网络层提供数据传送服务的，这种服务要依靠本层具备的功能来实现。链路层应具备如下功能： 链路连接的建立、拆除和分离； 帧定界和帧同步。链路层的数据传输单元是帧，协议不同，帧的长短和界面也有差别，但无论如何必须对帧进行定界； 顺序控制，指对帧的收发顺序的控制； 差错检测和恢复。还有链路标识，流量控制等等。差错检测多用方阵码校验和循环码校验来检测信道上数据的误码，而帧丢失等用序号检测。各种错误的恢复则常靠反馈重发技术来完成。 独立的链路产品中最常见的当属网卡，网桥也是链路产品。数据链路层将本质上不可靠的传输媒体变成可靠的传输通路提供给网络层。在IEEE802.3情况下，数据链路层分成了两个子层，一个是逻辑链路控制，另一个是媒体访问控制. OSI其中： AUI——连接单元接口 PMA——物理媒体连接 MAU——媒体连接单元 PLS——物理信令 MDI——媒体相关接口 网络层 封装数据报文 网络层的产生也是网络发展的结果。在联机系统和线路交换的环境中，网络层的功能没有太大意义。当数据终端增多时。它们之间有中继设备相连，此时会出现一台终端要求不只是与惟一的一台而是能和多台终端通信的情况，这就产生了把任意两台数据终端设备的数据链接起来的问题，也就是路由或者叫寻径。另外，当一条物理信道建立之后，被一对用户使用，往往有许多空闲时间被浪费掉。人们自然会希望让多对用户共用一条链路，为解决这一问题就出现了逻辑信道技术和虚拟电路技术。 中继控制层，其主要功能是利用数据链路层所保证的邻接节点间的无差错数据传输功能，通过路由选择和中继功能，实现两个端系统之间的数据传输。为此，网络层还具有多路复用功能，采用统计时分复用原理，将一条数据链路复用为多条逻辑信道，从而实现一个数据终端设备利用一条物理电路同时和多个远程数据通信设备的通信。网络层规定了网路连接的建立和拆除规程以及数据传送规程等。 路由选择和中继； 激活，终止网络连接； 在一条数据链路上复用多条网络连接，多采取分时复用技术； 检测与恢复； 排序，流量控制； 服务选择； 网络管理。 传输层 确定传输协议、确定数据传输的接口 主要功能是端开放系统之间数据的收妥确认。同时，还用于弥补各种通信网路的质量差异，对经过下三层之后仍然存在的传输差错进行恢复，进一步提高可靠性。另外，还通过复用、分段和组合、连接和分离、分流和合流等技术措施，提高吞吐量和服务质量。 传输层是两台计算机经过网络进行数据通信时，第一个端到端的层次，具有缓冲作用。当网络层服务质量不能满足要求时，它将服务加以提高，以满足高层的要求；当网络层服务质量较好时，它只用很少的工作。传输层还可进行复用，即在一个网络连接上创建多个逻辑连接。传输层也称为运输层。传输层只存在于端开放系统中，是介于低3层通信子网系统和高3层之间的一层，但是很重要的一层。因为它是源端到目的端对数据传送进行控制从低到高的最后一层。 有一个既存事实，即世界上各种通信子网在性能上存在着很大差异。例如电话交换网，分组交换网，公用数据交换网，局域网等通信子网都可互连，但它们提供的吞吐量，传输速率，数据延迟通信费用各不相同。对于会话层来说，却要求有一性能恒定的界面。传输层就承担了这一功能。它采用分流/合流，复用/介复用技术来调节上述通信子网的差异，使会话层感受不到。 此外传输层还要具备差错恢复，流量控制等功能，以此对会话层屏蔽通信子网在这些方面的细节与差异。传输层面对的数据对象已不是网络地址和主机地址，而是会话层的界面端口。上述功能的最终目的是为会话提供可靠的，无误的数据传输。传输层的服务一般要经历传输连接建立、数据传送、传输连接释放3个阶段才算完成一个完整的服务过程。而在数据传送阶段又分为一般数据传送和加速数据传送两种。 会话层 对应用会话的管理、同步 按照在应用进程之间约定的原则，按照正确的顺序收、发数据，进行各种形态的对话。会话层规定了会话服务用户间会话连接的建立和拆除规程以及数据传送规程。 会话层提供的服务是应用建立和维持会话，并能使会话获得同步。会话层使用校验点可使通信会话在通信失效时从校验点继续恢复通信。这种能力对于传送大的文件极为重要。会话层，表示层，应用层构成开放系统的高3层，面向应用进程提供分布处理、对话管理、信息表示、检查和恢复与语义上下文有关的传送差错等。为给两个对等会话服务用户建立一个会话连接，应该做如下几项工作： 将会话地址映射为运输地址； 数据传输阶段； 连接释放。 表示层 数据的表现形式、特殊数据的加密、压缩（解释传输的数据） 把应用层提供的信息变换为能够共同理解的形式，提供字符代码、数据格式、控制信息格式、加密等的统一表示。表示层的作用之一是为异种机通信提供一种公共语言，以便能进行互操作。这种类型的服务之所以需要，是因为不同的计算机体系结构使用的数据表示法不同。例如，IBM主机使用EBCDIC编码，而大部分PC机使用的是ASCII码。在这种情况下，便需要表示层来完成这种转换。通过前面的介绍，我们可以看出，会话层以下5层完成了端到端的数据传送，并且是可靠的、无差错的传送。但是数据传送只是手段而不是目的，最终是要实现对数据的使用。由于各种系统对数据的定义并不完全相同，最易明白的例子是键盘——其上的某些键的含义在许多系统中都有差异。这自然给利用其它系统的数据造成了障碍。表示层和应用层就担负了消除这种障碍的任务。 应用层 提供用户接口 实现应用进程（如用户程序、终端操作员等）之间的信息交换。同时，还具有一系列业务处理所需要的服务功能。应用层一般包括公共应用服务要素（CASE）和特定应用服务要素（SASE）。其中CASE提供应用进程中最基本的服务，向应用进程提供信息传送所必需的、但又独立于应用进程通信的能力。SASE实质上是各种应用进程在应用层中的映射，每一个SASE都针对某一类具体应用，例如文件传送、访问和管理（FTAM）、虚拟终端（VT）、消息处理系统（MHS）、电子数据互换（EDI）和目录查询等。 应用层向应用程序提供服务，这些服务按其向应用程序提供的特性分成组，并称为服务元素。有些可为多种应用程序共同使用，有些则为较少的一类应用程序使用。应用层是开放系统的最高层，是直接为应用进程提供服务的。其作用是在实现多个系统应用进程相互通信的同时，完成一系列业务处理所需的服务。 OSI七层模型 相关协议 缩写应用层HTTP 超文本传输协议FTP 文件传输协议SMTP 简单邮件传输协议TELNETTCP/IP 终端仿真协议POP3 邮局协议第三版Finger 用户信息协议NNTP 网络新闻传输协议IMAP4 因特网信息访问协议第四版LPR UNIX 远程打印协议Rwho UNIX 远程 Who协议Rexec UNIX 远程执行协议Login UNIX 远程登陆协议RSH UNIX 远程Shell协议NTF HP 网络文件传输协议RDA HP 远程数据库访问协议VT 虚拟终端仿真协议RFA HP 远程文件访问协议RPC Remote Process Comm.S-HTTP 安全超文本传输协议GDP 网关发现协议X-WindowCMOT 基于TCP/IP的CMIP协议SOCKS 安全套接字协议FANP 流属性通知协议SLP 服务定位协议MSN 微软网络服务Radius 远程用户拨号认证服务协议DNS 域名系统NFS 网络文件系统协议NIS SUN 网络信息系统协议R-STAT SUN 远程状态协议NSM SUN 网络状态监测协议PMAP SUN 端口映射协议MountLPR UNIX远程打印协议 常用UDP协议的应用层服务BOOTP 引导协议DHCP 动态主机配套协议NTP 网络时间协议TFTP 简单文件传输协议SNMP 简单网络管理协议 表示层DECnet NSPLPP 轻量级表示协议NBSSN NetBIOS 会话服务协议XDP 外部数据表示协议IPX 会话层SSL 安全套接字层协议TLS 传输层安全协议DAP 目录访问协议LDAP 轻量级目录访问协议RPC 远程过程调用协议VINES NETRPCVFRPNeTBIOSIPX 传输层XOT 基于tcp之上的X协议Van Jacobson 压缩TCP协议ISO-DE ISO 开发环境——–&gt;NetBISOTALI 传输适配层接口协议DSI、NetBIOS、IP NeTBIOS、ISO-TP SSP、SMB、MSRPCUDP 用户数据报协议RUDP 可靠的用户数据报协议Mobile IP 移动IP协议 网络层IP/IPv6 互联网协议/互联网协议第六版ICMPv6 互联网控制信息协议第六版ICMP 互联网控制信息协议IGMP 互联网组管理协议SLIP 串行线路IP协议 安全协议AH 认证头协议ESP 安装封装有效载荷协议 路由协议EGP 外部网关协议OSPF 开放最短路径优先协议IGRP 内部网关路由协议NHRP 下一跳解析协议IE-IRGP 增强内部网关路由选择协议RIPng for IPv6 IPv6路由信息协议GGP 网关到网关协议VRRP 虚拟路由器冗余协议PGM 实际通用组播协议RSVP 资源预留协议PIM-DM 密集模式独立组播协议DVMRP 距离矢量组播路由协议RIP2 路由信息协议第二版PIM-SM 稀疏模式独立组播协议MOSPF 组播开放最短路径优先协议 数据链路层MPLS 多协议标签交换协议XTP 压缩传输协议DCAP 数据转换客户访问协议SLE 串行连接封装协议IPinIP IP套IP封装协议 隧道协议PPTP 点对点隧道协议L2F 第二层转发协议L2TP 第二层隧道协议ATMP 接入隧道管理协议Cisco 协议CDP 思科发现协议CGMP 思科组管理协议 地址解析协议ARP 地址解析协议RAR 逆向地址解析协议 物理层IEEE 802.2Ethernet v.2Internetwork]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>OSI</tag>
        <tag>七层模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Common patches on Hackintosh]]></title>
    <url>%2FCommon-patches-on-Hackintosh.html</url>
    <content type="text"><![CDATA[先说说怎样强制加载某个驱动如下，KextToPatch并列ForceKextsToLoad，设置kext路径12345&lt;key&gt;ForceKextsToLoad&lt;/key&gt;&lt;array&gt; &lt;string&gt;\System\Library\Extensions\AppleHDA.kext&lt;/string&gt; &lt;string&gt;\Extra\Extensions&lt;/string&gt;&lt;/array&gt; 笔记本显存修改至2048MB HD4200_4400_4600 Mobile： 1234Name： AppleIntelFramebufferAzulFind： 01030303 00000002 00003001 00006000 00000060Replace： 01030303 00000002 00003001 00009000 00000080Comment: 1536MB -&gt; 2048MB for HD4200_4400_4600 Mobile HD620 Mobile： 1234Name： AppleIntelKBLGraphicsFramebufferFind： 01030303 00002002 00000000 00000060Replace： 01030303 00002002 00000000 00000080 Comment: 1536MB -&gt; 2048MB for HD620 Mobile HD630 Mobile： 1234Name： AppleIntelKBLGraphicsFramebufferFind： 01030303 00006002 00005001 00000060Replace： 01030303 00006002 00005001 00000080Comment: 1536MB -&gt; 2048MB for HD630 Mobile HD520_530_540 Mobile： 1234Name： AppleIntelSKLGraphicsFramebufferFind： 01030303 00002002 00005001 00000060Replace： 01030303 00002002 00005001 00000080Comment: 1536MB -&gt; 2048MB for HD520_530_540 Mobile HD5500 Mobile： 1234Name： AppleIntelBDWGraphicsFramebuffer Find: 01030303 00002002 00005001 00000060Replace: 01030303 00002002 00005001 00000080Comment: 1536MB -&gt; 2048MB for HD5500 Mobile 开启Trim1234Name: com.apple.iokit.IOAHCIBlockStorageFind: 00415050 4C452053 534400Replcae: 00000000 00000000 000000Comment: Enable TRIM for SSD 花屏补丁12345Name: com.apple.iokit.IOGraphicsFamilyFind: 4188C4EB 11Replcae: 4188C4EB 31Comment: Boot graphics glitch, 10.10.2/10.10.3MatchOS: 10.10.2,10.10.3 12345Name: com.apple.iokit.IOGraphicsFamilyFind: 01000075 17Replcae: 010000EB 17Comment: Boot graphics glitch, 10.10.x/10.11.x (credit lisai9093, cecekpawon)MatchOS: 10.10.x,10.11.x 12345Name: com.apple.iokit.IOGraphicsFamilyFind: 01000075 25Replcae: 010000EB 25Comment: Boot graphics glitch, 10.12.dp1 (credit denskop)MatchOS: 10.12.x 12345Name: com.apple.iokit.IOGraphicsFamilyFind: 01000075 22Replcae: 010000EB 22Comment: Boot graphics glitch, 10.13 beta (based on denskop patch)MatchOS: 10.13.x DVMT补丁 Broadwell 12345Name: com.apple.driver.AppleIntelBDWGraphicsFramebufferFind: 39CF763CReplcae: 39CFEB3CComment: Disable minStolenSize less or equal fStolenMemorySize assertion, 10.10.x (based on Austere.J patch)MatchOS: 10.10.x 12345Name: com.apple.driver.AppleIntelBDWGraphicsFramebufferFind: 4139C476 3EReplcae: 4139C4EB 3EComment: Disable minStolenSize less or equal fStolenMemorySize assertion, 10.11.beta (based on Austere.J patch)MatchOS: 10.11.x 12345Name: com.apple.driver.AppleIntelBDWGraphicsFramebufferFind: 8945C839 C7764FReplcae: 8945C839 C7EB4FComment: Disable minStolenSize less or equal fStolenMemorySize assertion, 10.12.0 (based on Austere.J patch)MatchOS: 10.12.x 12345Name: com.apple.driver.AppleIntelBDWGraphicsFramebufferFind: 4C895DB8 7644Replcae: 4C895DB8 EB44Comment: Disable minStolenSize less or equal fStolenMemorySize assertion, 10.13.0/1 (credit PMHeart)MatchOS: 10.13.0,10.13.1 12345Name: com.apple.driver.AppleIntelBDWGraphicsFramebufferFind: 4C8945C0 7644Replcae: 4C8945C0 EB44Comment: Disable minStolenSize less or equal fStolenMemorySize assertion, 10.13.2/3 (credit RehabMan)MatchOS: 10.13.2,10.13.3 Skylake 12345Name: com.apple.driver.AppleIntelSKLGraphicsFramebufferFind: 4139C476 2AReplcae: 4139C4EB 2AComment: Disable minStolenSize less or equal fStolenMemorySize assertion, 10.11.4 (based on Austere.J patch)MatchOS: 10.11.x 12345Name: com.apple.driver.AppleIntelSKLGraphicsFramebufferFind: 8945C839 C67651Replcae: 8945C839 C6EB51Comment: Disable minStolenSize less or equal fStolenMemorySize assertion, 10.12.0 (based on Austere.J patch)MatchOS: 10.12.x 12345Name: com.apple.driver.AppleIntelSKLGraphicsFramebufferFind: 4C8955B8 7640Replcae: 4C8955B8 EB40Comment: Disable minStolenSize less or equal fStolenMemorySize assertion, 10.13.0/1 (credit PMHeart)MatchOS: 10.13.0,10.13.1 12345Name: com.apple.driver.AppleIntelSKLGraphicsFramebufferFind: 4C895DB8 7640Replcae: 4C895DB8 EB40Comment: Disable minStolenSize less or equal fStolenMemorySize assertion, 10.13.2/3 (credit PMHeart, , shdkpr2008)MatchOS: 10.13.2,10.13.3 Kabylake 12345Name: com.apple.driver.AppleIntelKBLGraphicsFramebufferFind: 4C895DC0 7646Replcae: 4C895DC0 EB46Comment: Disable minStolenSize less or equal fStolenMemorySize assertion, 10.13.0/1 (credit PMHeart)MatchOS: 10.13.0,10.13.1 12345Name: com.apple.driver.AppleIntelKBLGraphicsFramebufferFind: 4C896DB8 7646Replcae: 4C896DB8 EB46Comment: Disable minStolenSize less or equal fStolenMemorySize assertion, 10.13.2/3 (credit RehabMan)MatchOS: 10.13.2,10.13.3 硬盘橙色1234Name: AppleAHCIPortFind: 45787465 726E616CReplcae: 496E7465 726E616CComment: Define external drivers as internal to fix yellow drive icons 让没有ECC内存的机器利用MacPro4,1或者 MacPro5,1机型启动1234Name: AppleTyMCEDriverFind: 720A004D 61635072 6F342C31 004D6163 50726F35 2C310058Replcae: 720A0000 00000000 00000000 00000000 00000000 00000058Comment: Allow booting with a MacPro4,1 or MacPro5,1 SMBIOS definition without ECC memory 万能声卡将Headphones显示替代为Telephones1234Name: VoodooHDAFind: 48656164 70686F6E 657300Replcae: 54656C65 70686F6E 657300Comment: For VoodooHDA replacing the string Headphones with Telephones]]></content>
      <categories>
        <category>Hackintosh</category>
      </categories>
      <tags>
        <tag>patch</tag>
        <tag>Hackintosh</tag>
        <tag>补丁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Common command in macOS]]></title>
    <url>%2FCommon-command-in-macOS.html</url>
    <content type="text"><![CDATA[Trim 开启1$ sudo trimforce enable 关闭1$ sudo trimforce disable 查看启用的ig-platform-id1$ ioreg -l | grep -y platform-id 笔记本开启插电源出提示音: 开启:1$ defaults write com.apple.PowerChime ChimeOnAllHardware -bool true; open /System/Library/CoreServices/PowerChime.app &amp; 关闭:1$ defaults write com.apple.PowerChime ChimeOnAllHardware -bool false; killall PowerChime 去掉apfs.efi最新版本的日志调试显示123$ cd ~/Desktop &amp; cp /usr/standalone/i386/apfs.efi .$ perl -i -pe &apos;s|\x00\x74\x07\xb8\xff\xff|\x00\x90\x90\xb8\xff\xff|sg&apos; ./apfs.efi 提取显示器EDID及设备ID厂商ID EDID1$ ioreg -lw0 | grep -i &quot;IODisplayEDID&quot; | sed -e &apos;s/.*&lt;//&apos; -e &apos;s/&gt;//&apos; PID1$ ioreg -l | grep &quot;DisplayProductID&quot; VID1$ ioreg -l | grep &quot;DisplayVendorID&quot; 为macOS Sierra以上的OS X开启任何来源1$ sudo spctl --master-disable 查看加载的非官方内核扩展 – kext1$ kextstat | grep -v &quot;com.apple&quot; | grep -v Energy 查看显示器硬件信息 EDID1$ ioreg -l | grep &quot;IODisplayEDID&quot; ProductID1$ ioreg -l | grep &quot;DisplayProductID&quot; VendorID1$ ioreg -l | grep &quot;DisplayVendorID&quot; 待续…]]></content>
      <categories>
        <category>Hackintosh</category>
      </categories>
      <tags>
        <tag>command</tag>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Make a bootable install image to install macOS High Sierra 10.13.4]]></title>
    <url>%2FMake-a-bootable-install-media-image-to-install-macOS-High-Sierra-10-13-4.html</url>
    <content type="text"><![CDATA[前言随着新的macOS High Sierra 10.13.4操作系统发布，很多盆友迫不及待的做了一个.dmg格式的压缩镜像以备用，但发现用Apple官方的方法制作出的镜像用CLOVER引导时是看不到安装镜像的，最后，在黑果小兵的帮助下，终于找到了解决方法。 教程开始下载app镜像首先去AppleStore下载原版的app镜像https://itunes.apple.com/cn/app/macos-high-sierra/id1246284741?l=en&amp;mt=12 制作镜像打开磁盘工具 点击顶部状态栏File -&gt; New Image -&gt; Blank Image 如上图写一个好听的名字，大小大于app镜像的大小，我直接大一点，写了6.8GB，选好保存位置，然后点击save。 打开终端，输入sudo空格，找到下载好的app镜像(一般在应用程序里)，右键显示包内容，依次打开/Contents/Resources，将createinstallmedia拖到终端，输入空格，然后输入--volume，再空格，然后将准备好的安装磁盘，拖动至终端，再空格，接着输入--applicationpath，空格，将app镜像拖放到终端，空格，输入--nointeraction，回车，输入密码，再回车，等待镜像写入完成。 如图 进行镜像修复然后下载附件，这个是我从10.13.3的镜像中提取的，13.4缺少这个启动的必要文件。链接:https://pan.baidu.com/s/14R8rEk7PK9exu0lDvPh7jA 密码:fcwt，将下载的压缩包解压，按住Command Shift .显示隐藏文件，即可看到里面的.IA开头的一个目录和一个文件，将这两个文件拷贝到刚才做的安装盘内。 拷贝之前 拷贝之后 右键.IABootFilesSystemVersion.plist用plist编辑器打开，例如Xcode、Plist Edit 做以下修改 保存退出 打开/System/Library/CoreServices 拷贝图中选中项，将其拷贝到/.IABootFiles/目录下，然后打开/System/Library/PrelinkedKernels/，将下图选中的文件也拷贝到/.IABootFiles/目录下 最后/.IABootFiles/目录下内容如下 这时重启进入CLOVER引导界面就可以看到安装盘了。]]></content>
      <categories>
        <category>Hackintosh</category>
      </categories>
      <tags>
        <tag>image</tag>
        <tag>10.13.4</tag>
        <tag>镜像</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[How to patch Framebuffer change VRAM from 1536MB to 2048MB]]></title>
    <url>%2FHow-to-patch-Framebuffer-change-VRAM-from-1536MB-to-2048MB.html</url>
    <content type="text"><![CDATA[前言：本来不打算发这个帖子的，因为好多人觉得没有什么用，但前几天帮论坛好友阿林解决他hd4600花屏问题时，发现这个方法还是有一定作用的。之前在10.12区有坛友的4600部分区域出现花屏的情况，最后通过修改注入的ig来解决的，大家都知道，4200 4400 4600都是靠FakeID为0x04128086和ig为0x0a260006然后配合FakePCIID和FakePCIID_HD_Graphics两个kext来驱动的，大家也知道，一部分4600也可以用0x04160000而不需要FakeID注入来驱动（相应的不少4400也可以用0x0a160000而不需要FakeID来驱动），两种方法都可以驱动核显，但区别还是有的，最容易发现的就是显存了，第一种方法驱动后都是1536m，第二种则是1024m。而前面提到的4600部分区域花屏的案例则是用第二种方式来解决的，后来经过测试，发现通过对framebuffer进行patch以达到2048m的显存也可以解决这个问题，于是这个方法就被我记在心里了。后来在帮阿林解决了他的花屏问题后，决定还是把相关方法写出来，虽然没什么技术含量，但也能为景友提供一个思路。废话就说到这，下面说方法: 开工查看FB以及ig首先，确定你当前加载的Framebuffer，终端执行以下命令 1$ kextstat | grep -y AppleIntel 如图，看输出结果中带Framebuffer的就是我们需要的（haswell之前的是带FB的），图中我的就是AppleIntelFramebufferAzul然后执行以下命令查看当前使用的ig 1$ ioreg -l | grep ig-platform-id 如图我的就是0x0a260006,有朋友不清楚，不是0600260a吗，下次一定要知道，这种id将每两位一组分组，然后从后往前排序，最后由于是十六进制，我们在最前面加上0x来表示，就得出了0x0a260006，这就是我们的id，当然了，后面步骤中用到的还是0600260a。 下载并安装hexfiend我直接放链接了链接:https://pan.baidu.com/s/1EhkVv2eaUE1u_Gmp87arJw 密码:lm1o 在FB中查找ig进行处理然后，在/System/Library/Extensions下找到和第一步找出的Frambuffer同名kext，以我的为例，就是AppleIntelFramebufferAzul.kext,右键显示包内容，在/Contents/MacOS下将kext的同名文件拷贝到桌面，以我的为例就是AppleIntelFramebufferAzul。 右键此文件打开方式选我们刚才安装的hexfiend，如图 快捷键command + F调出搜索框，输入刚才在第一步找到的ig，回车搜索，找到后面紧跟01030303的那一串字符，如图 从搜索的ig后面第一串开始，到00000060结束，将这些字符串拷贝到一个文本文档，并八个数字一组，整理好，然后再复制一行，将第二行最后的60改为80，如图 第一串就是我们要做的patch的Find，第二串是Replace，而Name则是第一步中的Framebuffer名字，我这里就是AppleIntelFramebufferAzul，Comment就无所谓了，我写成Change VRAM from 1536MB to 2048MB for HD4400，这时我们的补丁就做好了。 最后将patch打到config.plist 然后保存重启，就会发现关于本机的显存从原来的1536MB变成了2048MB 如果没效果，可以尝试重建缓存。 帖子的最后，我将之前做的几个patch贴出来，大家可以尝试使用 HD4200_4400_4600 Mobile 1234Name： AppleIntelFramebufferAzulFind： 01030303 00000002 00003001 00006000 00000060Replace： 01030303 00000002 00003001 00009000 00000080Comment： 1536MB -&gt; 2048MB for HD4200_4400_4600 Mobile HD620 Mobile： 1234Name： AppleIntelKBLGraphicsFramebufferFind： 01030303 00002002 00000000 00000060Replace： 01030303 00002002 00000000 00000080 Comment： 1536MB -&gt; 2048MB for HD620 Mobile HD630 Mobile： 1234Name： AppleIntelKBLGraphicsFramebufferFind： 01030303 00006002 00005001 00000060Replace： 01030303 00006002 00005001 00000080Comment： 1536MB -&gt; 2048MB for HD630 Mobile HD520_530_540 Mobile： 1234Name： AppleIntelSKLGraphicsFramebufferFind： 01030303 00002002 00005001 00000060Replace： 01030303 00002002 00005001 00000080Comment： 1536MB -&gt; 2048MB for HD520_530_540 Mobile HD5500 Mobile： 1234Name： AppleIntelBDWGraphicsFramebuffer find： 01030303 00002002 00005001 00000060Replace： 01030303 00002002 00005001 00000080Comment： 1536MB -&gt; 2048MB for HD5500 Mobile]]></content>
      <categories>
        <category>Hackintosh</category>
      </categories>
      <tags>
        <tag>显存</tag>
        <tag>FB</tag>
        <tag>花屏</tag>
        <tag>Framebuffer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[How to change your username on your mac]]></title>
    <url>%2FHow-to-change-your-username-on-your-mac.html</url>
    <content type="text"><![CDATA[帐户信息修改1System Preferences &gt; Users &amp; Groups &gt; 右单击当前用户 &gt; Advanced Options 注意：用了一段时间的电脑不建议修改，可能会导致很多软件要重新安装。 主机名修改1$ sudo scutil --set HostName MacBookPro 计算机名修改1$ sudo scutil --set ComputerName MacBookPro]]></content>
      <categories>
        <category>Hackintosh</category>
      </categories>
      <tags>
        <tag>账户名</tag>
        <tag>主机名</tag>
        <tag>计算机名</tag>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[How to unzip packages without .DS_store]]></title>
    <url>%2FHow-to-unzip-packages-without-DS-store.html</url>
    <content type="text"><![CDATA[Mac下面压缩的时候总会自动生成 .DS_store 文件，用户可以自行选择是否需要生成，执行下面命令之后需要重启Mac生效。 禁止 .DS_store生成： 1$ defaults write com.apple.desktopservices DSDontWriteNetworkStores -bool TRUE 恢复 .DS_store生成： 1$ defaults delete com.apple.desktopservices DSDontWriteNetworkStores]]></content>
      <categories>
        <category>Hackintosh</category>
      </categories>
      <tags>
        <tag>.DS_store</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0-1 backpack]]></title>
    <url>%2F0-1-backpack.html</url>
    <content type="text"><![CDATA[递归123456789101112131415161718192021222324252627282930313233//// main.c// algorithm//// Created by athlonreg on 17/01/2018.// Copyright © 2018 athlonreg. All rights reserved.//#include &lt;stdio.h&gt;#define n 5#define c 10int weight[n]=&#123;2,2,6,5,4&#125;, value[n]=&#123;6,3,5,4,6&#125;;int f(int i,int j)&#123; int m1,m2; if(i==n-1)&#123; if(j&gt;=weight[i]) return value[i]; return 0; &#125; if(j&lt;weight[i]) return f(i+1,j); m1=f(i+1,j); m2=f(i+1,j-weight[i])+value[i]; return m1&gt;m2?m1:m2;&#125;int main(int argc, const char * argv[]) &#123; printf(&quot;%d\n&quot;,f(0,c)); return 0;&#125; 运行结果 动态规划1234567891011121314151617181920212223242526272829303132333435//// main.c// algorithm//// Created by athlonreg on 17/01/2018.// Copyright © 2018 athlonreg. All rights reserved.//#include &lt;stdio.h&gt;#define n 5#define c 10int weight[n]=&#123;2,2,6,5,4&#125;, value[n]=&#123;6,3,5,4,6&#125;;int main(int argc, const char * argv[]) &#123; int s[n][c+1]; int i,j; for(j=0;j&lt;=c;j++)&#123; if(j&gt;weight[n-1]) s[n-1][j]=value[n-1]; else s[n-1][j]=0; &#125; for(i=n-2;i&gt;=0;i--)&#123; for(j=0;j&lt;=c;j++)&#123; if(j&lt;weight[i]) s[i][j]=s[i+1][j]; else s[i][j]=s[i+1][j]&gt;(s[i+1][j-weight[i]]+value[i])?s[i+1][j]:(s[i+1][j-weight[i]]+value[i]); &#125; &#125; printf(&quot;%d\n&quot;,s[0][c]); return 0;&#125; 运行结果 回溯12345678910111213141516171819202122232425262728293031323334353637//// main.c// algorithm//// Created by athlonreg on 17/01/2018.// Copyright © 2018 athlonreg. All rights reserved.//#include &lt;stdio.h&gt;#define n 5#define c 10int weight[n]=&#123;2,2,6,5,4&#125;, value[n]=&#123;6,3,5,4,6&#125;;int maxvalue, tempvalue, tempweight;void traceback(int t)&#123; if(t==n)&#123; if(tempvalue&gt;maxvalue) maxvalue=tempvalue; return; &#125; if(tempweight+weight[t]&lt;=c)&#123; tempweight+=weight[t]; tempvalue+=value[t]; traceback(t+1); tempweight-=weight[t]; tempvalue-=value[t]; &#125; traceback(t+1);&#125;int main(int argc, const char * argv[]) &#123; traceback(0); printf(&quot;%d\n&quot;,maxvalue); return 0;&#125; 运行结果]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>0-1背包问题</tag>
        <tag>algorithm</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Reverse part of array]]></title>
    <url>%2FReverse-part-of-array.html</url>
    <content type="text"><![CDATA[代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546//// main.c// algorithm//// Created by athlonreg on 17/01/2018.// Copyright © 2018 athlonreg. All rights reserved.//#include &lt;stdio.h&gt;#include &lt;math.h&gt;#define n 8int a[n]=&#123;1,4,2,6,8,5,7,3&#125;;void print()&#123; for(int i=0;i&lt;n;i++)&#123; printf(&quot;%3d&quot;, a[i]); &#125; putchar(&apos;\n&apos;);&#125;void swap(int *a, int *b)&#123; int temp=*a; *a=*b; *b=temp;&#125;void swapposition(int a[], int low, int high, int k)&#123; int i, j; for(i=low,j=k-1;i&lt;j;i++,j--) swap(&amp;a[i], &amp;a[j]); for(i=k,j=high;i&lt;j;i++,j--) swap(&amp;a[i], &amp;a[j]); for(i=low,j=high;i&lt;j;i++,j--) swap(&amp;a[i], &amp;a[j]);&#125;int main(int argc, const char * argv[]) &#123; int k; print(); scanf(&quot;%d&quot;, &amp;k); swapposition(a, 0, n-1, k); print(); return 0;&#125; 运行结果]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>算法</tag>
        <tag>逆置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[n queen]]></title>
    <url>%2Fn-queen.html</url>
    <content type="text"><![CDATA[代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//// main.c// algorithm//// Created by athlonreg on 17/01/2018.// Copyright © 2018 athlonreg. All rights reserved.//#include &lt;stdio.h&gt;#include &lt;math.h&gt;#define n 8int a[n];int count=0;int judge(int t)&#123; if(t==n) return 0; for(int i=0;i&lt;t;i++)&#123; for(int j=i+1;j&lt;=t;j++)&#123; if(a[i]==a[j]) return 0; if(abs(i-j)==abs(a[i]-a[j])) return 0; &#125; &#125; return 1;&#125;void traceback(int t)&#123; int i; if(t==n)&#123; count++; for(i=0;i&lt;n;i++) printf(&quot;%3d&quot;, a[i]); printf(&quot;\n&quot;); &#125; for(i=0;i&lt;n;i++)&#123; a[t]=i; if(judge(t)) traceback(t+1); &#125;&#125;int main(int argc, const char * argv[]) &#123; traceback(0); printf(&quot;%d\n&quot;, count); return 0;&#125; 运行结果]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>算法</tag>
        <tag>n皇后问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RecurMatrix]]></title>
    <url>%2FRecurMatrix.html</url>
    <content type="text"><![CDATA[代码12345678910111213141516171819202122232425262728293031323334353637383940414243//// main.c// algorithm//// Created by athlonreg on 17/01/2018.// Copyright © 2018 athlonreg. All rights reserved.//#include &lt;stdio.h&gt;#define n 6int a[n+1]=&#123;30,35,15,5,10,20,25&#125;;int b[n+1][n+1];int RecurMatrix(int i, int j)&#123; if(i==j) return 0; int minvalue=RecurMatrix(i, i)+RecurMatrix(i+1, j)+a[i-1]*a[i]*a[j]; b[i][j]=i; for(int k=i+1;k&lt;j;k++)&#123; int tempvalue=RecurMatrix(i, k)+RecurMatrix(k+1, j)+a[i-1]*a[k]*a[j]; if(tempvalue&lt;minvalue)&#123; minvalue=tempvalue; b[i][j]=k; &#125; &#125; return minvalue;&#125;void traceback(int i, int j)&#123; if(i==j) return; traceback(i, b[i][j]); traceback(b[i][j]+1, j); printf(&quot;A[%d-%d]*A[%d-%d]\n&quot;, i, b[i][j], b[i][j]+1, j);&#125;int main(int argc, const char * argv[]) &#123; printf(&quot;%d\n&quot;, RecurMatrix(1, n)); traceback(1, n); return 0;&#125; 运行结果]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>算法</tag>
        <tag>矩阵连乘问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BinarySearch]]></title>
    <url>%2FBinarySearch.html</url>
    <content type="text"><![CDATA[代码1234567891011121314151617181920212223242526272829303132//// main.c// algorithm//// Created by athlonreg on 17/01/2018.// Copyright © 2018 athlonreg. All rights reserved.//#include &lt;stdio.h&gt;#define n 5int arr[n]=&#123;1,2,3,4,5&#125;;int BinarySearch(int a[], int low, int high, int k)&#123; while(low&lt;high)&#123; int mid=(low+high)/2; if(a[mid]==k) return mid; else if(a[mid]&gt;k) return BinarySearch(a, low, mid-1, k); else return BinarySearch(a, mid+1, high, k); &#125; return -1;&#125;int main(int argc, const char * argv[]) &#123; int x=4; printf(&quot;%d\n&quot;, BinarySearch(arr, 0, n-1, x)); return 0;&#125; 运行结果]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>算法</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ldu crawl based on nodejs]]></title>
    <url>%2Fldu-crawl-based-on-nodejs.html</url>
    <content type="text"><![CDATA[简介基于Nodejs实现的网络爬虫，爬取鲁东大学官网指定数量的新闻保存至本地。 项目下载终端执行： 1$ git clone https://github.com/athlonreg/ldu-crawl-based-on-nodejs.git Windows用户请去项目首页下载，如图： 项目目录结构项目目录共有data、image、node_modules三个文件夹，其中node_modules为项目用到的node模块包，data和image分别用以存储抓取到的所有新闻，data用以保存文本内容，image用以保存所有文章内的图片，以文章标题命名。如下图所示： index.html是程序的web主页面；server.js用以启动服务器；spider.js是爬虫主程序；test.sh用以启动爬虫开始抓取工作。 程序运行方法For Windows 两种方式，首先将项目放到桌面： 1、在根目录利用cmd或者Git Bash执行： 1$ node spider.js 爬虫程序即开始执行。 2、双击test.sh或者利用Git Bash执行(若执行闪退请在Git Bash执行)： 12$ chmod +x test.sh$ ./test.sh 即可自动完成所有工作，抓取工作完成后，命令行自动退出。 For macOS 两种方式 1、假设项目放于桌面，打开终端执行： 123$ cd ~/Desktop/ldu_crawl/$ chmod +x test.sh$ ./test.sh 即可自动完成所有工作，抓取工作完成后，命令行自动退出。 2、假设项目放于桌面，打开终端执行： 12$ cd ~/Desktop/ldu_crawl/$ node spider.js 预设界面查看启动服务器终端执行： 1$ node server.js 打开浏览器网址输入： 1http://127.0.0.1:8080/ 即可打开项目首页。如图所示： 点击了解使用方法即可查看详细使用说明。]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
        <tag>crawl</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Install and config mysql on mac]]></title>
    <url>%2FInstall-and-config-mysql-on-mac.html</url>
    <content type="text"><![CDATA[准备安装HomeBrew1$ /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 等待安装完成即可 安装安装MySQL1$ brew install mysql 等待安装完成，如下图 检查安装是否正常1$ mysql --version 如果出现版本号，则正常，如下图 若提示command not found，则依次执行下面两条命令 12$ cd /usr/local/bin/$ sudo ln -fs /usr/local/mysql/bin/mysql mysql 配置配置root账号的密码，默认无密码开启安全模式启动mysql1$ sudo /usr/local/mysql/bin/mysqld_safe --skip-grant-tables 修改密码首先登录mysql1$ mysql -u root 配置root账号的密码 命令中的****为要修改的密码 1UPDATE mysql.user SET authentication_string=PASSWORD(&apos;****&apos;) WHERE User=&apos;root&apos;; 刷新权限1FLUSH PRIVILEGES; 退出mysql1\q 验证密码1$ mysql -u root -p 会提示输入密码，输入刚才设定的密码后如果能够进入mysql则说明配置成功。 终端开启和关闭mysql服务12$ sudo /usr/local/mysql/support-files/mysql.server start$ sudo /usr/local/mysql/support-files/mysql.server stop]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Clover ACPI hotpatch]]></title>
    <url>%2FClover-ACPI-hotpatch.html</url>
    <content type="text"><![CDATA[Preface–序言This blog is created by me to introduce how to using Clover to hotpatch ACPI，and provide an Chinese version。 我写这篇博客是为了介绍如何使用Clover对ACPI使用hotpatch，并翻译原贴提供中文参考帖。 Brief description for hotpatch–hotpatch概要In RehabMan’s GitHub homepage, a repository named OS-X-Clover-Laptop-Config Contains some Clover config.plist for common Intel graphics and hotpatch for common configurations.More information in here. RehabMan的GitHub有一个仓库–OS-X-Clover-Laptop-Config,里面包含了一些适用于常见的英特尔核芯显卡的config.plist,还有hotpatch。点击这里了解更多。 There are some handy SSDTs for use with Clover ACPI hotpatch (in conjunction with hotpatch/config.plist) If you understand ACPI, you may find the SSDTs and hotpatch/config.plist quite useful. 这儿有许多针对使用Clover ACPI hotpatch(连同使用hotpatch/config.plist)的SSDT。如果你理解了ACPI，你会发现这些SSDT和hotpatch/config.plist相当重要。 Read here for the hotpatch guide: https://www.tonymacx86.com/threads/guide-using-clover-to-hotpatch-acpi.200137/ 这里是hotpatch的‘入门引导贴。https://www.tonymacx86.com/threads/guide-using-clover-to-hotpatch-acpi.200137/ A brief description of each hotpatch SSDT is provided below–下面是每一个 hotpatch SSDT 的概要SSDT-Config.dsl: This file provides configuration data for other SSDTs. Read the comments within the file for more information. SSDT-Config.dsl:这个文件为其他SSDT提供参数。请阅读文件中的注释以获得更多信息。 SSDT-Debug.dsl: This SSDT is for use with ACPIDebug.kext. Instead of patching your DSDT to add the RMDT device, you can use this SSDT and refer to the methods with External. See ACPIDebug.kext documentation for more information regarding the RMDT methods. 这个SSDT和ACPIDebug.kext一起使用。不需要对你的DSDT打补丁增加RMDT设备，你可以使用这个SSDT通过External导入这个方法。关于RMDT方法，要了解更多请参阅ACPIDebug.kext文档。 SSDT-XOSI.dsl: This SSDT provides the XOSI method, which is a replacement for the system provided _OSI object when the _OSI-&gt;XOSI patch is being used. This is actually one of the examples in the Clover ACPI hotpatch guide, linked above. 这个SSDT提供了XOSI方法，当打了_OSI-&gt;XOSI补丁时，XOSI方法会替换系统提供的_OSI对象。实际上，这就是Clover ACPI hotpatch入门参考帖的一个例子，链接在下面。 SSDT-IGPU.dsl This SSDT injects Intel GPU properties depending on the configuration data in SSDT-Config and the device-id that is discovered to be present on the system. It assumes the IGPU is named IGPU (typical is GFX0, requring GFX0-&gt;IGPU rename). Configured with RMCF.TYPE, RMCF.HIGH, RMCF.IGPI, and SSDT-SkylakeSpoof.aml. 这个SSDT根据SSDT-config的配置数据和系统中发现的设备id注入了Intel GPU–核芯显卡属性。它假定IGPU被命名成IGPU(通常是GFX0，需要重命名GFX0-&gt;IGPU)。通过RMCF.TYPE, RMCF.HIGH, RMCF.IGPI, and SSDT-SkylakeSpoof.aml来配置。 SSDT-SkylakeSpoof.aml: This SSDT is an optional SSDT that can be paired with SSDT-IGPU.dsl. When present, SSDT-IGPU uses the data within as an override for various KabyLake graphics devices which spoofs those devices as Skylake. Prior to 10.12.6, Skylake spoofing is the only option for KabyLake graphics. And even with 10.12.6 (or later, including 10.13.x), it still may be useful to spoof KabyLake graphics as Skyake. Keep in mind complete Skylake spoofing requires FakePCIID.kext + FakePCIID_Intel_HD_Graphics.kext. 这个SSDT是一个可选的SSDT,它可以配合SSDT-IGPU.dsl使用。SSDT-IGPU使用这些数据对KabyLake图形设备的数据进行覆盖重写，把KabyLake仿冒成Skylake。10.12.6之前,KabyLake只有仿冒成’SkyLake’驱动核显，即使在10.12.6之后(或者更新的版本，包括10.13.x)，将KabyLake仿冒成’SkyLake’仍然是很有用的，需要注意的是完整的仿冒需要FakePCIID.kext + FakePCIID_Intel_HD_Graphics.kext。 SSDT-IMEI.dsl: This SSDT injects fake device-id as required for IMEI when using mixed HD3000/7-series or HD4000/6-series. Be sure to read the comments within carefully, as customization is required if your system already has an IMEI identity in ACPI. 当使用混合的hd3000/7系或hd4000/6系时，该SSDT为IMEI注入了仿冒的设备id。一定要仔细阅读注释，因为如果您的系统已经在ACPI中有了IMEI标识，那么就需要进行定制。 SSDT-PNLF.dsl: This SSDT injects a PNLF device that works with IntelBacklight.kext or AppleBacklight.kext. Configured with RMCF.BKLT, RMCF.LMAX, RMCF.FBTP. See guide for more information: https://www.tonymacx86.com/threads/guide-laptop-backlight-control-using-applebacklightinjector-kext.218222/ 这个SSDT注入了一个PNLF设备，它可以与IntelBacklight.kext 或者AppleBacklight.kext一起工作。通过RMCF.BKLT ,RMCF.LMAX RMCF.FBTP。更多信息参见指南: SSDT-LPC.dsl:This SSDT injects properties to force AppleLPC to load for various unsupported LPC device-ids. It assumes the LPC device is named LPCB. 这个SSDT:注入属性以强制AppleLPC加载各种不支持的LPC设备id。需要LPC设备被命名为LPCB。 SSDT-SATA.dsl: This SSDT injects properties (fake device-id, compatible) to enable the SATA controller with certain unsupported SATA controllers. It assumes the SATA device is named SATA (typical is SAT0, thus requiring SAT0-&gt;SATA rename). 这个SSDT注入了一些属性(仿冒的设备id，兼容的)，以使某些不受支持的SATA控制器启用SATA控制器。它假设SATA设备被命名为SATA(常见的是SAT0，因此需要SAT0-SATA重命名)。 SSDT-Disable_DGPU.dsl: This SSDT provides an _INI method that will call _OFF for a couple of common paths for a discrete GPU in a switched/dual GPU scenario. This SSDT can work to disable the Nvidia or AMD graphics device, if the path matches (or is modified to math) and your _OFF method code path has no EC related code. Refer to the hotpatch guide for a complete example. 这个SSDT提供了一个INI方法，它将在可切换的/双GPU中为独立显卡提供一些通用的路径来调用_OFF。如果路径匹配(或被自定义来匹配)而且你的_OFF方法代码路径则没有与EC相关的代码，那么这个SSDT可以禁用Nvidia或AMD图形设备。有关一个完整的示例，请参阅热补丁指南。 SSDT-SMBUS.dsl:This SSDT injects the missing DVL0 device. Mostly used with Sandy Bridge and Ivy Bridge systems. 这个SSDT注入了丢失的DVL0设备。主要用于Sandy Bridge和Ivy Bridge平台。 SSDT-GPRW.dsl and SSDT-UPRW.dsl: These SSDTs is used in conjuction with the GPRW-&gt;XPRW or UPRW-&gt;XPRW patch. Used together this SSDT can fix “instant-wake” by disabling “wake on USB”. It overrides the _PRW package return for GPE indexes 0x0d or 0x6d. Potential companion patches are provided in hotpatch/config.plist 这些SSDT与GPRW-XPRW或UPRW-XPRW补丁一起使用。通过使用这些SSDT，可以通过禁用wake on USB来修复instant wake。它重写了GPE的索引0x0d或0x6d的PRW包返回值。在hotpatch/config.plist中提供了潜在的伙伴补丁。 SSDT-LANC_PRW.dsl: Also part of fixing “instant wake”, but this is for _PRW on the Ethernet device. Potential companion patches are provided in hotpatch/config.plist. 这也是修复instant wake的一部分，但这是在以太网设备上进行修复的。在hotpatch/config.plist中提供了潜在的伙伴补丁。 SSDT-PTSWAK.dsl: This SSDT provides overrides for both _PTS and _WAK. When combined with the appropriate companion patches from hotpatch/config.plist, these methods can provide various fixes. The actions are controlled by RMCF.DPTS, RMCF.SHUT, RMCF.XPEE, RMCF.SSTF. Refer to SSDT-Config.dsl for more information on those options. 这个SSDT提供了对_PTS和_WAK的重写。当与来自hotpatch/config.plist的适当的补丁相结合使用时，这些方法可以提供一系列的修复。这些行为是由RMCF.DPTS, RMCF.SHUT,RMCF.XPEE,RMCF.XPEE ,RMCF.SSTF.更多关于这些选项的信息参阅SSDT-Config。 SSDT-Disable_EHCI.dsl: This SSDT can disable both EHCI controllers. It is assumed both have been renamed to EH01/EH02 (typically original names are EHC1/EHC2). 这个SSDT可以禁用EHCI控制器。要求这两种情况都被重新命名为EH01/EH02(通常原来的名字是EHC1/EHC2). SSDT-Disable_EH01.dsl, SSDT-Disable_EH02.dsl: Each of these SSDTs is just SSDT-Disable_EHCI.dsl broken down to only disable EH01 or only EH02. Use as appropriate depending on which EHCI controllers are active/present in your ACPI set. 这些SSDT每一个都是SSDT-Disable_EHCI.dsl分解的，仅仅用以禁用EH01或EH02。取决于在你的ACPI集合中使用哪个EHCI控制器是合适的。 SSDT-XWAK.dsl, SSDT-XSEL.dsl, SSDT-ESEL.dsl: Each of these SSDTs provides an empty XWAK, XSEL, and ESEL methods (respectively). Use with the appropriate companion patch from hotpatch/config.plist. Typically, these methods are disabled (by having no code in them) to disable certain actions native ACPI may be doing on wake from sleep or during startup that cause problems with the xHCI/EHCI configuration. 这些SSDT分别提供了一个空的XWAK、XSEL和ESEL方法(独立地)。配合hotpatch/config.plist中适当的补丁一起使用。通常情况下，这些方法被禁用(因为在它们中没有代码)，以禁用本地ACPI可能在唤醒睡眠或在启动时导致xHCI/EHCIi配置问题的某些动作。 SSDT-PluginType1.dsl: This SSDT injects “plugin-type”=1 on CPU0. It assumes ACPI Processor objects are in Scope(_PR). It can be used to enable native CPU power management on Haswell and later CPUs. See guide for more information: https://www.tonymacx86.com/threads/guide-native-power-management-for-laptops.175801/. 这个SSDT在CPU0注入“plugin-type”=1。它要求ACPI处理器对象在Scope(_PR)范围内。它可以用于在Haswell和更新的CPU启用原生电源管理。更多信息见指南：https://www.tonymacx86.com/threads/guide-native-power-management-for-laptops.175801/. SSDT-HDEF.dsl and SSDT-HDAU.dsl: Injects layout-id, hda-gfx, and PinConfiguration properties on HDEF and HDAU in order to implement audio with patched AppleHDA.kext Configured with: RMCF.AUDL. 在HDEF和HDAU上注入layout-id、hda-gfx和PinConfiguration属性，以通过对AppleHDA的patch实现音频。通过RMCF.AUDL配置. SSDT-EH01.dsl,SSDT-EH02.dsl, and SSDT-XHC.dsl:These SSDTs inject USB power properties and control over FakePCIID_XHCIMux (dending on SSDT-Disable_EH*.dsl). 这些SSDT注入USB电源属性并通过FakePCIID_XHCIMux控制(取决于SSDT-Disable_EH*.dsl)。 SSDT-ALS0.dsl: Injects a fake ALS device (ambient light sensor). This SSDT is used to fix problems with restoring brightness upon reboot. 注入仿冒ALS设备(环境光传感器)。这个SSDT用于修复重新启动时还原亮度的问题。 Introduction-说明文档Patching ACPI is always necessary to enable (near) full functionality when installing OS X on non-Apple hardware. 在非苹果硬件上安装OS X时，修补ACPI以启用(接近)完整的功能总是必要的。 There is a complete guide here: http://www.tonymacx86.com/threads/guide-patching-laptop-dsdt-ssdts.152573/ 这里有一个完整的指南: http://www.tonymacx86.com/threads/guide-patching-laptop-dsdt-ssdts.152573/ That guide uses what is known as “static patching”. In order to inject patched ACPI files, we extract native ACPI, disassemble them, make changes, then recompile and place the files in ACPI/patched, so that Clover injects the patched ACPI instead of native ACPI. With the techniques detailed in this guide, the changes can be made directly to the ACPI binaries provided by BIOS, skipping the extract, disassembly, and recompilation steps. 该指南使用了所谓的“静态补丁”。为了注入打了补丁的ACPI文件，我们提取本地的ACPI，将它们反编译，进行修改，然后重新编译，并将文件放在ACPI/patched中，这样Clover就注入了打过补丁的ACPI，而不是原生的ACPI。通过本指南中详细介绍的技术，可以直接对BIOS提供的ACPI二进制文件进行更改，跳过提取、分解和重新编译步骤。 You should have a solid understanding of static ACPI patching before attempting to hotpatch. You should also have an understanding of the ACPI spec, binary patching, programming, and ACPI concepts. Don’t expect step-by-step and spoon feeding in this thread. 在尝试hotpatch之前，你应该对静态的ACPI补丁有一定的了解。你还应该了解ACPI规范、二进制补丁、语法和ACPI概念。不要指望在这个过程中循序渐进地学习。 Clover mechanisms-Clover机制Clover provides a few methods for accomplishing ACPI hotpatch: Clover提供了一些新的方法来实现ACPI hotpatch. config.plist/ACPI/DSDT/Fixes config.plist/ACPI/DSDT/Patches ability to inject additional SSDTs DSDT/Fixes provide fixed function ACPI patching. Each “Fix” can do a particular kind of patching that can be used instead of typical patching you might do with MaciASL and static patching. For example, “IRQ Fix” can be accomplished with “FixHPET_0010” “FixIPIC_0040” “FIX_RTC_20000” and “FIX_TMR_40000”. As an other example, “Fix _WAK Arg0 v2” can be accomplished with “FIX_WAK_200000”. You can read the Clover wiki for more information on each patch. Most of the time, there are not many DSDT “Fixes” needed for basic functionality. DSDT “Fixes” are useful for implementing patches that are difficult or impossible to implement with ACPI/DSDT/Patches or additional SSDTs. DSDT/Fixes提供了具有修复功能的ACPI补丁。每一个Fix都可以使用一种特殊的补丁，从而不需要你使用MaciASL和静态补丁。例如，IRQ Fix可以用FixHPET_0010、FixIPIC_0040、FIX_RTC_20000和FIX_TMR_40000来完成。再举一个例子，Fix _WAK Arg0 v2可以用FIX_WAK_200000来完成。对于每个补丁阅读Clover wiki以获得更多信息。大多数情况下，基本功能所需的DSDTFix并不多。对于用ACPI/DSDT/Patches或附加的SSDT很难实现甚至不可能实现的补丁,利用DSDTFixes实现非常有用。 DSDT/Patches allows for binary search and replace by Clover. Clover loads the native ACPI files, applies the patches specified in ACPI/Patches using binary search/replace, then injects the patched ACPI. You need to have an understanding of the binary AML format. It is fully documented in the ACPI spec. DSDT/Patches允许通过Clover对二进制进行查找并替换。Clover加载本地的ACPI文件，在ACPI/Patches中使用二进制查找替换以应用指定的补丁，然后注入打过补丁的ACPI。您需要了解二进制AML格式。它在ACPI规范中有完整的文档记录。 ACPI namespace is built by merging the DSDT and SSDTs at load time. By placing additional SSDTs into ACPI/patched, we can essentially add code to this ACPI set. Since many OS X patches involve adding properties to ioreg with a _DSM method, it is often adequate to simply add an SSDT which contains the additional _DSM method instead of patching the native ACPI files. A perfect example you’re already familiar with is the SSDT.aml that is generated by Pike’s ssdtPRgen.sh. ACPI命名空间在加载时通过合并DSDT和SSDT构建。通过将额外的SSDT放到ACPI/patched,我们可以添加代码到ACPI集。因为许多OS X补丁涉及_DSM方法添加属性到ioreg ,通常是适当的SSDT包含额外的一个_DSM方法而不是对本地ACPI文件打补丁。你已经熟悉的一个很好的例子是Pike的ssdtprgensh.sh脚本生成的SSDT.aml。 In some cases, more than one mechanism must be used to accomplish a single goal. For example, you might use binary patching to disable or rename components in the native ACPI set, and then replace it with additional SSDTs. 在某些情况下，必须使用不止一个机制来完成某一个目标。例如，你可能使用二进制补丁来禁用或重命名本地ACPI集合中的组件，然后用额外的SSDT替换它。 Renaming ACPI objects-重命名ACPI对象Since OS X can depend on specific ACPI object names used by Macs, a common patch is to rename an object in the native ACPI set. For example, most PC laptops use GFX0 for the integrated Intel GPU object (Intel HD Graphics). In OS X, power management for Intel graphics is not enabled unless this device is named IGPU. Using static patching, we apply “Rename IGPU to GFX0” in order to rename this object. The patch must be applied to the DSDT and all SSDTs that reference it. 由于OS X可以依赖于Mac所使用的特定的ACPI对象名称，一个常见的补丁是在本地的ACPI集合中重命名一个对象，例如，大多数PC笔记本使用GFX0作为集成的Intel GPU对象(Intel HD显卡)。在OS X中，除非这个设备被命名为IGPU，否则英特尔图形的电源管理是不能启用的。使用静态补丁，我们应用Rename IGPU to GFX0来重命名这个对象。这个补丁必须应用到DSDT和所有有引用GFX0的SSDT上。 With hotpatch, we can rename GFX0 to IGPU using a simple Clover patch in ACPI/DSDT/Patches. Such patches apply to DSDT and all native SSDTs (DSDT/Patches do not apply to SSDTs that are added via ACPI/patched). The patch for the rename would be: 使用hotpatch，我们可以在ACPI/DSDT/Patches使用一个简单的四叶草补丁将GFX0重命名为IGPU。这些补丁适用于DSDT和所有本地的SSDTs((DSDT/Patches不能被应用到通过ACPI/patched添加的SSDT)。重命名的补丁是: 123Comment: Rename GFX0 to IGPUFind: &lt;4746 5830&gt;Replace: &lt;4947 5055&gt; The hex values in Find and Replaces are the ASCII codes for GFX0 and IGPU, respectively. 查找和替换的十六进制值分别是GFX0和IGPU的ASCII码,分别是： 1234$ echo -n GFX0|xxd0000000: 4746 5830 GFX0$ echo -n IGPU|xxd0000000: 4947 5055 IGPU There are number of common renames, and most are in the config.plist that are part of my Clover/hoptpatch project: https://github.com/RehabMan/OS-X-Clover-Laptop-Config/tree/master/hotpatch 有许多通用的重命名，而且很多都在config.plist里，这个config.plist是我的Clover/hotpatch项目的一部分:https://github.com/RehabMan/OS-X-Clover-Laptop-Config/tree/master/hotpatch In fact, the hotpatch SSDTs that are part of the same project depend on the renames being implemented. 事实上，这些hotpach的SSDT也是上面那个项目的一部分，并且它们要求这些重命名必须被实现。 Common renames: 通用的重命名： 12345678910GFX0 -&gt; IGPUSAT0 -&gt; SATAEHC1 -&gt; EH01EHC2 -&gt; EH02XHCI -&gt; XHCHECI -&gt; IMEIMEI -&gt; IMEILPC -&gt; LPCBHDAS -&gt; HDEFAZAL -&gt; HDEF Note: All ACPI identifiers are 4 characters. Shorter names are padded with underscore. So, for example, XHC is represented in the AML binary as XHC_, EC would be EC__, EC0 would be EC_, MEI would be MEI_, etc. 注意：所有的ACPI标识符都是4个字符。较短的名字用下划线填充。例如，XHC在AML二进制文件中被表示为XHC_，EC是EC__，EC0是EC0_，MEI是MEI_，等等。 Removing methods-移除方法It is very difficult to remove ACPI objects, (methods, names, devices, etc) using Clover binary patches. Commonly, we must add _DSM methods to inject properties that describe various hardware properties. But added _DSM methods can conflict with existing _DSM methods that may already be in the native ACPI files. With static patching, “Remove _DSM methods” would be used. 使用Clover二进制补丁来移除ACPI对象(方法、名称、设备等等)是非常困难的。通常，我们必须添加_DSM方法来注入各种描述硬件属性的属性。但是，添加_DSM方法可能与本地ACPI文件现有的_DSM方法冲突。这时，就会用到静态补丁Remove _DSM methods。 Since it is difficult to remove the methods, but we don’t want the native methods to conflict with new _DSM methods that are added, the fix is to rename the native methods to something else. 由于很难删除这些方法，但是我们又不希望本地方法与添加的新_DSM方法相冲突，所以就将本地方法重命名为其他名字来修复这个问题。 So… again, we use a simple rename patch: 那么…同样地，我们使用一个简单的重命名补丁: 123Comment: Rename _DSM to XDSMFind: &lt;5f44534d&gt;Replace: &lt;5844534d&gt; Sometimes, you might rename an object to effectively disable it so it does not cause problems. For example, my Intel DH67GD DSDT defines an APSS object. If this object is left in the DSDT it interferes with power management (causes panic). I use a rename from APSS -&gt; APXX. Because AppleIntelCPUPowerManagement is looking for APSS, it does not cause a problem once renamed to APXX. 有时，你可能会重命名一个对象，以便有效地禁用它，这样它就不会造成问题。例如，我的Intel DH67GD的 DSDT定义了APSS对象。如果这个对象留在DSDT中，它会干扰电源管理(引起KP)。我使用APSS-&gt;APXX的重命名。因为AppleIntelCPUPowerManagement会查找APSS,只要改名为APXX就不会引起问题。 Redirect and Replace-重定向和替换In some cases, we would like to replace code to change the behavior. For this, we can rename the object and provide an alternate implementation in an SSDT. 在某些情况下，我们希望替换代码来改变某些动作。为此，我们可以重命名这个对象，并在SSDT中提供一个用来替代的对象以达到目的。 A common fix is spoofing the ACPI code in DSDT and SSDTs such that it behaves as if a certain version of Windows is the ACPI host. When static patching, we might use “OS Check Fix (Windows 8)”. When applied, it changes code from: 一个常见的修复是在DSDT和SSDT中仿冒ACPI代码，使其表现得就像是ACPI主机的某个版本的Windows一样。当利用静态补丁时，我们可能会使用OS Check Fix (Windows 8)。当应用这个补丁时，它会将代码从: 1If (_OSI(&quot;Windows 2012&quot;)) To: 改为： 1If (LOr(_OSI(&quot;Darwin&quot;),_OSI(&quot;Windows 2012&quot;)) Since the _OSI implementation in OS X only responds to “Darwin” the code is changed so that this specific _OSI check also accomodates “Darwin”. 由于OS X中_OSI方法的实现只对被修改了代码的Darwin作出响应，所以这个特定的_OSI check补丁也能响应Darwin。 With hotpatching, the opposite approach is taken. Instead of changing the code using _OSI, we change the code so it calls a different method that emulates the _OSI implementation that would be in the Windows ACPI host. 而热补丁则采用相反的方法，我们不使用_OSI修改代码，而是改变代码让它调用一种不同的方法来模拟在Windows ACPI主机上的_OSI实现。 This technique relies on two of the techniques… a patch to change all calls from _OSI to XOSI… and an implementation of XOSI that emulates what Windows would do for a certain Windows version. 这项技术依赖于两种技术，一个补丁来改变从_OSI到XOSI的所有调用。另一个是XOSI的实现，即模拟Windows对某个Windows版本的操作。 First, changing the code to call XOSI instead of _OSI: 首先，改变代码来调用XOSI而不是_OSI: 123Comment: Change _OSI to XOSIFind: &lt;5f4f 5349&gt;Replace: &lt;584f 5349&gt; The hex codes above should be no mystery (they are ASCII for _OSI and XOSI, respectively). 上面的十六进制代码没有什么神秘的(它们分别是_OSI和XOSI的ASCII码)。 Now the code mentioned above, after patching by Clover, will read: 现在，上面提到的代码，在通过Clover打了补丁之后，将会读到: 1If (XOSI(&quot;Windows 2012&quot;)) Now we need an SSDT that implements XOSI. You will find such an implementation in the repository (SSDT-XOSI.dsl). 现在我们需要一个实现XOSI的SSDT。你可以我的GitHub仓库中找到这样的实现(SSDT-XOSI.dsl). Note that without the SSDT that implements the XOSI method, the (patched) calls to XOSI would cause an ACPI abort (ACPI abort causes execution of the ACPI method to be terminated immediately with an error). Don’t use the _OSI-&gt;XOSI patch without the XOSI method. 注意，如果没有实现XOSI方法的SSDT，这个补丁对XOSI的调用将导致ACPI的加载被终止(ACPI中止导致ACPI方法的执行被错误立即终止)。如果没有XOSI方法不要使用_OSI-&gt;XOSI补丁。 Rename and Replace-重命名和替换A second pattern, similar to “Redirect and Replace” is “Rename and Replace”. In this case, instead of changing all the call sites, we change the method definition such that the method is named something different than it was originally, but leave the original method name at the call sites. This allows the method that is the target of the calls to be replaced. For example, it is very common for USB devices to cause “instant wake”. As a work around, wake on USB can be disabled. Most laptops don’t have a BIOS option for it, so instead the _PRW methods that control this feature are patched. For example, the native _SB.PCI0.EHC1._PRW method might read: 1234Method (_PRW, 0, NotSerialized) // _PRW: Power Resources for Wake&#123; Return (GPRW (0x6D, 0x03))&#125; In order to patch it so USB devices on EHCI#1 cannot cause wake, it would be changed: 1234Method (_PRW, 0, NotSerialized) // _PRW: Power Resources for Wake&#123; Return (GPRW (0x6D, 0))&#125; Usually, there are several such call sites to GPRW that need to be changed (also, keep in mind not all ACPI sets use the specific name GPRW). Instead of trying to patch all the call sites as above, we can instead patch the method definition of GPRW instead: With the original code: 1234Method (GPRW, 2, NotSerialized)&#123; ...&#125; If we change it to: 1234Method (XPRW, 2, NotSerialized)&#123; ...&#125; Since you don’t want to change any call sites, the patch must be constructed such that it affects only the method itself and not the call sites. According to ACPI spec, a method definition starts with bytecode 14, is followed by the method size, the method name, argument count/flags. You can use the “-l” option in iasl to generate a mixed listing of your ACPI file. For example, the Lenovo u430 GPRW method mixed listing: 1234564323: Method (GPRW, 2, NotSerialized)00003F95: 14 45 08 47 50 52 57 02 &quot;.E.GPRW.&quot;4324: &#123;4325: Store (Arg0, Index (PRWP, Zero))00003F9D: 70 68 .................. &quot;ph&quot;00003F9F: 88 50 52 57 50 00 00 ... &quot;.PRWP..&quot; We could do a find replace using the method header bytes: 12Find: &lt;14 45 08 47 50 52 57 02&gt;Replace: &lt;14 45 08 58 50 52 57 02&gt; But what happens if the method differs slightly between different versions of BIOS or models that are similar, but not exactly the same? In that case, the byte following the 14 will change due to the change in the method length. My thought is that the beginning of the method body is less likely to be different than the total length of the method, so it helps to add a few extra bytes from the body of the method to the find/replace specification: 12Find: &lt;47 50 52 57 02 70 68&gt;Replace: &lt;58 50 52 57 02 70 68&gt; The number of follow-on bytes that you use depends on how many you need to make the find/replace affect only the method definition. You can verify by looking at the native AML binary in a hex editor such as Hex Fiend (it is a nice hex editor and is also open source). Note: Although you could search just for the method name + arg count/flags, it is possible that the same pattern will find a call site to the method which you don’t want to change. In the case of the u430 that wasn’t the case, so I was able to find/replace with just the method name+flags. 12Find: &lt;47505257 02&gt;Replace: &lt;58505257 02&gt; In the case of the ProBook UPRW, it was necessary to use the follow-on bytes that are part of the method body: 12Find: &lt;55505257 0a7012&gt;Replace: &lt;58505257 0a7012&gt; Now any code that calls GPRW (or UPRW in the ProBook example) will not call the implementation in XPRW because the name doesn’t match. The original XPRW is now unreachable code. Which means the GPRW implementation can be changed for our purpose: 123456Method(GPRW, 2)&#123; If (0x6d == Arg0) &#123; Return(Package() &#123; 0x6d, 0, &#125;) &#125; External(\XPRW, MethodObj) Return(XPRW(Arg0, Arg1))&#125; Explaining the code: For any call to GPRW with the first argument set to 0x6d (the GPE we are trying to disable for wake), instead of returning what the original GPRW would, we return a package with 0x6d and 0 (which disables wake). And for other GPE values, the code simply calls the original GPRW method now named XPRW. Another simple case is patching EC query methods to fix the brightness keys. A simple rename of the _Qxx methods involved to XQxx, and a new definition of the method with the original name is all that is needed. For example, in the HP Envy Haswell repo: 123456789101112131415161718192021// _Q13 called on brightness/mirror display keyMethod (_Q13, 0, Serialized) // _Qxx: EC Query&#123; External(\HKNO, FieldUnitObj) Store(HKNO, Local0) If (LEqual(Local0,7)) &#123; // Brightness Down Notify(\_SB.PCI0.LPCB.PS2K, 0x0405) &#125; If (LEqual(Local0,8)) &#123; // Brightness Up Notify(\_SB.PCI0.LPCB.PS2K, 0x0406) &#125; If (LEqual(Local0,4)) &#123; // Mirror toggle Notify(\_SB.PCI0.LPCB.PS2K, 0x046e) &#125;&#125; And the associated patch: 123Comment: change Method(_Q13,0,S) to XQ13Find: &lt;5f513133 08&gt;Replace: &lt;58513133 08&gt; This same “Rename and Replace” mechanism can be used in cases that are much more complex than this. For example, it is typically used to patch battery methods, which need to be patched to avoid access to multibyte EC fields. Tips for complex Rename and ReplaceAs you probably already know, patching for battery status (multibyte EC fields) can be very complex and can involve a lot of code changes to many methods. This section will detail some of the techniques and procedures used for battery patching. It is advisable to patch for battery without using hotpatch first. After you get it working, then attempt hotpatch. Also, the difference between the code not patched for battery and the code patched for battery is very helpful. You can use a tool like ‘diffmerge’ to compare each. This is especially true if there is already a static battery patch for your laptop in my laptop repository. General procedure: start with native ACPI patch for battery status using static patching (verify it works) use diffmerge to compare the unpatched code with patched code for each method that is different, implement the “Rename and Replace” pattern for the EC fields, create another EC OperationRegion (use a name that is different from the original) and Field definition as a sort of “overlay” which contains only the EC fields you need to patch to create the EC overlay, you can use the patched Field/OperationRegion in the patched DSDT, then eliminate unpatched fields use External to allow the replacement methods in the SSDT to access the fields defined elsewhere in the ACPI set (usually DSDT) let the compiler point out where you need to use External watch out for symbols with duplicate names in different scopes An example is provided in post #2 of this thread. Code value patchingConsider the case of “Fix Mutex with non-zero SyncLevel”. This patch finds all Mutex objects and replaces the SyncLevel with 0. We use this patch since OS X does not support Mutex debugging correctly and aborts on any Acquire with a Mutex that has a non-zero SyncLevel. As an example, the u430 has Mutexes delcared as such: Mutex (MSMI, 0x07) To make it compatible with OS X it must be changed: Mutex (MSMI, 0) The ACPI spec defines how a Mutex object is encoded in the AML, but it can be helpful to look at a mixed disassembly of a small ACPI file: 1234DefinitionBlock (&quot;&quot;, &quot;DSDT&quot;, 2, &quot;test&quot;, &quot;test&quot;, 0)&#123; Mutex(ABCD, 7)&#125; The iasl compiler can create a mixed listing file with the “-l” option. If we compile the above file with: iasl -l test.dsl, test.lst contains: 1: DefinitionBlock (&quot;&quot;, &quot;DSDT&quot;, 2, &quot;test&quot;, &quot;test&quot;, 0) 00000000: 44 53 44 54 2B 00 00 00 &quot;DSDT+...&quot; 00000008: 02 36 74 65 73 74 00 00 &quot;.6test..&quot; 00000010: 74 65 73 74 00 00 00 00 &quot;test....&quot; 00000018: 00 00 00 00 49 4E 54 4C &quot;....INTL&quot; 00000020: 10 04 16 20 ............ &quot;... &quot; 2: { 3: Mutex(ABCD, 7) 00000024: 5B 01 41 42 43 44 07 ... &quot;[.ABCD.&quot; 4: } As you can see, the Mutex(ABCD, 7), is encoded as &lt;5B 01 41 42 43 44 07&gt; It is now very easy to construct a patch for it: 123Comment: Change Mutex(ABCD,7) to Mutex(ABCD,0)Find: &lt;5B 01 41 42 43 44 07&gt;Replace: &lt;5B 01 41 42 43 44 00&gt; Clover ACPI configurationWith static patching, DropOem=true is used and patched DSDT and SSDTs are added to ACPI/patched. With hotpatch, instead use DropOem=false, and only add-on SSDTs are placed in ACPI/patched. It is important to note that config.plist/ACPI/patches are applied only to native SSDTs, and not the SSDTs in ACPI/patched. This means that if you are renaming objects using config.plist, the add-on SSDTs must refer to the new names, not the old names. Unlike SSDTs in ACPI/patched, binary patches in ACPI/Patches do apply to DSDT.aml that might be in ACPI/patched. Keep this in mind if you’re using a combination of static and hotpatching. Also, with static patching, SortedOrder is used to specify the order of SSDTs in ACPI/patched. With hotpatch it is not strictly necessary as it is possible to construct the code in each SSDT such that the code is not order dependent. Especially if you place all add-on code in a single SSDT such as many of my laptop repo examples. Unless your add-on SSDTs are order dependent, you do not have to name each one in SortedOrder. It is also not necessary to choose “numbered names” for each SSDT. Instead you can use meaningful names, such as “SSDT-USB.aml”, SSDT-XOSI.aml”, etc. Using numbers instead of meaningul names will just confuse you. Don’t do it. TroubleshootingYou can use patchmatic to look at your complete ACPI set as injected by Clover after patching. By runnning ‘patchmatic -extract’, patchmatic will write all injected DSDT.aml and SSDT.aml in the order they were injected by Clover. You can disassemble them with ‘iasl -da -dl .aml’. If iasl shows errors with the disassembly (for example duplicate symbols), it is likley OS X is also rejecting the conflicting SSDTs. If you’re a novice with this technique, it is a good idea to implement one patch at a time, and slowly build it up to a full set of working patches + SSDTs. Trying to do all at once can make it difficult to locate your mistake. Battery Status HotpatchThis second post is dedicated to patching battery status with Clover hotpatch. To demonstrate the process, we will work through an example DSDT. The example files used are from the guide for disabling discrete graphics, an “Asus UX303LN”. https://www.tonymacx86.com/threads/guide-disabling-discrete-graphics-in-dual-gpu-laptops.163772/ You should download the ACPI/origin files that are attached to that guide, so you can follow along. As mentioned in post #1, the general procedures are as follows: start with native ACPI patch for battery status using static patching (verify it works) use diffmerge to compare the unpatched code with patched code for each method that is different, implement the “Rename and Replace” pattern for the EC fields, create another EC OperationRegion (use a name that is different from the original) and Field definition as a sort of “overlay” which contains only the EC fields you need to patch to create the EC overlay, you can use the patched Field/OperationRegion in the patched DSDT, then eliminate unpatched fields use External to allow the replacement methods in the SSDT to access the fields defined elsewhere in the ACPI set (usually DSDT) let the compiler point out where you need to use External watch out for symbols with duplicate names in different scopes Using diffmerge to find patched vs. native differencesStart by disassembling the origin files: iasl -da -dl *.aml(you should be familiar with this part as it is part of normal ACPI patching) Next apply the battery patch only using MaciASL to DSDT.dsl. In this case, we apply the “ASUS N55SL/VivoBook”. There is no need to fix any errors, as we are interested only in the differences created by applying the battery patch. Save the patched file as DSDT_patched.dsl. Now you can run diffmerge to see the differences between DSDT.dsl and DSDT_patched.dsl. I usually just do this from Terminal: $ diffmerge DSDT.dsl DSDT_patched.dsl The initial diffmerge window will look something like this: From there, we can examine the parts that have changes by clicking on the markers in the left column. In the examples, the groups of changes you find: group 1: is the changes to the EC fields (multibyte to single byte) group 2: addition of RDBA, WRBA, RDBB, WRBB methods group 3: patched FBST, _BIX, B1FA methods group 4: patched SMBR, SMBW, ECSB methods group 5: patched TACH method final group: addition of B1B2 method Constructing the initial SSDTStart with an empty SSDT in MaciASL: 123DefinitionBlock(&quot;&quot;, &quot;SSDT&quot;, 2, &quot;hack&quot;, &quot;batt&quot;, 0)&#123;&#125; Next, add all methods that were added by the patch. In the example, this includes RDBA, WRBA, RDBB, WRBB and B1B2 methods. You can copy them directly from the DSDT_patched.dsl. You want to be certain each method is placed in the same scope. For example, here is the “group 2” methods added: DefinitionBlock(&quot;&quot;, &quot;SSDT&quot;, 2, &quot;hack&quot;, &quot;batt&quot;, 0) { Scope (_SB.PCI0.LPCB.EC0) { Scope (EC0) { Method (RDBA, 0, Serialized) { Name (TEMP, Buffer(0x20) { }) Store (BA00, Index(TEMP, 0x00)) Store (BA01, Index(TEMP, 0x01)) Store (BA02, Index(TEMP, 0x02)) Store (BA03, Index(TEMP, 0x03)) Store (BA04, Index(TEMP, 0x04)) Store (BA05, Index(TEMP, 0x05)) Store (BA06, Index(TEMP, 0x06)) Store (BA07, Index(TEMP, 0x07)) Store (BA08, Index(TEMP, 0x08)) Store (BA09, Index(TEMP, 0x09)) Store (BA0A, Index(TEMP, 0x0A)) Store (BA0B, Index(TEMP, 0x0B)) Store (BA0C, Index(TEMP, 0x0C)) Store (BA0D, Index(TEMP, 0x0D)) Store (BA0E, Index(TEMP, 0x0E)) Store (BA0F, Index(TEMP, 0x0F)) Store (BA10, Index(TEMP, 0x10)) Store (BA11, Index(TEMP, 0x11)) Store (BA12, Index(TEMP, 0x12)) Store (BA13, Index(TEMP, 0x13)) Store (BA14, Index(TEMP, 0x14)) Store (BA15, Index(TEMP, 0x15)) Store (BA16, Index(TEMP, 0x16)) Store (BA17, Index(TEMP, 0x17)) Store (BA18, Index(TEMP, 0x18)) Store (BA19, Index(TEMP, 0x19)) Store (BA1A, Index(TEMP, 0x1A)) Store (BA1B, Index(TEMP, 0x1B)) Store (BA1C, Index(TEMP, 0x1C)) Store (BA1D, Index(TEMP, 0x1D)) Store (BA1E, Index(TEMP, 0x1E)) Store (BA1F, Index(TEMP, 0x1F)) Return (TEMP) } Method (WRBA, 1, Serialized) { Name (TEMP, Buffer(0x20) { }) Store (Arg0, TEMP) Store (DerefOf(Index(TEMP, 0x00)), BA00) Store (DerefOf(Index(TEMP, 0x01)), BA01) Store (DerefOf(Index(TEMP, 0x02)), BA02) Store (DerefOf(Index(TEMP, 0x03)), BA03) Store (DerefOf(Index(TEMP, 0x04)), BA04) Store (DerefOf(Index(TEMP, 0x05)), BA05) Store (DerefOf(Index(TEMP, 0x06)), BA06) Store (DerefOf(Index(TEMP, 0x07)), BA07) Store (DerefOf(Index(TEMP, 0x08)), BA08) Store (DerefOf(Index(TEMP, 0x09)), BA09) Store (DerefOf(Index(TEMP, 0x0A)), BA0A) Store (DerefOf(Index(TEMP, 0x0B)), BA0B) Store (DerefOf(Index(TEMP, 0x0C)), BA0C) Store (DerefOf(Index(TEMP, 0x0D)), BA0D) Store (DerefOf(Index(TEMP, 0x0E)), BA0E) Store (DerefOf(Index(TEMP, 0x0F)), BA0F) Store (DerefOf(Index(TEMP, 0x10)), BA10) Store (DerefOf(Index(TEMP, 0x11)), BA11) Store (DerefOf(Index(TEMP, 0x12)), BA12) Store (DerefOf(Index(TEMP, 0x13)), BA13) Store (DerefOf(Index(TEMP, 0x14)), BA14) Store (DerefOf(Index(TEMP, 0x15)), BA15) Store (DerefOf(Index(TEMP, 0x16)), BA16) Store (DerefOf(Index(TEMP, 0x17)), BA17) Store (DerefOf(Index(TEMP, 0x18)), BA18) Store (DerefOf(Index(TEMP, 0x19)), BA19) Store (DerefOf(Index(TEMP, 0x1A)), BA1A) Store (DerefOf(Index(TEMP, 0x1B)), BA1B) Store (DerefOf(Index(TEMP, 0x1C)), BA1C) Store (DerefOf(Index(TEMP, 0x1D)), BA1D) Store (DerefOf(Index(TEMP, 0x1E)), BA1E) Store (DerefOf(Index(TEMP, 0x1F)), BA1F) } Method (RDBB, 0, Serialized) { Name (TEMP, Buffer(0x20) { }) Store (BB00, Index(TEMP, 0x00)) Store (BB01, Index(TEMP, 0x01)) Store (BB02, Index(TEMP, 0x02)) Store (BB03, Index(TEMP, 0x03)) Store (BB04, Index(TEMP, 0x04)) Store (BB05, Index(TEMP, 0x05)) Store (BB06, Index(TEMP, 0x06)) Store (BB07, Index(TEMP, 0x07)) Store (BB08, Index(TEMP, 0x08)) Store (BB09, Index(TEMP, 0x09)) Store (BB0A, Index(TEMP, 0x0A)) Store (BB0B, Index(TEMP, 0x0B)) Store (BB0C, Index(TEMP, 0x0C)) Store (BB0D, Index(TEMP, 0x0D)) Store (BB0E, Index(TEMP, 0x0E)) Store (BB0F, Index(TEMP, 0x0F)) Store (BB10, Index(TEMP, 0x10)) Store (BB11, Index(TEMP, 0x11)) Store (BB12, Index(TEMP, 0x12)) Store (BB13, Index(TEMP, 0x13)) Store (BB14, Index(TEMP, 0x14)) Store (BB15, Index(TEMP, 0x15)) Store (BB16, Index(TEMP, 0x16)) Store (BB17, Index(TEMP, 0x17)) Store (BB18, Index(TEMP, 0x18)) Store (BB19, Index(TEMP, 0x19)) Store (BB1A, Index(TEMP, 0x1A)) Store (BB1B, Index(TEMP, 0x1B)) Store (BB1C, Index(TEMP, 0x1C)) Store (BB1D, Index(TEMP, 0x1D)) Store (BB1E, Index(TEMP, 0x1E)) Store (BB1F, Index(TEMP, 0x1F)) Return (TEMP) } Method (WRBB, 1, Serialized) { Name (TEMP, Buffer(0x20) { }) Store (Arg0, TEMP) Store (DerefOf(Index(TEMP, 0x00)), BB00) Store (DerefOf(Index(TEMP, 0x01)), BB01) Store (DerefOf(Index(TEMP, 0x02)), BB02) Store (DerefOf(Index(TEMP, 0x03)), BB03) Store (DerefOf(Index(TEMP, 0x04)), BB04) Store (DerefOf(Index(TEMP, 0x05)), BB05) Store (DerefOf(Index(TEMP, 0x06)), BB06) Store (DerefOf(Index(TEMP, 0x07)), BB07) Store (DerefOf(Index(TEMP, 0x08)), BB08) Store (DerefOf(Index(TEMP, 0x09)), BB09) Store (DerefOf(Index(TEMP, 0x0A)), BB0A) Store (DerefOf(Index(TEMP, 0x0B)), BB0B) Store (DerefOf(Index(TEMP, 0x0C)), BB0C) Store (DerefOf(Index(TEMP, 0x0D)), BB0D) Store (DerefOf(Index(TEMP, 0x0E)), BB0E) Store (DerefOf(Index(TEMP, 0x0F)), BB0F) Store (DerefOf(Index(TEMP, 0x10)), BB10) Store (DerefOf(Index(TEMP, 0x11)), BB11) Store (DerefOf(Index(TEMP, 0x12)), BB12) Store (DerefOf(Index(TEMP, 0x13)), BB13) Store (DerefOf(Index(TEMP, 0x14)), BB14) Store (DerefOf(Index(TEMP, 0x15)), BB15) Store (DerefOf(Index(TEMP, 0x16)), BB16) Store (DerefOf(Index(TEMP, 0x17)), BB17) Store (DerefOf(Index(TEMP, 0x18)), BB18) Store (DerefOf(Index(TEMP, 0x19)), BB19) Store (DerefOf(Index(TEMP, 0x1A)), BB1A) Store (DerefOf(Index(TEMP, 0x1B)), BB1B) Store (DerefOf(Index(TEMP, 0x1C)), BB1C) Store (DerefOf(Index(TEMP, 0x1D)), BB1D) Store (DerefOf(Index(TEMP, 0x1E)), BB1E) Store (DerefOf(Index(TEMP, 0x1F)), BB1F) } } } } And with B1B2 added: DefinitionBlock(&quot;&quot;, &quot;SSDT&quot;, 2, &quot;hack&quot;, &quot;batt&quot;, 0) { Method (B1B2, 2, NotSerialized) { Return (Or (Arg0, ShiftLeft (Arg1, 8))) } // added methods (group 2) Scope (_SB.PCI0.LPCB.EC0) { Scope (EC0) { Method (RDBA, 0, Serialized) { Name (TEMP, Buffer(0x20) { }) Store (BA00, Index(TEMP, 0x00)) Store (BA01, Index(TEMP, 0x01)) Store (BA02, Index(TEMP, 0x02)) Store (BA03, Index(TEMP, 0x03)) Store (BA04, Index(TEMP, 0x04)) Store (BA05, Index(TEMP, 0x05)) Store (BA06, Index(TEMP, 0x06)) Store (BA07, Index(TEMP, 0x07)) Store (BA08, Index(TEMP, 0x08)) Store (BA09, Index(TEMP, 0x09)) Store (BA0A, Index(TEMP, 0x0A)) Store (BA0B, Index(TEMP, 0x0B)) Store (BA0C, Index(TEMP, 0x0C)) Store (BA0D, Index(TEMP, 0x0D)) Store (BA0E, Index(TEMP, 0x0E)) Store (BA0F, Index(TEMP, 0x0F)) Store (BA10, Index(TEMP, 0x10)) Store (BA11, Index(TEMP, 0x11)) Store (BA12, Index(TEMP, 0x12)) Store (BA13, Index(TEMP, 0x13)) Store (BA14, Index(TEMP, 0x14)) Store (BA15, Index(TEMP, 0x15)) Store (BA16, Index(TEMP, 0x16)) Store (BA17, Index(TEMP, 0x17)) Store (BA18, Index(TEMP, 0x18)) Store (BA19, Index(TEMP, 0x19)) Store (BA1A, Index(TEMP, 0x1A)) Store (BA1B, Index(TEMP, 0x1B)) Store (BA1C, Index(TEMP, 0x1C)) Store (BA1D, Index(TEMP, 0x1D)) Store (BA1E, Index(TEMP, 0x1E)) Store (BA1F, Index(TEMP, 0x1F)) Return (TEMP) } Method (WRBA, 1, Serialized) { Name (TEMP, Buffer(0x20) { }) Store (Arg0, TEMP) Store (DerefOf(Index(TEMP, 0x00)), BA00) Store (DerefOf(Index(TEMP, 0x01)), BA01) Store (DerefOf(Index(TEMP, 0x02)), BA02) Store (DerefOf(Index(TEMP, 0x03)), BA03) Store (DerefOf(Index(TEMP, 0x04)), BA04) Store (DerefOf(Index(TEMP, 0x05)), BA05) Store (DerefOf(Index(TEMP, 0x06)), BA06) Store (DerefOf(Index(TEMP, 0x07)), BA07) Store (DerefOf(Index(TEMP, 0x08)), BA08) Store (DerefOf(Index(TEMP, 0x09)), BA09) Store (DerefOf(Index(TEMP, 0x0A)), BA0A) Store (DerefOf(Index(TEMP, 0x0B)), BA0B) Store (DerefOf(Index(TEMP, 0x0C)), BA0C) Store (DerefOf(Index(TEMP, 0x0D)), BA0D) Store (DerefOf(Index(TEMP, 0x0E)), BA0E) Store (DerefOf(Index(TEMP, 0x0F)), BA0F) Store (DerefOf(Index(TEMP, 0x10)), BA10) Store (DerefOf(Index(TEMP, 0x11)), BA11) Store (DerefOf(Index(TEMP, 0x12)), BA12) Store (DerefOf(Index(TEMP, 0x13)), BA13) Store (DerefOf(Index(TEMP, 0x14)), BA14) Store (DerefOf(Index(TEMP, 0x15)), BA15) Store (DerefOf(Index(TEMP, 0x16)), BA16) Store (DerefOf(Index(TEMP, 0x17)), BA17) Store (DerefOf(Index(TEMP, 0x18)), BA18) Store (DerefOf(Index(TEMP, 0x19)), BA19) Store (DerefOf(Index(TEMP, 0x1A)), BA1A) Store (DerefOf(Index(TEMP, 0x1B)), BA1B) Store (DerefOf(Index(TEMP, 0x1C)), BA1C) Store (DerefOf(Index(TEMP, 0x1D)), BA1D) Store (DerefOf(Index(TEMP, 0x1E)), BA1E) Store (DerefOf(Index(TEMP, 0x1F)), BA1F) } Method (RDBB, 0, Serialized) { Name (TEMP, Buffer(0x20) { }) Store (BB00, Index(TEMP, 0x00)) Store (BB01, Index(TEMP, 0x01)) Store (BB02, Index(TEMP, 0x02)) Store (BB03, Index(TEMP, 0x03)) Store (BB04, Index(TEMP, 0x04)) Store (BB05, Index(TEMP, 0x05)) Store (BB06, Index(TEMP, 0x06)) Store (BB07, Index(TEMP, 0x07)) Store (BB08, Index(TEMP, 0x08)) Store (BB09, Index(TEMP, 0x09)) Store (BB0A, Index(TEMP, 0x0A)) Store (BB0B, Index(TEMP, 0x0B)) Store (BB0C, Index(TEMP, 0x0C)) Store (BB0D, Index(TEMP, 0x0D)) Store (BB0E, Index(TEMP, 0x0E)) Store (BB0F, Index(TEMP, 0x0F)) Store (BB10, Index(TEMP, 0x10)) Store (BB11, Index(TEMP, 0x11)) Store (BB12, Index(TEMP, 0x12)) Store (BB13, Index(TEMP, 0x13)) Store (BB14, Index(TEMP, 0x14)) Store (BB15, Index(TEMP, 0x15)) Store (BB16, Index(TEMP, 0x16)) Store (BB17, Index(TEMP, 0x17)) Store (BB18, Index(TEMP, 0x18)) Store (BB19, Index(TEMP, 0x19)) Store (BB1A, Index(TEMP, 0x1A)) Store (BB1B, Index(TEMP, 0x1B)) Store (BB1C, Index(TEMP, 0x1C)) Store (BB1D, Index(TEMP, 0x1D)) Store (BB1E, Index(TEMP, 0x1E)) Store (BB1F, Index(TEMP, 0x1F)) Return (TEMP) } Method (WRBB, 1, Serialized) { Name (TEMP, Buffer(0x20) { }) Store (Arg0, TEMP) Store (DerefOf(Index(TEMP, 0x00)), BB00) Store (DerefOf(Index(TEMP, 0x01)), BB01) Store (DerefOf(Index(TEMP, 0x02)), BB02) Store (DerefOf(Index(TEMP, 0x03)), BB03) Store (DerefOf(Index(TEMP, 0x04)), BB04) Store (DerefOf(Index(TEMP, 0x05)), BB05) Store (DerefOf(Index(TEMP, 0x06)), BB06) Store (DerefOf(Index(TEMP, 0x07)), BB07) Store (DerefOf(Index(TEMP, 0x08)), BB08) Store (DerefOf(Index(TEMP, 0x09)), BB09) Store (DerefOf(Index(TEMP, 0x0A)), BB0A) Store (DerefOf(Index(TEMP, 0x0B)), BB0B) Store (DerefOf(Index(TEMP, 0x0C)), BB0C) Store (DerefOf(Index(TEMP, 0x0D)), BB0D) Store (DerefOf(Index(TEMP, 0x0E)), BB0E) Store (DerefOf(Index(TEMP, 0x0F)), BB0F) Store (DerefOf(Index(TEMP, 0x10)), BB10) Store (DerefOf(Index(TEMP, 0x11)), BB11) Store (DerefOf(Index(TEMP, 0x12)), BB12) Store (DerefOf(Index(TEMP, 0x13)), BB13) Store (DerefOf(Index(TEMP, 0x14)), BB14) Store (DerefOf(Index(TEMP, 0x15)), BB15) Store (DerefOf(Index(TEMP, 0x16)), BB16) Store (DerefOf(Index(TEMP, 0x17)), BB17) Store (DerefOf(Index(TEMP, 0x18)), BB18) Store (DerefOf(Index(TEMP, 0x19)), BB19) Store (DerefOf(Index(TEMP, 0x1A)), BB1A) Store (DerefOf(Index(TEMP, 0x1B)), BB1B) Store (DerefOf(Index(TEMP, 0x1C)), BB1C) Store (DerefOf(Index(TEMP, 0x1D)), BB1D) Store (DerefOf(Index(TEMP, 0x1E)), BB1E) Store (DerefOf(Index(TEMP, 0x1F)), BB1F) } } } } Don’t worry that the code does not compile at the moment. It is not expected at this point, due to the EC fields (and other identifiers) that are not defined in this file. They will need to be definined or referenced via External (eventually). Now let’s add the patched methods. Just like the methods that were added methods, the patched methods are just copied from the DSDT_patched.dsl: DefinitionBlock(&quot;&quot;, &quot;SSDT&quot;, 2, &quot;hack&quot;, &quot;batt&quot;, 0) { // patched methods Scope (_SB.PCI0) { Scope (BAT0) { Method (FBST, 4, NotSerialized) { And (Arg1, 0xFFFF, Local1) Store (Zero, Local0) If (^^LPCB.EC0.ACAP ()) { Store (One, Local0) } If (Local0) { If (CHGS (Zero)) { Store (0x02, Local0) } Else { Store (Zero, Local0) } } Else { Store (One, Local0) } If (BLLO) { ShiftLeft (One, 0x02, Local2) Or (Local0, Local2, Local0) } If (And (^^LPCB.EC0.EB0S, 0x08)) { ShiftLeft (One, 0x02, Local2) Or (Local0, Local2, Local0) } If (LGreaterEqual (Local1, 0x8000)) { Subtract (0xFFFF, Local1, Local1) } Store (Arg2, Local2) If (LEqual (PUNT, Zero)) { Multiply (Local1, ^^LPCB.EC0.B0DV, Local1) Multiply (Local2, 0x0A, Local2) } And (Local0, 0x02, Local3) If (LNot (Local3)) { Subtract (LFCC, Local2, Local3) Divide (LFCC, 0xC8, Local4, Local5) If (LLess (Local3, Local5)) { Store (LFCC, Local2) } } Else { Divide (LFCC, 0xC8, Local4, Local5) Subtract (LFCC, Local5, Local4) If (LGreater (Local2, Local4)) { Store (Local4, Local2) } } If (LNot (^^LPCB.EC0.ACAP ())) { Divide (Local2, MBLF, Local3, Local4) If (LLess (Local1, Local4)) { Store (Local4, Local1) } } Store (Local0, Index (PBST, Zero)) Store (Local1, Index (PBST, One)) Store (Local2, Index (PBST, 0x02)) Store (Arg3, Index (PBST, 0x03)) } Method (_BIX, 0, NotSerialized) // _BIX: Battery Information Extended { If (LNot (^^LPCB.EC0.BATP (Zero))) { Return (NBIX) } If (LEqual (^^LPCB.EC0.GBTT (Zero), 0xFF)) { Return (NBIX) } _BIF () Store (DerefOf (Index (PBIF, Zero)), Index (BIXT, One)) Store (DerefOf (Index (PBIF, One)), Index (BIXT, 0x02)) Store (DerefOf (Index (PBIF, 0x02)), Index (BIXT, 0x03)) Store (DerefOf (Index (PBIF, 0x03)), Index (BIXT, 0x04)) Store (DerefOf (Index (PBIF, 0x04)), Index (BIXT, 0x05)) Store (DerefOf (Index (PBIF, 0x05)), Index (BIXT, 0x06)) Store (DerefOf (Index (PBIF, 0x06)), Index (BIXT, 0x07)) Store (DerefOf (Index (PBIF, 0x07)), Index (BIXT, 0x0E)) Store (DerefOf (Index (PBIF, 0x08)), Index (BIXT, 0x0F)) Store (DerefOf (Index (PBIF, 0x09)), Index (BIXT, 0x10)) Store (DerefOf (Index (PBIF, 0x0A)), Index (BIXT, 0x11)) Store (DerefOf (Index (PBIF, 0x0B)), Index (BIXT, 0x12)) Store (DerefOf (Index (PBIF, 0x0C)), Index (BIXT, 0x13)) If (LEqual (DerefOf (Index (BIXT, One)), One)) { Store (Zero, Index (BIXT, One)) Store (DerefOf (Index (BIXT, 0x05)), Local0) Multiply (DerefOf (Index (BIXT, 0x02)), Local0, Index (BIXT, 0x02)) Multiply (DerefOf (Index (BIXT, 0x03)), Local0, Index (BIXT, 0x03)) Multiply (DerefOf (Index (BIXT, 0x06)), Local0, Index (BIXT, 0x06)) Multiply (DerefOf (Index (BIXT, 0x07)), Local0, Index (BIXT, 0x07)) Multiply (DerefOf (Index (BIXT, 0x0E)), Local0, Index (BIXT, 0x0E)) Multiply (DerefOf (Index (BIXT, 0x0F)), Local0, Index (BIXT, 0x0F)) Divide (DerefOf (Index (BIXT, 0x02)), 0x03E8, Local0, Index (BIXT, 0x02)) Divide (DerefOf (Index (BIXT, 0x03)), 0x03E8, Local0, Index (BIXT, 0x03)) Divide (DerefOf (Index (BIXT, 0x06)), 0x03E8, Local0, Index (BIXT, 0x06)) Divide (DerefOf (Index (BIXT, 0x07)), 0x03E8, Local0, Index (BIXT, 0x07)) Divide (DerefOf (Index (BIXT, 0x0E)), 0x03E8, Local0, Index (BIXT, 0x0E)) Divide (DerefOf (Index (BIXT, 0x0F)), 0x03E8, Local0, Index (BIXT, 0x0F)) } Store (B1B2(^^LPCB.EC0.XC30,^^LPCB.EC0.XC31), Index (BIXT, 0x08)) Store (0x0001869F, Index (BIXT, 0x09)) Return (BIXT) } } } Scope (_SB.PCI0.LPCB.EC0) { Method (BIFA, 0, NotSerialized) { If (ECAV ()) { If (BSLF) { Store (B1B2(B1S0,B1S1), Local0) } Else { Store (B1B2(B0S0,B0S1), Local0) } } Else { Store (Ones, Local0) } Return (Local0) } } Method (B1B2, 2, NotSerialized) { Return (Or (Arg0, ShiftLeft (Arg1, 8))) } // added methods (group 2) Scope (_SB.PCI0.LPCB.EC0) { Scope (EC0) { Method (RDBA, 0, Serialized) { Name (TEMP, Buffer(0x20) { }) Store (BA00, Index(TEMP, 0x00)) Store (BA01, Index(TEMP, 0x01)) Store (BA02, Index(TEMP, 0x02)) Store (BA03, Index(TEMP, 0x03)) Store (BA04, Index(TEMP, 0x04)) Store (BA05, Index(TEMP, 0x05)) Store (BA06, Index(TEMP, 0x06)) Store (BA07, Index(TEMP, 0x07)) Store (BA08, Index(TEMP, 0x08)) Store (BA09, Index(TEMP, 0x09)) Store (BA0A, Index(TEMP, 0x0A)) Store (BA0B, Index(TEMP, 0x0B)) Store (BA0C, Index(TEMP, 0x0C)) Store (BA0D, Index(TEMP, 0x0D)) Store (BA0E, Index(TEMP, 0x0E)) Store (BA0F, Index(TEMP, 0x0F)) Store (BA10, Index(TEMP, 0x10)) Store (BA11, Index(TEMP, 0x11)) Store (BA12, Index(TEMP, 0x12)) Store (BA13, Index(TEMP, 0x13)) Store (BA14, Index(TEMP, 0x14)) Store (BA15, Index(TEMP, 0x15)) Store (BA16, Index(TEMP, 0x16)) Store (BA17, Index(TEMP, 0x17)) Store (BA18, Index(TEMP, 0x18)) Store (BA19, Index(TEMP, 0x19)) Store (BA1A, Index(TEMP, 0x1A)) Store (BA1B, Index(TEMP, 0x1B)) Store (BA1C, Index(TEMP, 0x1C)) Store (BA1D, Index(TEMP, 0x1D)) Store (BA1E, Index(TEMP, 0x1E)) Store (BA1F, Index(TEMP, 0x1F)) Return (TEMP) } Method (WRBA, 1, Serialized) { Name (TEMP, Buffer(0x20) { }) Store (Arg0, TEMP) Store (DerefOf(Index(TEMP, 0x00)), BA00) Store (DerefOf(Index(TEMP, 0x01)), BA01) Store (DerefOf(Index(TEMP, 0x02)), BA02) Store (DerefOf(Index(TEMP, 0x03)), BA03) Store (DerefOf(Index(TEMP, 0x04)), BA04) Store (DerefOf(Index(TEMP, 0x05)), BA05) Store (DerefOf(Index(TEMP, 0x06)), BA06) Store (DerefOf(Index(TEMP, 0x07)), BA07) Store (DerefOf(Index(TEMP, 0x08)), BA08) Store (DerefOf(Index(TEMP, 0x09)), BA09) Store (DerefOf(Index(TEMP, 0x0A)), BA0A) Store (DerefOf(Index(TEMP, 0x0B)), BA0B) Store (DerefOf(Index(TEMP, 0x0C)), BA0C) Store (DerefOf(Index(TEMP, 0x0D)), BA0D) Store (DerefOf(Index(TEMP, 0x0E)), BA0E) Store (DerefOf(Index(TEMP, 0x0F)), BA0F) Store (DerefOf(Index(TEMP, 0x10)), BA10) Store (DerefOf(Index(TEMP, 0x11)), BA11) Store (DerefOf(Index(TEMP, 0x12)), BA12) Store (DerefOf(Index(TEMP, 0x13)), BA13) Store (DerefOf(Index(TEMP, 0x14)), BA14) Store (DerefOf(Index(TEMP, 0x15)), BA15) Store (DerefOf(Index(TEMP, 0x16)), BA16) Store (DerefOf(Index(TEMP, 0x17)), BA17) Store (DerefOf(Index(TEMP, 0x18)), BA18) Store (DerefOf(Index(TEMP, 0x19)), BA19) Store (DerefOf(Index(TEMP, 0x1A)), BA1A) Store (DerefOf(Index(TEMP, 0x1B)), BA1B) Store (DerefOf(Index(TEMP, 0x1C)), BA1C) Store (DerefOf(Index(TEMP, 0x1D)), BA1D) Store (DerefOf(Index(TEMP, 0x1E)), BA1E) Store (DerefOf(Index(TEMP, 0x1F)), BA1F) } Method (RDBB, 0, Serialized) { Name (TEMP, Buffer(0x20) { }) Store (BB00, Index(TEMP, 0x00)) Store (BB01, Index(TEMP, 0x01)) Store (BB02, Index(TEMP, 0x02)) Store (BB03, Index(TEMP, 0x03)) Store (BB04, Index(TEMP, 0x04)) Store (BB05, Index(TEMP, 0x05)) Store (BB06, Index(TEMP, 0x06)) Store (BB07, Index(TEMP, 0x07)) Store (BB08, Index(TEMP, 0x08)) Store (BB09, Index(TEMP, 0x09)) Store (BB0A, Index(TEMP, 0x0A)) Store (BB0B, Index(TEMP, 0x0B)) Store (BB0C, Index(TEMP, 0x0C)) Store (BB0D, Index(TEMP, 0x0D)) Store (BB0E, Index(TEMP, 0x0E)) Store (BB0F, Index(TEMP, 0x0F)) Store (BB10, Index(TEMP, 0x10)) Store (BB11, Index(TEMP, 0x11)) Store (BB12, Index(TEMP, 0x12)) Store (BB13, Index(TEMP, 0x13)) Store (BB14, Index(TEMP, 0x14)) Store (BB15, Index(TEMP, 0x15)) Store (BB16, Index(TEMP, 0x16)) Store (BB17, Index(TEMP, 0x17)) Store (BB18, Index(TEMP, 0x18)) Store (BB19, Index(TEMP, 0x19)) Store (BB1A, Index(TEMP, 0x1A)) Store (BB1B, Index(TEMP, 0x1B)) Store (BB1C, Index(TEMP, 0x1C)) Store (BB1D, Index(TEMP, 0x1D)) Store (BB1E, Index(TEMP, 0x1E)) Store (BB1F, Index(TEMP, 0x1F)) Return (TEMP) } Method (WRBB, 1, Serialized) { Name (TEMP, Buffer(0x20) { }) Store (Arg0, TEMP) Store (DerefOf(Index(TEMP, 0x00)), BB00) Store (DerefOf(Index(TEMP, 0x01)), BB01) Store (DerefOf(Index(TEMP, 0x02)), BB02) Store (DerefOf(Index(TEMP, 0x03)), BB03) Store (DerefOf(Index(TEMP, 0x04)), BB04) Store (DerefOf(Index(TEMP, 0x05)), BB05) Store (DerefOf(Index(TEMP, 0x06)), BB06) Store (DerefOf(Index(TEMP, 0x07)), BB07) Store (DerefOf(Index(TEMP, 0x08)), BB08) Store (DerefOf(Index(TEMP, 0x09)), BB09) Store (DerefOf(Index(TEMP, 0x0A)), BB0A) Store (DerefOf(Index(TEMP, 0x0B)), BB0B) Store (DerefOf(Index(TEMP, 0x0C)), BB0C) Store (DerefOf(Index(TEMP, 0x0D)), BB0D) Store (DerefOf(Index(TEMP, 0x0E)), BB0E) Store (DerefOf(Index(TEMP, 0x0F)), BB0F) Store (DerefOf(Index(TEMP, 0x10)), BB10) Store (DerefOf(Index(TEMP, 0x11)), BB11) Store (DerefOf(Index(TEMP, 0x12)), BB12) Store (DerefOf(Index(TEMP, 0x13)), BB13) Store (DerefOf(Index(TEMP, 0x14)), BB14) Store (DerefOf(Index(TEMP, 0x15)), BB15) Store (DerefOf(Index(TEMP, 0x16)), BB16) Store (DerefOf(Index(TEMP, 0x17)), BB17) Store (DerefOf(Index(TEMP, 0x18)), BB18) Store (DerefOf(Index(TEMP, 0x19)), BB19) Store (DerefOf(Index(TEMP, 0x1A)), BB1A) Store (DerefOf(Index(TEMP, 0x1B)), BB1B) Store (DerefOf(Index(TEMP, 0x1C)), BB1C) Store (DerefOf(Index(TEMP, 0x1D)), BB1D) Store (DerefOf(Index(TEMP, 0x1E)), BB1E) Store (DerefOf(Index(TEMP, 0x1F)), BB1F) } } } } Notice how FBST and _BIX were added to scope _SB.PCI0.BAT0, but BIFA was added to _SB.PCI0.LPCB.EC0. It is important to inject all methods into their original scope. Now, we add SMBR, SMBW, ECSB, and TACH: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684DefinitionBlock(&quot;&quot;, &quot;SSDT&quot;, 2, &quot;hack&quot;, &quot;batt&quot;, 0)&#123; // patched methods Scope (_SB.PCI0) &#123; Scope (BAT0) &#123; Method (FBST, 4, NotSerialized) &#123; And (Arg1, 0xFFFF, Local1) Store (Zero, Local0) If (^^LPCB.EC0.ACAP ()) &#123; Store (One, Local0) &#125; If (Local0) &#123; If (CHGS (Zero))&#123; Store (0x02, Local0)&#125;Else&#123; Store (Zero, Local0)&#125; &#125; Else &#123; Store (One, Local0) &#125; If (BLLO) &#123; ShiftLeft (One, 0x02, Local2) Or (Local0, Local2, Local0) &#125; If (And (^^LPCB.EC0.EB0S, 0x08)) &#123; ShiftLeft (One, 0x02, Local2) Or (Local0, Local2, Local0) &#125; If (LGreaterEqual (Local1, 0x8000)) &#123; Subtract (0xFFFF, Local1, Local1) &#125; Store (Arg2, Local2) If (LEqual (PUNT, Zero)) &#123; Multiply (Local1, ^^LPCB.EC0.B0DV, Local1) Multiply (Local2, 0x0A, Local2) &#125; And (Local0, 0x02, Local3) If (LNot (Local3)) &#123; Subtract (LFCC, Local2, Local3) Divide (LFCC, 0xC8, Local4, Local5) If (LLess (Local3, Local5)) &#123; Store (LFCC, Local2) &#125; &#125; Else &#123; Divide (LFCC, 0xC8, Local4, Local5) Subtract (LFCC, Local5, Local4) If (LGreater (Local2, Local4)) &#123; Store (Local4, Local2) &#125; &#125; If (LNot (^^LPCB.EC0.ACAP ())) &#123; Divide (Local2, MBLF, Local3, Local4) If (LLess (Local1, Local4)) &#123; Store (Local4, Local1) &#125; &#125; Store (Local0, Index (PBST, Zero)) Store (Local1, Index (PBST, One)) Store (Local2, Index (PBST, 0x02)) Store (Arg3, Index (PBST, 0x03)) &#125; Method (_BIX, 0, NotSerialized) // _BIX: Battery Information Extended &#123; If (LNot (^^LPCB.EC0.BATP (Zero))) &#123; Return (NBIX) &#125; If (LEqual (^^LPCB.EC0.GBTT (Zero), 0xFF)) &#123; Return (NBIX) &#125; _BIF () Store (DerefOf (Index (PBIF, Zero)), Index (BIXT, One)) Store (DerefOf (Index (PBIF, One)), Index (BIXT, 0x02)) Store (DerefOf (Index (PBIF, 0x02)), Index (BIXT, 0x03)) Store (DerefOf (Index (PBIF, 0x03)), Index (BIXT, 0x04)) Store (DerefOf (Index (PBIF, 0x04)), Index (BIXT, 0x05)) Store (DerefOf (Index (PBIF, 0x05)), Index (BIXT, 0x06)) Store (DerefOf (Index (PBIF, 0x06)), Index (BIXT, 0x07)) Store (DerefOf (Index (PBIF, 0x07)), Index (BIXT, 0x0E)) Store (DerefOf (Index (PBIF, 0x08)), Index (BIXT, 0x0F)) Store (DerefOf (Index (PBIF, 0x09)), Index (BIXT, 0x10)) Store (DerefOf (Index (PBIF, 0x0A)), Index (BIXT, 0x11)) Store (DerefOf (Index (PBIF, 0x0B)), Index (BIXT, 0x12)) Store (DerefOf (Index (PBIF, 0x0C)), Index (BIXT, 0x13)) If (LEqual (DerefOf (Index (BIXT, One)), One)) &#123; Store (Zero, Index (BIXT, One)) Store (DerefOf (Index (BIXT, 0x05)), Local0) Multiply (DerefOf (Index (BIXT, 0x02)), Local0, Index (BIXT, 0x02)) Multiply (DerefOf (Index (BIXT, 0x03)), Local0, Index (BIXT, 0x03)) Multiply (DerefOf (Index (BIXT, 0x06)), Local0, Index (BIXT, 0x06)) Multiply (DerefOf (Index (BIXT, 0x07)), Local0, Index (BIXT, 0x07)) Multiply (DerefOf (Index (BIXT, 0x0E)), Local0, Index (BIXT, 0x0E)) Multiply (DerefOf (Index (BIXT, 0x0F)), Local0, Index (BIXT, 0x0F)) Divide (DerefOf (Index (BIXT, 0x02)), 0x03E8, Local0, Index (BIXT, 0x02)) Divide (DerefOf (Index (BIXT, 0x03)), 0x03E8, Local0, Index (BIXT, 0x03)) Divide (DerefOf (Index (BIXT, 0x06)), 0x03E8, Local0, Index (BIXT, 0x06)) Divide (DerefOf (Index (BIXT, 0x07)), 0x03E8, Local0, Index (BIXT, 0x07)) Divide (DerefOf (Index (BIXT, 0x0E)), 0x03E8, Local0, Index (BIXT, 0x0E)) Divide (DerefOf (Index (BIXT, 0x0F)), 0x03E8, Local0, Index (BIXT, 0x0F)) &#125; Store (B1B2(^^LPCB.EC0.XC30,^^LPCB.EC0.XC31), Index (BIXT, 0x08)) Store (0x0001869F, Index (BIXT, 0x09)) Return (BIXT) &#125; &#125; &#125; Scope (_SB.PCI0.LPCB.EC0) &#123; Method (BIFA, 0, NotSerialized) &#123; If (ECAV ()) &#123; If (BSLF) &#123; Store (B1B2(B1S0,B1S1), Local0) &#125; Else &#123; Store (B1B2(B0S0,B0S1), Local0) &#125; &#125; Else &#123; Store (Ones, Local0) &#125; Return (Local0) &#125; Method (SMBR, 3, Serialized) &#123; Store (Package (0x03) &#123; 0x07, Zero, Zero &#125;, Local0) If (LNot (ECAV ())) &#123; Return (Local0) &#125; If (LNotEqual (Arg0, RDBL)) &#123; If (LNotEqual (Arg0, RDWD)) &#123; If (LNotEqual (Arg0, RDBT)) &#123; If (LNotEqual (Arg0, RCBT)) &#123; If (LNotEqual (Arg0, RDQK)) &#123; Return (Local0) &#125; &#125; &#125; &#125; &#125; Acquire (MUEC, 0xFFFF) Store (PRTC, Local1) Store (Zero, Local2) While (LNotEqual (Local1, Zero)) &#123; Stall (0x0A) Increment (Local2) If (LGreater (Local2, 0x03E8)) &#123; Store (SBBY, Index (Local0, Zero)) Store (Zero, Local1) &#125; Else &#123; Store (PRTC, Local1) &#125; &#125; If (LLessEqual (Local2, 0x03E8)) &#123; ShiftLeft (Arg1, One, Local3) Or (Local3, One, Local3) Store (Local3, ADDR) If (LNotEqual (Arg0, RDQK)) &#123; If (LNotEqual (Arg0, RCBT)) &#123; Store (Arg2, CMDB) &#125; &#125; WRBA(Zero) Store (Arg0, PRTC) Store (SWTC (Arg0), Index (Local0, Zero)) If (LEqual (DerefOf (Index (Local0, Zero)), Zero)) &#123; If (LEqual (Arg0, RDBL)) &#123; Store (BCNT, Index (Local0, One)) Store (RDBA(), Index (Local0, 0x02)) &#125; If (LEqual (Arg0, RDWD)) &#123; Store (0x02, Index (Local0, One)) Store (B1B2(T2B0,T2B1), Index (Local0, 0x02)) &#125; If (LEqual (Arg0, RDBT)) &#123; Store (One, Index (Local0, One)) Store (DAT0, Index (Local0, 0x02)) &#125; If (LEqual (Arg0, RCBT)) &#123; Store (One, Index (Local0, One)) Store (DAT0, Index (Local0, 0x02)) &#125; &#125; &#125; Release (MUEC) Return (Local0) &#125; Method (SMBW, 5, Serialized) &#123; Store (Package (0x01) &#123; 0x07 &#125;, Local0) If (LNot (ECAV ())) &#123; Return (Local0) &#125; If (LNotEqual (Arg0, WRBL)) &#123; If (LNotEqual (Arg0, WRWD)) &#123; If (LNotEqual (Arg0, WRBT)) &#123; If (LNotEqual (Arg0, SDBT)) &#123; If (LNotEqual (Arg0, WRQK)) &#123; Return (Local0) &#125; &#125; &#125; &#125; &#125; Acquire (MUEC, 0xFFFF) Store (PRTC, Local1) Store (Zero, Local2) While (LNotEqual (Local1, Zero)) &#123; Stall (0x0A) Increment (Local2) If (LGreater (Local2, 0x03E8)) &#123; Store (SBBY, Index (Local0, Zero)) Store (Zero, Local1) &#125; Else &#123; Store (PRTC, Local1) &#125; &#125; If (LLessEqual (Local2, 0x03E8)) &#123; WRBA(Zero) ShiftLeft (Arg1, One, Local3) Store (Local3, ADDR) If (LNotEqual (Arg0, WRQK)) &#123; If (LNotEqual (Arg0, SDBT)) &#123; Store (Arg2, CMDB) &#125; &#125; If (LEqual (Arg0, WRBL)) &#123; Store (Arg3, BCNT) WRBA(Arg4) &#125; If (LEqual (Arg0, WRWD)) &#123; Store(Arg4,T2B0) Store(ShiftRight(Arg4,8),T2B1) &#125; If (LEqual (Arg0, WRBT)) &#123; Store (Arg4, DAT0) &#125; If (LEqual (Arg0, SDBT)) &#123; Store (Arg4, DAT0) &#125; Store (Arg0, PRTC) Store (SWTC (Arg0), Index (Local0, Zero)) &#125; Release (MUEC) Return (Local0) &#125; Method (ECSB, 7, NotSerialized) &#123; Store (Package (0x05) &#123; 0x11, Zero, Zero, Zero, Buffer (0x20)&#123;&#125; &#125;, Local1) If (LGreater (Arg0, One)) &#123; Return (Local1) &#125; If (ECAV ()) &#123; Acquire (MUEC, 0xFFFF) If (LEqual (Arg0, Zero)) &#123; Store (PRTC, Local0) &#125; Else &#123; Store (PRT2, Local0) &#125; Store (Zero, Local2) While (LNotEqual (Local0, Zero)) &#123; Stall (0x0A) Increment (Local2) If (LGreater (Local2, 0x03E8)) &#123; Store (SBBY, Index (Local1, Zero)) Store (Zero, Local0) &#125; ElseIf (LEqual (Arg0, Zero)) &#123; Store (PRTC, Local0) &#125; Else &#123; Store (PRT2, Local0) &#125; &#125; If (LLessEqual (Local2, 0x03E8)) &#123; If (LEqual (Arg0, Zero)) &#123; Store (Arg2, ADDR) Store (Arg3, CMDB) If (LOr (LEqual (Arg1, 0x0A), LEqual (Arg1, 0x0B))) &#123; Store (DerefOf (Index (Arg6, Zero)), BCNT) WRBA(DerefOf (Index (Arg6, One))) &#125; Else &#123; Store (Arg4, DAT0) Store (Arg5, DAT1) &#125; Store (Arg1, PRTC) &#125; Else &#123; Store (Arg2, ADD2) Store (Arg3, CMD2) If (LOr (LEqual (Arg1, 0x0A), LEqual (Arg1, 0x0B))) &#123; Store (DerefOf (Index (Arg6, Zero)), BCN2) WRBB(DerefOf (Index (Arg6, One))) &#125; Else &#123; Store (Arg4, DA20) Store (Arg5, DA21) &#125; Store (Arg1, PRT2) &#125; Store (0x7F, Local0) If (LEqual (Arg0, Zero)) &#123; While (PRTC) &#123; Sleep (One) Decrement (Local0) &#125; &#125; Else &#123; While (PRT2) &#123; Sleep (One) Decrement (Local0) &#125; &#125; If (Local0) &#123; If (LEqual (Arg0, Zero)) &#123; Store (SSTS, Local0) Store (DAT0, Index (Local1, One)) Store (DAT1, Index (Local1, 0x02)) Store (BCNT, Index (Local1, 0x03)) Store (RDBA(), Index (Local1, 0x04)) &#125; Else &#123; Store (SST2, Local0) Store (DA20, Index (Local1, One)) Store (DA21, Index (Local1, 0x02)) Store (BCN2, Index (Local1, 0x03)) Store (RDBB(), Index (Local1, 0x04)) &#125; And (Local0, 0x1F, Local0) If (Local0) &#123; Add (Local0, 0x10, Local0) &#125; Store (Local0, Index (Local1, Zero)) &#125; Else &#123; Store (0x10, Index (Local1, Zero)) &#125; &#125; Release (MUEC) &#125; Return (Local1) &#125; Method (TACH, 1, Serialized) &#123; If (ECAV ()) &#123; Switch (Arg0) &#123; Case (Zero) &#123; Store (B1B2(TH00,TH01), Local0) Break &#125; Case (One) &#123; Store (B1B2(TH10,TH11), Local0) Break &#125; Default &#123; Return (Ones) &#125; &#125; Multiply (Local0, 0x02, Local0) If (LNotEqual (Local0, Zero)) &#123; Divide (0x0041CDB4, Local0, Local1, Local0) Return (Local0) &#125; Else &#123; Return (Ones) &#125; &#125; Else &#123; Return (Ones) &#125; &#125; &#125; Method (B1B2, 2, NotSerialized) &#123; Return (Or (Arg0, ShiftLeft (Arg1, 8))) &#125; // added methods (group 2) Scope (_SB.PCI0.LPCB) &#123; Scope (EC0) &#123; Method (RDBA, 0, Serialized) &#123; Name (TEMP, Buffer(0x20) &#123; &#125;) Store (BA00, Index(TEMP, 0x00)) Store (BA01, Index(TEMP, 0x01)) Store (BA02, Index(TEMP, 0x02)) Store (BA03, Index(TEMP, 0x03)) Store (BA04, Index(TEMP, 0x04)) Store (BA05, Index(TEMP, 0x05)) Store (BA06, Index(TEMP, 0x06)) Store (BA07, Index(TEMP, 0x07)) Store (BA08, Index(TEMP, 0x08)) Store (BA09, Index(TEMP, 0x09)) Store (BA0A, Index(TEMP, 0x0A)) Store (BA0B, Index(TEMP, 0x0B)) Store (BA0C, Index(TEMP, 0x0C)) Store (BA0D, Index(TEMP, 0x0D)) Store (BA0E, Index(TEMP, 0x0E)) Store (BA0F, Index(TEMP, 0x0F)) Store (BA10, Index(TEMP, 0x10)) Store (BA11, Index(TEMP, 0x11)) Store (BA12, Index(TEMP, 0x12)) Store (BA13, Index(TEMP, 0x13)) Store (BA14, Index(TEMP, 0x14)) Store (BA15, Index(TEMP, 0x15)) Store (BA16, Index(TEMP, 0x16)) Store (BA17, Index(TEMP, 0x17)) Store (BA18, Index(TEMP, 0x18)) Store (BA19, Index(TEMP, 0x19)) Store (BA1A, Index(TEMP, 0x1A)) Store (BA1B, Index(TEMP, 0x1B)) Store (BA1C, Index(TEMP, 0x1C)) Store (BA1D, Index(TEMP, 0x1D)) Store (BA1E, Index(TEMP, 0x1E)) Store (BA1F, Index(TEMP, 0x1F)) Return (TEMP) &#125; Method (WRBA, 1, Serialized) &#123; Name (TEMP, Buffer(0x20) &#123; &#125;) Store (Arg0, TEMP) Store (DerefOf(Index(TEMP, 0x00)), BA00) Store (DerefOf(Index(TEMP, 0x01)), BA01) Store (DerefOf(Index(TEMP, 0x02)), BA02) Store (DerefOf(Index(TEMP, 0x03)), BA03) Store (DerefOf(Index(TEMP, 0x04)), BA04) Store (DerefOf(Index(TEMP, 0x05)), BA05) Store (DerefOf(Index(TEMP, 0x06)), BA06) Store (DerefOf(Index(TEMP, 0x07)), BA07) Store (DerefOf(Index(TEMP, 0x08)), BA08) Store (DerefOf(Index(TEMP, 0x09)), BA09) Store (DerefOf(Index(TEMP, 0x0A)), BA0A) Store (DerefOf(Index(TEMP, 0x0B)), BA0B) Store (DerefOf(Index(TEMP, 0x0C)), BA0C) Store (DerefOf(Index(TEMP, 0x0D)), BA0D) Store (DerefOf(Index(TEMP, 0x0E)), BA0E) Store (DerefOf(Index(TEMP, 0x0F)), BA0F) Store (DerefOf(Index(TEMP, 0x10)), BA10) Store (DerefOf(Index(TEMP, 0x11)), BA11) Store (DerefOf(Index(TEMP, 0x12)), BA12) Store (DerefOf(Index(TEMP, 0x13)), BA13) Store (DerefOf(Index(TEMP, 0x14)), BA14) Store (DerefOf(Index(TEMP, 0x15)), BA15) Store (DerefOf(Index(TEMP, 0x16)), BA16) Store (DerefOf(Index(TEMP, 0x17)), BA17) Store (DerefOf(Index(TEMP, 0x18)), BA18) Store (DerefOf(Index(TEMP, 0x19)), BA19) Store (DerefOf(Index(TEMP, 0x1A)), BA1A) Store (DerefOf(Index(TEMP, 0x1B)), BA1B) Store (DerefOf(Index(TEMP, 0x1C)), BA1C) Store (DerefOf(Index(TEMP, 0x1D)), BA1D) Store (DerefOf(Index(TEMP, 0x1E)), BA1E) Store (DerefOf(Index(TEMP, 0x1F)), BA1F) &#125; Method (RDBB, 0, Serialized) &#123; Name (TEMP, Buffer(0x20) &#123; &#125;) Store (BB00, Index(TEMP, 0x00)) Store (BB01, Index(TEMP, 0x01)) Store (BB02, Index(TEMP, 0x02)) Store (BB03, Index(TEMP, 0x03)) Store (BB04, Index(TEMP, 0x04)) Store (BB05, Index(TEMP, 0x05)) Store (BB06, Index(TEMP, 0x06)) Store (BB07, Index(TEMP, 0x07)) Store (BB08, Index(TEMP, 0x08)) Store (BB09, Index(TEMP, 0x09)) Store (BB0A, Index(TEMP, 0x0A)) Store (BB0B, Index(TEMP, 0x0B)) Store (BB0C, Index(TEMP, 0x0C)) Store (BB0D, Index(TEMP, 0x0D)) Store (BB0E, Index(TEMP, 0x0E)) Store (BB0F, Index(TEMP, 0x0F)) Store (BB10, Index(TEMP, 0x10)) Store (BB11, Index(TEMP, 0x11)) Store (BB12, Index(TEMP, 0x12)) Store (BB13, Index(TEMP, 0x13)) Store (BB14, Index(TEMP, 0x14)) Store (BB15, Index(TEMP, 0x15)) Store (BB16, Index(TEMP, 0x16)) Store (BB17, Index(TEMP, 0x17)) Store (BB18, Index(TEMP, 0x18)) Store (BB19, Index(TEMP, 0x19)) Store (BB1A, Index(TEMP, 0x1A)) Store (BB1B, Index(TEMP, 0x1B)) Store (BB1C, Index(TEMP, 0x1C)) Store (BB1D, Index(TEMP, 0x1D)) Store (BB1E, Index(TEMP, 0x1E)) Store (BB1F, Index(TEMP, 0x1F)) Return (TEMP) &#125; Method (WRBB, 1, Serialized) &#123; Name (TEMP, Buffer(0x20) &#123; &#125;) Store (Arg0, TEMP) Store (DerefOf(Index(TEMP, 0x00)), BB00) Store (DerefOf(Index(TEMP, 0x01)), BB01) Store (DerefOf(Index(TEMP, 0x02)), BB02) Store (DerefOf(Index(TEMP, 0x03)), BB03) Store (DerefOf(Index(TEMP, 0x04)), BB04) Store (DerefOf(Index(TEMP, 0x05)), BB05) Store (DerefOf(Index(TEMP, 0x06)), BB06) Store (DerefOf(Index(TEMP, 0x07)), BB07) Store (DerefOf(Index(TEMP, 0x08)), BB08) Store (DerefOf(Index(TEMP, 0x09)), BB09) Store (DerefOf(Index(TEMP, 0x0A)), BB0A) Store (DerefOf(Index(TEMP, 0x0B)), BB0B) Store (DerefOf(Index(TEMP, 0x0C)), BB0C) Store (DerefOf(Index(TEMP, 0x0D)), BB0D) Store (DerefOf(Index(TEMP, 0x0E)), BB0E) Store (DerefOf(Index(TEMP, 0x0F)), BB0F) Store (DerefOf(Index(TEMP, 0x10)), BB10) Store (DerefOf(Index(TEMP, 0x11)), BB11) Store (DerefOf(Index(TEMP, 0x12)), BB12) Store (DerefOf(Index(TEMP, 0x13)), BB13) Store (DerefOf(Index(TEMP, 0x14)), BB14) Store (DerefOf(Index(TEMP, 0x15)), BB15) Store (DerefOf(Index(TEMP, 0x16)), BB16) Store (DerefOf(Index(TEMP, 0x17)), BB17) Store (DerefOf(Index(TEMP, 0x18)), BB18) Store (DerefOf(Index(TEMP, 0x19)), BB19) Store (DerefOf(Index(TEMP, 0x1A)), BB1A) Store (DerefOf(Index(TEMP, 0x1B)), BB1B) Store (DerefOf(Index(TEMP, 0x1C)), BB1C) Store (DerefOf(Index(TEMP, 0x1D)), BB1D) Store (DerefOf(Index(TEMP, 0x1E)), BB1E) Store (DerefOf(Index(TEMP, 0x1F)), BB1F) &#125; &#125; &#125;&#125; With all the nodes expanded in MaciASL, our work looks like this: Resolving errorsNow we need to start resolving errors by using External or defining the patched EC fields as necessary.We can use the compiler to help. Clicking Compile will show the first error: “3, 6085, Object not found or not accessible from scope (_SB.PCI0)”It is at this line: Scope (_SB.PCI0) The compiler is indicating that _SB.PCI0 is not declared, so you can’t use it in a Scope operator. We need to declare it with External, as the scope is actually defined in another file (DSDT.aml):Add it to the top of the file: 123456DefinitionBlock(&quot;&quot;, &quot;SSDT&quot;, 2, &quot;hack&quot;, &quot;batt&quot;, 0)&#123; External(_SB.PCI0, DeviceObj) Scope (_SB.PCI0) &#123;... Now the next error is at “Scope(BAT0)”, so, again: DefinitionBlock(&quot;&quot;, &quot;SSDT&quot;, 2, &quot;hack&quot;, &quot;batt&quot;, 0) { External(_SB.PCI0, DeviceObj) External(_SB.PCI0.BAT0, DeviceObj) Scope (_SB.PCI0) { Scope (BAT0) { ... The next error is “13, 6085, Object not found or not accessible from scope (^^LPCB.EC0.ACAP)”We can tell from the code referencing ACAP that it is a method: If (^^LPCB.EC0.ACAP ()) Note: Method calls are indicated by the “()” (in this case, an empty parameter list). So, we know we can add an External as MethodObj: DefinitionBlock(&quot;&quot;, &quot;SSDT&quot;, 2, &quot;hack&quot;, &quot;batt&quot;, 0) { External(_SB.PCI0, DeviceObj) External(_SB.PCI0.BAT0, DeviceObj) External(_SB.PCI0.LPCB.EC0.ACAP, MethodObj) ... } Note: The path ^^LPCB.EC0.ACAP is equivalent to _SB.PCI0.LPCB.EC0.ACAP because the reference was in scope _SB.PCI0.BAT0.FBST (the path of the FBST method). Each ^ (parent of) operator walks up the current scope by one item, so ^ is _SB.PCI0.BAT0, and ^^ is _SB.PCI0. In some cases, you need to look at the DSDT to find the path and/or type of a given identifier. For example, the next error has to do with CHGS. Again, we know it is a method as it is the target of a method call, but for the path, we must refer to the DSDT:Code (Text): Scope (\) { Method (CHGS, 1, Serialized) { Store (\_SB.PCI0.LPCB.EC0.BCHG (Arg0), Local0) Return (Local0) } So, it is in the root: DefinitionBlock(&quot;&quot;, &quot;SSDT&quot;, 2, &quot;hack&quot;, &quot;batt&quot;, 0) { External(_SB.PCI0, DeviceObj) External(_SB.PCI0.BAT0, DeviceObj) External(_SB.PCI0.LPCB.EC0.ACAP, MethodObj) External(CHGS, MethodObj) ... The next undefined symbol, BLLO, is something other than a method: If (BLLO) { Looking in DSDT, we find it is defined with Name (and it happens to be in root scope): Name (BLLO, Zero) Which makes it an IntObj: DefinitionBlock(&quot;&quot;, &quot;SSDT&quot;, 2, &quot;hack&quot;, &quot;batt&quot;, 0) { External(_SB.PCI0, DeviceObj) External(_SB.PCI0.BAT0, DeviceObj) External(_SB.PCI0.LPCB.EC0.ACAP, MethodObj) External(CHGS, MethodObj) External(BLLO, IntObj) ... Fixing all the errors in the FBST method: DefinitionBlock(&quot;&quot;, &quot;SSDT&quot;, 2, &quot;hack&quot;, &quot;batt&quot;, 0) { External(_SB.PCI0, DeviceObj) External(_SB.PCI0.BAT0, DeviceObj) External(_SB.PCI0.LPCB.EC0.ACAP, MethodObj) External(CHGS, MethodObj) External(BLLO, IntObj) External(_SB.PCI0.LPCB.EC0.EB0S, FieldUnitObj) External(_SB.PCI0.BAT0.PUNT, IntObj) External(_SB.PCI0.LPCB.EC0.B0DV, FieldUnitObj) External(_SB.PCI0.BAT0.LFCC, IntObj) External(MBLF, IntObj) External(_SB.PCI0.BAT0.PBST, PkgObj) ... And now continue with the same process. Eventually, you will have: DefinitionBlock(&quot;&quot;, &quot;SSDT&quot;, 2, &quot;hack&quot;, &quot;batt&quot;, 0) { External(_SB.PCI0, DeviceObj) External(_SB.PCI0.BAT0, DeviceObj) External(_SB.PCI0.LPCB.EC0.ACAP, MethodObj) External(CHGS, MethodObj) External(BLLO, IntObj) External(_SB.PCI0.LPCB.EC0.EB0S, FieldUnitObj) External(_SB.PCI0.BAT0.PUNT, IntObj) External(_SB.PCI0.LPCB.EC0.B0DV, FieldUnitObj) External(_SB.PCI0.BAT0.LFCC, IntObj) External(MBLF, IntObj) External(_SB.PCI0.BAT0.PBST, PkgObj) External(_SB.PCI0.LPCB.EC0.BATP, MethodObj) External(_SB.PCI0.BAT0.NBIX, PkgObj) External(_SB.PCI0.LPCB.EC0.GBTT, MethodObj) External(_SB.PCI0.BAT0._BIF, MethodObj) External(_SB.PCI0.BAT0.PBIF, PkgObj) External(_SB.PCI0.BAT0.BIXT, PkgObj) ... And will come to an error with XC30/XC31: “153, 6085, Object not found or not accessible from scope (^^LPCB.EC0.XC30)” This is one of the 16-bit fields that was broken into two.And this is where it is necessary to create the EC overlay. To do this, we use another OperationRegion within EC scope, that has a different name than what we find in DSDT: External(_SB.PCI0.LPCB, DeviceObj) External(_SB.PCI0.LPCB.EC0, DeviceObj) Scope(_SB.PCI0.LPCB.EC0) { OperationRegion (ERM2, EmbeddedControl, Zero, 0xFF) Field(ERM2, ByteAcc, NoLock, Preserve) { } } And from DSDT_patched.dsl, we can get the various patched fields (again refer to the diffmerge).This is the entire set from ECOR in the DSDT_patched.dsl Offset (0x04), CMD1, 8, CDT1, 8, CDT2, 8, CDT3, 8, Offset (0x80), Offset (0x81), Offset (0x82), Offset (0x83), EB0R, 8, EB1R, 8, EPWF, 8, Offset (0x87), Offset (0x88), Offset (0x89), Offset (0x8A), HKEN, 1, Offset (0x93), TH00,8,TH01,8, TH10,8,TH11,8, TSTP, 8, Offset (0x9C), CDT4, 8, CDT5, 8, Offset (0xA0), Offset (0xA1), Offset (0xA2), Offset (0xA3), EACT, 8, TH1R, 8, TH1L, 8, TH0R, 8, TH0L, 8, Offset (0xB0), B0PN, 16, Offset (0xB4), Offset (0xB6), Offset (0xB8), Offset (0xBA), Offset (0xBC), Offset (0xBE), B0TM, 16, B0C1, 16, B0C2, 16, XC30,8,XC31,8, B0C4, 16, Offset (0xD0), B1PN, 16, Offset (0xD4), Offset (0xD6), Offset (0xD8), Offset (0xDA), Offset (0xDC), Offset (0xDE), B1TM, 16, B1C1, 16, B1C2, 16, YC30,8,YC31,8, B1C4, 16, Offset (0xF0), Offset (0xF2), Offset (0xF4), B0S0,8,B0S1,8, Offset (0xF8), Offset (0xFA), Offset (0xFC), B1S0,8,B1S1,8 And if we strip the unpatched identifiers, but keep the offsets correct (very important!): Offset (0x93), TH00,8,TH01,8, TH10,8,TH11,8, Offset (0xBE), /*B0TM*/, 16, /*B0C1*/, 16, /*B0C2*/, 16, XC30,8,XC31,8, Offset (0xDE), /*B1TM*/, 16, /*B1C1*/, 16, /*B1C2*/, 16, YC30,8,YC31,8, Offset (0xF4), B0S0,8,B0S1,8, Offset (0xFC), B1S0,8,B1S1,8 The same thing can be written as follows: Offset (0x93), TH00,8,TH01,8, TH10,8,TH11,8, Offset (0xc4), XC30,8,XC31,8, Offset (0xe4), YC30,8,YC31,8, Offset (0xF4), B0S0,8,B0S1,8, Offset (0xFC), B1S0,8,B1S1,8 So, into our SSDT: DefinitionBlock(&quot;&quot;, &quot;SSDT&quot;, 2, &quot;hack&quot;, &quot;batt&quot;, 0) { External(_SB.PCI0, DeviceObj) External(_SB.PCI0.BAT0, DeviceObj) External(_SB.PCI0.LPCB.EC0.ACAP, MethodObj) External(CHGS, MethodObj) External(BLLO, IntObj) External(_SB.PCI0.LPCB.EC0.EB0S, FieldUnitObj) External(_SB.PCI0.BAT0.PUNT, IntObj) External(_SB.PCI0.LPCB.EC0.B0DV, FieldUnitObj) External(_SB.PCI0.BAT0.LFCC, IntObj) External(MBLF, IntObj) External(_SB.PCI0.BAT0.PBST, PkgObj) External(_SB.PCI0.LPCB.EC0.BATP, MethodObj) External(_SB.PCI0.BAT0.NBIX, PkgObj) External(_SB.PCI0.LPCB.EC0.GBTT, MethodObj) External(_SB.PCI0.BAT0._BIF, MethodObj) External(_SB.PCI0.BAT0.PBIF, PkgObj) External(_SB.PCI0.BAT0.BIXT, PkgObj) External(_SB.PCI0.LPCB, DeviceObj) External(_SB.PCI0.LPCB.EC0, DeviceObj) Scope(_SB.PCI0.LPCB.EC0) { OperationRegion (ERM2, EmbeddedControl, Zero, 0xFF) Field(ERM2, ByteAcc, NoLock, Preserve) { Offset (0x93), TH00,8,TH01,8, TH10,8,TH11,8, Offset (0xc4), XC30,8,XC31,8, Offset (0xe4), YC30,8,YC31,8, Offset (0xF4), B0S0,8,B0S1,8, Offset (0xFC), B1S0,8,B1S1,8 } } And then on to fixing more errors, we add some more External: DefinitionBlock(&quot;&quot;, &quot;SSDT&quot;, 2, &quot;hack&quot;, &quot;batt&quot;, 0) { External(_SB.PCI0, DeviceObj) External(_SB.PCI0.BAT0, DeviceObj) External(_SB.PCI0.LPCB.EC0.ACAP, MethodObj) External(CHGS, MethodObj) External(BLLO, IntObj) External(_SB.PCI0.LPCB.EC0.EB0S, FieldUnitObj) External(_SB.PCI0.BAT0.PUNT, IntObj) External(_SB.PCI0.LPCB.EC0.B0DV, FieldUnitObj) External(_SB.PCI0.BAT0.LFCC, IntObj) External(MBLF, IntObj) External(_SB.PCI0.BAT0.PBST, PkgObj) External(_SB.PCI0.LPCB.EC0.BATP, MethodObj) External(_SB.PCI0.BAT0.NBIX, PkgObj) External(_SB.PCI0.LPCB.EC0.GBTT, MethodObj) External(_SB.PCI0.BAT0._BIF, MethodObj) External(_SB.PCI0.BAT0.PBIF, PkgObj) External(_SB.PCI0.BAT0.BIXT, PkgObj) External(_SB.PCI0.LPCB.EC0.ECAV, MethodObj) External(BSLF, IntObj) External(_SB.PCI0.LPCB.EC0.RDBL, IntObj) External(_SB.PCI0.LPCB.EC0.RDWD, IntObj) External(_SB.PCI0.LPCB.EC0.RDBT, IntObj) External(_SB.PCI0.LPCB.EC0.RCBT, IntObj) External(_SB.PCI0.LPCB.EC0.RDQK, IntObj) External(_SB.PCI0.LPCB.EC0.MUEC, MutexObj) External(_SB.PCI0.LPCB.EC0.PRTC, FieldUnitObj) External(_SB.PCI0.LPCB.EC0.SBBY, IntObj) External(_SB.PCI0.LPCB.EC0.ADDR, FieldUnitObj) External(_SB.PCI0.LPCB.EC0.CMDB, FieldUnitObj) External(_SB.PCI0.LPCB.EC0.SWTC, MethodObj) External(_SB.PCI0.LPCB.EC0.BCNT, FieldUnitObj) External(_SB.PCI0.LPCB, DeviceObj) External(_SB.PCI0.LPCB.EC0, DeviceObj) Scope(_SB.PCI0.LPCB.EC0) { ... And then we have errors with T2B0 and T2B1. These are again broken down 16-bit EC fields that need to be defined in our EC overlay. In fact, might as well define the rest we know we need (from diffmerge data). There is patched data in SMBX: OperationRegion (SMBX, EmbeddedControl, 0x18, 0x28) So, we create a similar overlay, with a unique name: OperationRegion (RMB1, EmbeddedControl, 0x18, 0x28) Field (RMB1, ByteAcc, NoLock, Preserve) { /* Note: disabling these fields (already defined in DSDT, referenced with External if needed, but keeping the correct offset! (very important!) */ */ PRTC, 8, SSTS, 5, , 1, ALFG, 1, CDFG, 1, ADDR, 8, CMDB, 8, */ Offset(4), // the data above is 4 bytes offset from the start of this region! //BDAT, 256, BA00,8,BA01,8,BA02,8,BA03,8, BA04,8,BA05,8,BA06,8,BA07,8, BA08,8,BA09,8,BA0A,8,BA0B,8, BA0C,8,BA0D,8,BA0E,8,BA0F,8, BA10,8,BA11,8,BA12,8,BA13,8, BA14,8,BA15,8,BA16,8,BA17,8, BA18,8,BA19,8,BA1A,8,BA1B,8, BA1C,8,BA1D,8,BA1E,8,BA1F,8 } And similar withe SMB2 region: OperationRegion(RMB2, EmbeddedControl, 0x40, 0x28) Field (RMB2, ByteAcc, NoLock, Preserve) { /* PRT2, 8, SST2, 5, , 1, ALF2, 1, CDF2, 1, ADD2, 8, CMD2, 8, */ Offset(4), //BDA2, 256, BB00,8,BB01,8,BB02,8,BB03,8, BB04,8,BB05,8,BB06,8,BB07,8, BB08,8,BB09,8,BB0A,8,BB0B,8, BB0C,8,BB0D,8,BB0E,8,BB0F,8, BB10,8,BB11,8,BB12,8,BB13,8, BB14,8,BB15,8,BB16,8,BB17,8, BB18,8,BB19,8,BB1A,8,BB1B,8, BB1C,8,BB1D,8,BB1E,8,BB1F,8 } And the T2B0 and T2B1 that are in orginal SMBX, but now RMB1: Field (RMB1, ByteAcc, NoLock, Preserve) { Offset (0x04), T2B0,8,T2B1,8 } And now we have: External(_SB.PCI0, DeviceObj) External(_SB.PCI0.BAT0, DeviceObj) External(_SB.PCI0.LPCB.EC0.ACAP, MethodObj) External(CHGS, MethodObj) External(BLLO, IntObj) External(_SB.PCI0.LPCB.EC0.EB0S, FieldUnitObj) External(_SB.PCI0.BAT0.PUNT, IntObj) External(_SB.PCI0.LPCB.EC0.B0DV, FieldUnitObj) External(_SB.PCI0.BAT0.LFCC, IntObj) External(MBLF, IntObj) External(_SB.PCI0.BAT0.PBST, PkgObj) External(_SB.PCI0.LPCB.EC0.BATP, MethodObj) External(_SB.PCI0.BAT0.NBIX, PkgObj) External(_SB.PCI0.LPCB.EC0.GBTT, MethodObj) External(_SB.PCI0.BAT0._BIF, MethodObj) External(_SB.PCI0.BAT0.PBIF, PkgObj) External(_SB.PCI0.BAT0.BIXT, PkgObj) External(_SB.PCI0.LPCB.EC0.ECAV, MethodObj) External(BSLF, IntObj) External(_SB.PCI0.LPCB.EC0.RDBL, IntObj) External(_SB.PCI0.LPCB.EC0.RDWD, IntObj) External(_SB.PCI0.LPCB.EC0.RDBT, IntObj) External(_SB.PCI0.LPCB.EC0.RCBT, IntObj) External(_SB.PCI0.LPCB.EC0.RDQK, IntObj) External(_SB.PCI0.LPCB.EC0.MUEC, MutexObj) External(_SB.PCI0.LPCB.EC0.PRTC, FieldUnitObj) External(_SB.PCI0.LPCB.EC0.SBBY, IntObj) External(_SB.PCI0.LPCB.EC0.ADDR, FieldUnitObj) External(_SB.PCI0.LPCB.EC0.CMDB, FieldUnitObj) External(_SB.PCI0.LPCB.EC0.SWTC, MethodObj) External(_SB.PCI0.LPCB.EC0.BCNT, FieldUnitObj) External(_SB.PCI0.LPCB, DeviceObj) External(_SB.PCI0.LPCB.EC0, DeviceObj) Scope(_SB.PCI0.LPCB.EC0) { OperationRegion (ERM2, EmbeddedControl, Zero, 0xFF) Field(ERM2, ByteAcc, NoLock, Preserve) { Offset (0x93), TH00,8,TH01,8, TH10,8,TH11,8, Offset (0xc4), XC30,8,XC31,8, Offset (0xe4), YC30,8,YC31,8, Offset (0xF4), B0S0,8,B0S1,8, Offset (0xFC), B1S0,8,B1S1,8 } OperationRegion (RMB1, EmbeddedControl, 0x18, 0x28) Field (RMB1, ByteAcc, NoLock, Preserve) { /* Note: disabling these fields (already defined in DSDT, referenced with External if needed, but keeping the correct offset! (very important!) */ */ PRTC, 8, SSTS, 5, , 1, ALFG, 1, CDFG, 1, ADDR, 8, CMDB, 8, */ Offset(4), // the data above is 4 bytes offset from the start of this region! //BDAT, 256, BA00,8,BA01,8,BA02,8,BA03,8, BA04,8,BA05,8,BA06,8,BA07,8, BA08,8,BA09,8,BA0A,8,BA0B,8, BA0C,8,BA0D,8,BA0E,8,BA0F,8, BA10,8,BA11,8,BA12,8,BA13,8, BA14,8,BA15,8,BA16,8,BA17,8, BA18,8,BA19,8,BA1A,8,BA1B,8, BA1C,8,BA1D,8,BA1E,8,BA1F,8 } OperationRegion(RMB2, EmbeddedControl, 0x40, 0x28) Field (RMB2, ByteAcc, NoLock, Preserve) { /* PRT2, 8, SST2, 5, , 1, ALF2, 1, CDF2, 1, ADD2, 8, CMD2, 8, */ Offset(4), //BDA2, 256, BB00,8,BB01,8,BB02,8,BB03,8, BB04,8,BB05,8,BB06,8,BB07,8, BB08,8,BB09,8,BB0A,8,BB0B,8, BB0C,8,BB0D,8,BB0E,8,BB0F,8, BB10,8,BB11,8,BB12,8,BB13,8, BB14,8,BB15,8,BB16,8,BB17,8, BB18,8,BB19,8,BB1A,8,BB1B,8, BB1C,8,BB1D,8,BB1E,8,BB1F,8 } Field (RMB1, ByteAcc, NoLock, Preserve) { Offset (0x04), T2B0,8,T2B1,8 } } Then continue on with fixing more errors with External (it ends eventually!), by adding these External declarations: External(_SB.PCI0.LPCB.EC0.DAT0, FieldUnitObj) External(_SB.PCI0.LPCB.EC0.WRBL, IntObj) External(_SB.PCI0.LPCB.EC0.WRWD, IntObj) External(_SB.PCI0.LPCB.EC0.WRBT, IntObj) External(_SB.PCI0.LPCB.EC0.SDBT, IntObj) External(_SB.PCI0.LPCB.EC0.WRQK, IntObj) External(_SB.PCI0.LPCB.EC0.PRT2, FieldUnitObj) External(_SB.PCI0.LPCB.EC0.DAT1, FieldUnitObj) External(_SB.PCI0.LPCB.EC0.ADD2, FieldUnitObj) External(_SB.PCI0.LPCB.EC0.CMD2, FieldUnitObj) External(_SB.PCI0.LPCB.EC0.BCN2, FieldUnitObj) External(_SB.PCI0.LPCB.EC0.DA20, FieldUnitObj) External(_SB.PCI0.LPCB.EC0.DA21, FieldUnitObj) External(_SB.PCI0.LPCB.EC0.SSTS, FieldUnitObj) External(_SB.PCI0.LPCB.EC0.SST2, FieldUnitObj) Note: With DAT0, don’t be confused at the “other” DAT0 in a different scope! At this point, the SSDT compiles without any errors: DefinitionBlock(&quot;&quot;, &quot;SSDT&quot;, 2, &quot;hack&quot;, &quot;batt&quot;, 0) { External(_SB.PCI0, DeviceObj) External(_SB.PCI0.BAT0, DeviceObj) External(_SB.PCI0.LPCB.EC0.ACAP, MethodObj) External(CHGS, MethodObj) External(BLLO, IntObj) External(_SB.PCI0.LPCB.EC0.EB0S, FieldUnitObj) External(_SB.PCI0.BAT0.PUNT, IntObj) External(_SB.PCI0.LPCB.EC0.B0DV, FieldUnitObj) External(_SB.PCI0.BAT0.LFCC, IntObj) External(MBLF, IntObj) External(_SB.PCI0.BAT0.PBST, PkgObj) External(_SB.PCI0.LPCB.EC0.BATP, MethodObj) External(_SB.PCI0.BAT0.NBIX, PkgObj) External(_SB.PCI0.LPCB.EC0.GBTT, MethodObj) External(_SB.PCI0.BAT0._BIF, MethodObj) External(_SB.PCI0.BAT0.PBIF, PkgObj) External(_SB.PCI0.BAT0.BIXT, PkgObj) External(_SB.PCI0.LPCB.EC0.ECAV, MethodObj) External(BSLF, IntObj) External(_SB.PCI0.LPCB.EC0.RDBL, IntObj) External(_SB.PCI0.LPCB.EC0.RDWD, IntObj) External(_SB.PCI0.LPCB.EC0.RDBT, IntObj) External(_SB.PCI0.LPCB.EC0.RCBT, IntObj) External(_SB.PCI0.LPCB.EC0.RDQK, IntObj) External(_SB.PCI0.LPCB.EC0.MUEC, MutexObj) External(_SB.PCI0.LPCB.EC0.PRTC, FieldUnitObj) External(_SB.PCI0.LPCB.EC0.SBBY, IntObj) External(_SB.PCI0.LPCB.EC0.ADDR, FieldUnitObj) External(_SB.PCI0.LPCB.EC0.CMDB, FieldUnitObj) External(_SB.PCI0.LPCB.EC0.SWTC, MethodObj) External(_SB.PCI0.LPCB.EC0.BCNT, FieldUnitObj) External(_SB.PCI0.LPCB.EC0.DAT0, FieldUnitObj) External(_SB.PCI0.LPCB.EC0.WRBL, IntObj) External(_SB.PCI0.LPCB.EC0.WRWD, IntObj) External(_SB.PCI0.LPCB.EC0.WRBT, IntObj) External(_SB.PCI0.LPCB.EC0.SDBT, IntObj) External(_SB.PCI0.LPCB.EC0.WRQK, IntObj) External(_SB.PCI0.LPCB.EC0.PRT2, FieldUnitObj) External(_SB.PCI0.LPCB.EC0.DAT1, FieldUnitObj) External(_SB.PCI0.LPCB.EC0.ADD2, FieldUnitObj) External(_SB.PCI0.LPCB.EC0.CMD2, FieldUnitObj) External(_SB.PCI0.LPCB.EC0.BCN2, FieldUnitObj) External(_SB.PCI0.LPCB.EC0.DA20, FieldUnitObj) External(_SB.PCI0.LPCB.EC0.DA21, FieldUnitObj) External(_SB.PCI0.LPCB.EC0.SSTS, FieldUnitObj) External(_SB.PCI0.LPCB.EC0.SST2, FieldUnitObj) External(_SB.PCI0.LPCB, DeviceObj) External(_SB.PCI0.LPCB.EC0, DeviceObj) Scope(_SB.PCI0.LPCB.EC0) { OperationRegion (ERM2, EmbeddedControl, Zero, 0xFF) Field(ERM2, ByteAcc, NoLock, Preserve) { Offset (0x93), TH00,8,TH01,8, TH10,8,TH11,8, Offset (0xc4), XC30,8,XC31,8, Offset (0xe4), YC30,8,YC31,8, Offset (0xF4), B0S0,8,B0S1,8, Offset (0xFC), B1S0,8,B1S1,8 } OperationRegion (RMB1, EmbeddedControl, 0x18, 0x28) Field (RMB1, ByteAcc, NoLock, Preserve) { /* Note: disabling these fields (already defined in DSDT, referenced with External if needed, but keeping the correct offset! (very important!) */ */ PRTC, 8, SSTS, 5, , 1, ALFG, 1, CDFG, 1, ADDR, 8, CMDB, 8, */ Offset(4), // the data above is 4 bytes offset from the start of this region! //BDAT, 256, BA00,8,BA01,8,BA02,8,BA03,8, BA04,8,BA05,8,BA06,8,BA07,8, BA08,8,BA09,8,BA0A,8,BA0B,8, BA0C,8,BA0D,8,BA0E,8,BA0F,8, BA10,8,BA11,8,BA12,8,BA13,8, BA14,8,BA15,8,BA16,8,BA17,8, BA18,8,BA19,8,BA1A,8,BA1B,8, BA1C,8,BA1D,8,BA1E,8,BA1F,8 } OperationRegion(RMB2, EmbeddedControl, 0x40, 0x28) Field (RMB2, ByteAcc, NoLock, Preserve) { /* PRT2, 8, SST2, 5, , 1, ALF2, 1, CDF2, 1, ADD2, 8, CMD2, 8, */ Offset(4), //BDA2, 256, BB00,8,BB01,8,BB02,8,BB03,8, BB04,8,BB05,8,BB06,8,BB07,8, BB08,8,BB09,8,BB0A,8,BB0B,8, BB0C,8,BB0D,8,BB0E,8,BB0F,8, BB10,8,BB11,8,BB12,8,BB13,8, BB14,8,BB15,8,BB16,8,BB17,8, BB18,8,BB19,8,BB1A,8,BB1B,8, BB1C,8,BB1D,8,BB1E,8,BB1F,8 } Field (RMB1, ByteAcc, NoLock, Preserve) { Offset (0x04), T2B0,8,T2B1,8 } } Scope (_SB.PCI0) { Scope (BAT0) { Method (FBST, 4, NotSerialized) { And (Arg1, 0xFFFF, Local1) Store (Zero, Local0) If (^^LPCB.EC0.ACAP ()) { Store (One, Local0) } If (Local0) { If (CHGS (Zero)) { Store (0x02, Local0) } Else { Store (Zero, Local0) } } Else { Store (One, Local0) } If (BLLO) { ShiftLeft (One, 0x02, Local2) Or (Local0, Local2, Local0) } If (And (^^LPCB.EC0.EB0S, 0x08)) { ShiftLeft (One, 0x02, Local2) Or (Local0, Local2, Local0) } If (LGreaterEqual (Local1, 0x8000)) { Subtract (0xFFFF, Local1, Local1) } Store (Arg2, Local2) If (LEqual (PUNT, Zero)) { Multiply (Local1, ^^LPCB.EC0.B0DV, Local1) Multiply (Local2, 0x0A, Local2) } And (Local0, 0x02, Local3) If (LNot (Local3)) { Subtract (LFCC, Local2, Local3) Divide (LFCC, 0xC8, Local4, Local5) If (LLess (Local3, Local5)) { Store (LFCC, Local2) } } Else { Divide (LFCC, 0xC8, Local4, Local5) Subtract (LFCC, Local5, Local4) If (LGreater (Local2, Local4)) { Store (Local4, Local2) } } If (LNot (^^LPCB.EC0.ACAP ())) { Divide (Local2, MBLF, Local3, Local4) If (LLess (Local1, Local4)) { Store (Local4, Local1) } } Store (Local0, Index (PBST, Zero)) Store (Local1, Index (PBST, One)) Store (Local2, Index (PBST, 0x02)) Store (Arg3, Index (PBST, 0x03)) } Method (_BIX, 0, NotSerialized) // _BIX: Battery Information Extended { If (LNot (^^LPCB.EC0.BATP (Zero))) { Return (NBIX) } If (LEqual (^^LPCB.EC0.GBTT (Zero), 0xFF)) { Return (NBIX) } _BIF () Store (DerefOf (Index (PBIF, Zero)), Index (BIXT, One)) Store (DerefOf (Index (PBIF, One)), Index (BIXT, 0x02)) Store (DerefOf (Index (PBIF, 0x02)), Index (BIXT, 0x03)) Store (DerefOf (Index (PBIF, 0x03)), Index (BIXT, 0x04)) Store (DerefOf (Index (PBIF, 0x04)), Index (BIXT, 0x05)) Store (DerefOf (Index (PBIF, 0x05)), Index (BIXT, 0x06)) Store (DerefOf (Index (PBIF, 0x06)), Index (BIXT, 0x07)) Store (DerefOf (Index (PBIF, 0x07)), Index (BIXT, 0x0E)) Store (DerefOf (Index (PBIF, 0x08)), Index (BIXT, 0x0F)) Store (DerefOf (Index (PBIF, 0x09)), Index (BIXT, 0x10)) Store (DerefOf (Index (PBIF, 0x0A)), Index (BIXT, 0x11)) Store (DerefOf (Index (PBIF, 0x0B)), Index (BIXT, 0x12)) Store (DerefOf (Index (PBIF, 0x0C)), Index (BIXT, 0x13)) If (LEqual (DerefOf (Index (BIXT, One)), One)) { Store (Zero, Index (BIXT, One)) Store (DerefOf (Index (BIXT, 0x05)), Local0) Multiply (DerefOf (Index (BIXT, 0x02)), Local0, Index (BIXT, 0x02)) Multiply (DerefOf (Index (BIXT, 0x03)), Local0, Index (BIXT, 0x03)) Multiply (DerefOf (Index (BIXT, 0x06)), Local0, Index (BIXT, 0x06)) Multiply (DerefOf (Index (BIXT, 0x07)), Local0, Index (BIXT, 0x07)) Multiply (DerefOf (Index (BIXT, 0x0E)), Local0, Index (BIXT, 0x0E)) Multiply (DerefOf (Index (BIXT, 0x0F)), Local0, Index (BIXT, 0x0F)) Divide (DerefOf (Index (BIXT, 0x02)), 0x03E8, Local0, Index (BIXT, 0x02)) Divide (DerefOf (Index (BIXT, 0x03)), 0x03E8, Local0, Index (BIXT, 0x03)) Divide (DerefOf (Index (BIXT, 0x06)), 0x03E8, Local0, Index (BIXT, 0x06)) Divide (DerefOf (Index (BIXT, 0x07)), 0x03E8, Local0, Index (BIXT, 0x07)) Divide (DerefOf (Index (BIXT, 0x0E)), 0x03E8, Local0, Index (BIXT, 0x0E)) Divide (DerefOf (Index (BIXT, 0x0F)), 0x03E8, Local0, Index (BIXT, 0x0F)) } Store (B1B2(^^LPCB.EC0.XC30,^^LPCB.EC0.XC31), Index (BIXT, 0x08)) Store (0x0001869F, Index (BIXT, 0x09)) Return (BIXT) } } } Scope (_SB.PCI0.LPCB.EC0) { Method (BIFA, 0, NotSerialized) { If (ECAV ()) { If (BSLF) { Store (B1B2(B1S0,B1S1), Local0) } Else { Store (B1B2(B0S0,B0S1), Local0) } } Else { Store (Ones, Local0) } Return (Local0) } Method (SMBR, 3, Serialized) { Store (Package (0x03) { 0x07, Zero, Zero }, Local0) If (LNot (ECAV ())) { Return (Local0) } If (LNotEqual (Arg0, RDBL)) { If (LNotEqual (Arg0, RDWD)) { If (LNotEqual (Arg0, RDBT)) { If (LNotEqual (Arg0, RCBT)) { If (LNotEqual (Arg0, RDQK)) { Return (Local0) } } } } } Acquire (MUEC, 0xFFFF) Store (PRTC, Local1) Store (Zero, Local2) While (LNotEqual (Local1, Zero)) { Stall (0x0A) Increment (Local2) If (LGreater (Local2, 0x03E8)) { Store (SBBY, Index (Local0, Zero)) Store (Zero, Local1) } Else { Store (PRTC, Local1) } } If (LLessEqual (Local2, 0x03E8)) { ShiftLeft (Arg1, One, Local3) Or (Local3, One, Local3) Store (Local3, ADDR) If (LNotEqual (Arg0, RDQK)) { If (LNotEqual (Arg0, RCBT)) { Store (Arg2, CMDB) } } WRBA(Zero) Store (Arg0, PRTC) Store (SWTC (Arg0), Index (Local0, Zero)) If (LEqual (DerefOf (Index (Local0, Zero)), Zero)) { If (LEqual (Arg0, RDBL)) { Store (BCNT, Index (Local0, One)) Store (RDBA(), Index (Local0, 0x02)) } If (LEqual (Arg0, RDWD)) { Store (0x02, Index (Local0, One)) Store (B1B2(T2B0,T2B1), Index (Local0, 0x02)) } If (LEqual (Arg0, RDBT)) { Store (One, Index (Local0, One)) Store (DAT0, Index (Local0, 0x02)) } If (LEqual (Arg0, RCBT)) { Store (One, Index (Local0, One)) Store (DAT0, Index (Local0, 0x02)) } } } Release (MUEC) Return (Local0) } Method (SMBW, 5, Serialized) { Store (Package (0x01) { 0x07 }, Local0) If (LNot (ECAV ())) { Return (Local0) } If (LNotEqual (Arg0, WRBL)) { If (LNotEqual (Arg0, WRWD)) { If (LNotEqual (Arg0, WRBT)) { If (LNotEqual (Arg0, SDBT)) { If (LNotEqual (Arg0, WRQK)) { Return (Local0) } } } } } Acquire (MUEC, 0xFFFF) Store (PRTC, Local1) Store (Zero, Local2) While (LNotEqual (Local1, Zero)) { Stall (0x0A) Increment (Local2) If (LGreater (Local2, 0x03E8)) { Store (SBBY, Index (Local0, Zero)) Store (Zero, Local1) } Else { Store (PRTC, Local1) } } If (LLessEqual (Local2, 0x03E8)) { WRBA(Zero) ShiftLeft (Arg1, One, Local3) Store (Local3, ADDR) If (LNotEqual (Arg0, WRQK)) { If (LNotEqual (Arg0, SDBT)) { Store (Arg2, CMDB) } } If (LEqual (Arg0, WRBL)) { Store (Arg3, BCNT) WRBA(Arg4) } If (LEqual (Arg0, WRWD)) { Store(Arg4,T2B0) Store(ShiftRight(Arg4,8),T2B1) } If (LEqual (Arg0, WRBT)) { Store (Arg4, DAT0) } If (LEqual (Arg0, SDBT)) { Store (Arg4, DAT0) } Store (Arg0, PRTC) Store (SWTC (Arg0), Index (Local0, Zero)) } Release (MUEC) Return (Local0) } Method (ECSB, 7, NotSerialized) { Store (Package (0x05) { 0x11, Zero, Zero, Zero, Buffer (0x20){} }, Local1) If (LGreater (Arg0, One)) { Return (Local1) } If (ECAV ()) { Acquire (MUEC, 0xFFFF) If (LEqual (Arg0, Zero)) { Store (PRTC, Local0) } Else { Store (PRT2, Local0) } Store (Zero, Local2) While (LNotEqual (Local0, Zero)) { Stall (0x0A) Increment (Local2) If (LGreater (Local2, 0x03E8)) { Store (SBBY, Index (Local1, Zero)) Store (Zero, Local0) } ElseIf (LEqual (Arg0, Zero)) { Store (PRTC, Local0) } Else { Store (PRT2, Local0) } } If (LLessEqual (Local2, 0x03E8)) { If (LEqual (Arg0, Zero)) { Store (Arg2, ADDR) Store (Arg3, CMDB) If (LOr (LEqual (Arg1, 0x0A), LEqual (Arg1, 0x0B))) { Store (DerefOf (Index (Arg6, Zero)), BCNT) WRBA(DerefOf (Index (Arg6, One))) } Else { Store (Arg4, DAT0) Store (Arg5, DAT1) } Store (Arg1, PRTC) } Else { Store (Arg2, ADD2) Store (Arg3, CMD2) If (LOr (LEqual (Arg1, 0x0A), LEqual (Arg1, 0x0B))) { Store (DerefOf (Index (Arg6, Zero)), BCN2) WRBB(DerefOf (Index (Arg6, One))) } Else { Store (Arg4, DA20) Store (Arg5, DA21) } Store (Arg1, PRT2) } Store (0x7F, Local0) If (LEqual (Arg0, Zero)) { While (PRTC) { Sleep (One) Decrement (Local0) } } Else { While (PRT2) { Sleep (One) Decrement (Local0) } } If (Local0) { If (LEqual (Arg0, Zero)) { Store (SSTS, Local0) Store (DAT0, Index (Local1, One)) Store (DAT1, Index (Local1, 0x02)) Store (BCNT, Index (Local1, 0x03)) Store (RDBA(), Index (Local1, 0x04)) } Else { Store (SST2, Local0) Store (DA20, Index (Local1, One)) Store (DA21, Index (Local1, 0x02)) Store (BCN2, Index (Local1, 0x03)) Store (RDBB(), Index (Local1, 0x04)) } And (Local0, 0x1F, Local0) If (Local0) { Add (Local0, 0x10, Local0) } Store (Local0, Index (Local1, Zero)) } Else { Store (0x10, Index (Local1, Zero)) } } Release (MUEC) } Return (Local1) } Method (TACH, 1, Serialized) { If (ECAV ()) { Switch (Arg0) { Case (Zero) { Store (B1B2(TH00,TH01), Local0) Break } Case (One) { Store (B1B2(TH10,TH11), Local0) Break } Default { Return (Ones) } } Multiply (Local0, 0x02, Local0) If (LNotEqual (Local0, Zero)) { Divide (0x0041CDB4, Local0, Local1, Local0) Return (Local0) } Else { Return (Ones) } } Else { Return (Ones) } } } Method (B1B2, 2, NotSerialized) { Return (Or (Arg0, ShiftLeft (Arg1, 8))) } Scope (_SB.PCI0.LPCB) { Scope (EC0) { Method (RDBA, 0, Serialized) { Name (TEMP, Buffer(0x20) { }) Store (BA00, Index(TEMP, 0x00)) Store (BA01, Index(TEMP, 0x01)) Store (BA02, Index(TEMP, 0x02)) Store (BA03, Index(TEMP, 0x03)) Store (BA04, Index(TEMP, 0x04)) Store (BA05, Index(TEMP, 0x05)) Store (BA06, Index(TEMP, 0x06)) Store (BA07, Index(TEMP, 0x07)) Store (BA08, Index(TEMP, 0x08)) Store (BA09, Index(TEMP, 0x09)) Store (BA0A, Index(TEMP, 0x0A)) Store (BA0B, Index(TEMP, 0x0B)) Store (BA0C, Index(TEMP, 0x0C)) Store (BA0D, Index(TEMP, 0x0D)) Store (BA0E, Index(TEMP, 0x0E)) Store (BA0F, Index(TEMP, 0x0F)) Store (BA10, Index(TEMP, 0x10)) Store (BA11, Index(TEMP, 0x11)) Store (BA12, Index(TEMP, 0x12)) Store (BA13, Index(TEMP, 0x13)) Store (BA14, Index(TEMP, 0x14)) Store (BA15, Index(TEMP, 0x15)) Store (BA16, Index(TEMP, 0x16)) Store (BA17, Index(TEMP, 0x17)) Store (BA18, Index(TEMP, 0x18)) Store (BA19, Index(TEMP, 0x19)) Store (BA1A, Index(TEMP, 0x1A)) Store (BA1B, Index(TEMP, 0x1B)) Store (BA1C, Index(TEMP, 0x1C)) Store (BA1D, Index(TEMP, 0x1D)) Store (BA1E, Index(TEMP, 0x1E)) Store (BA1F, Index(TEMP, 0x1F)) Return (TEMP) } Method (WRBA, 1, Serialized) { Name (TEMP, Buffer(0x20) { }) Store (Arg0, TEMP) Store (DerefOf(Index(TEMP, 0x00)), BA00) Store (DerefOf(Index(TEMP, 0x01)), BA01) Store (DerefOf(Index(TEMP, 0x02)), BA02) Store (DerefOf(Index(TEMP, 0x03)), BA03) Store (DerefOf(Index(TEMP, 0x04)), BA04) Store (DerefOf(Index(TEMP, 0x05)), BA05) Store (DerefOf(Index(TEMP, 0x06)), BA06) Store (DerefOf(Index(TEMP, 0x07)), BA07) Store (DerefOf(Index(TEMP, 0x08)), BA08) Store (DerefOf(Index(TEMP, 0x09)), BA09) Store (DerefOf(Index(TEMP, 0x0A)), BA0A) Store (DerefOf(Index(TEMP, 0x0B)), BA0B) Store (DerefOf(Index(TEMP, 0x0C)), BA0C) Store (DerefOf(Index(TEMP, 0x0D)), BA0D) Store (DerefOf(Index(TEMP, 0x0E)), BA0E) Store (DerefOf(Index(TEMP, 0x0F)), BA0F) Store (DerefOf(Index(TEMP, 0x10)), BA10) Store (DerefOf(Index(TEMP, 0x11)), BA11) Store (DerefOf(Index(TEMP, 0x12)), BA12) Store (DerefOf(Index(TEMP, 0x13)), BA13) Store (DerefOf(Index(TEMP, 0x14)), BA14) Store (DerefOf(Index(TEMP, 0x15)), BA15) Store (DerefOf(Index(TEMP, 0x16)), BA16) Store (DerefOf(Index(TEMP, 0x17)), BA17) Store (DerefOf(Index(TEMP, 0x18)), BA18) Store (DerefOf(Index(TEMP, 0x19)), BA19) Store (DerefOf(Index(TEMP, 0x1A)), BA1A) Store (DerefOf(Index(TEMP, 0x1B)), BA1B) Store (DerefOf(Index(TEMP, 0x1C)), BA1C) Store (DerefOf(Index(TEMP, 0x1D)), BA1D) Store (DerefOf(Index(TEMP, 0x1E)), BA1E) Store (DerefOf(Index(TEMP, 0x1F)), BA1F) } Method (RDBB, 0, Serialized) { Name (TEMP, Buffer(0x20) { }) Store (BB00, Index(TEMP, 0x00)) Store (BB01, Index(TEMP, 0x01)) Store (BB02, Index(TEMP, 0x02)) Store (BB03, Index(TEMP, 0x03)) Store (BB04, Index(TEMP, 0x04)) Store (BB05, Index(TEMP, 0x05)) Store (BB06, Index(TEMP, 0x06)) Store (BB07, Index(TEMP, 0x07)) Store (BB08, Index(TEMP, 0x08)) Store (BB09, Index(TEMP, 0x09)) Store (BB0A, Index(TEMP, 0x0A)) Store (BB0B, Index(TEMP, 0x0B)) Store (BB0C, Index(TEMP, 0x0C)) Store (BB0D, Index(TEMP, 0x0D)) Store (BB0E, Index(TEMP, 0x0E)) Store (BB0F, Index(TEMP, 0x0F)) Store (BB10, Index(TEMP, 0x10)) Store (BB11, Index(TEMP, 0x11)) Store (BB12, Index(TEMP, 0x12)) Store (BB13, Index(TEMP, 0x13)) Store (BB14, Index(TEMP, 0x14)) Store (BB15, Index(TEMP, 0x15)) Store (BB16, Index(TEMP, 0x16)) Store (BB17, Index(TEMP, 0x17)) Store (BB18, Index(TEMP, 0x18)) Store (BB19, Index(TEMP, 0x19)) Store (BB1A, Index(TEMP, 0x1A)) Store (BB1B, Index(TEMP, 0x1B)) Store (BB1C, Index(TEMP, 0x1C)) Store (BB1D, Index(TEMP, 0x1D)) Store (BB1E, Index(TEMP, 0x1E)) Store (BB1F, Index(TEMP, 0x1F)) Return (TEMP) } Method (WRBB, 1, Serialized) { Name (TEMP, Buffer(0x20) { }) Store (Arg0, TEMP) Store (DerefOf(Index(TEMP, 0x00)), BB00) Store (DerefOf(Index(TEMP, 0x01)), BB01) Store (DerefOf(Index(TEMP, 0x02)), BB02) Store (DerefOf(Index(TEMP, 0x03)), BB03) Store (DerefOf(Index(TEMP, 0x04)), BB04) Store (DerefOf(Index(TEMP, 0x05)), BB05) Store (DerefOf(Index(TEMP, 0x06)), BB06) Store (DerefOf(Index(TEMP, 0x07)), BB07) Store (DerefOf(Index(TEMP, 0x08)), BB08) Store (DerefOf(Index(TEMP, 0x09)), BB09) Store (DerefOf(Index(TEMP, 0x0A)), BB0A) Store (DerefOf(Index(TEMP, 0x0B)), BB0B) Store (DerefOf(Index(TEMP, 0x0C)), BB0C) Store (DerefOf(Index(TEMP, 0x0D)), BB0D) Store (DerefOf(Index(TEMP, 0x0E)), BB0E) Store (DerefOf(Index(TEMP, 0x0F)), BB0F) Store (DerefOf(Index(TEMP, 0x10)), BB10) Store (DerefOf(Index(TEMP, 0x11)), BB11) Store (DerefOf(Index(TEMP, 0x12)), BB12) Store (DerefOf(Index(TEMP, 0x13)), BB13) Store (DerefOf(Index(TEMP, 0x14)), BB14) Store (DerefOf(Index(TEMP, 0x15)), BB15) Store (DerefOf(Index(TEMP, 0x16)), BB16) Store (DerefOf(Index(TEMP, 0x17)), BB17) Store (DerefOf(Index(TEMP, 0x18)), BB18) Store (DerefOf(Index(TEMP, 0x19)), BB19) Store (DerefOf(Index(TEMP, 0x1A)), BB1A) Store (DerefOf(Index(TEMP, 0x1B)), BB1B) Store (DerefOf(Index(TEMP, 0x1C)), BB1C) Store (DerefOf(Index(TEMP, 0x1D)), BB1D) Store (DerefOf(Index(TEMP, 0x1E)), BB1E) Store (DerefOf(Index(TEMP, 0x1F)), BB1F) } } } } //EOF The resulting file can be saved as AML (suggested name: SSDT-BATT.aml), and placed in ACPI/patched. But you can’t expect battery status to work with native DSDT yet! Renaming existing methodsFor now, there are duplicate methods in DSDT and this SSDT-BATT.aml. For each method in DSDT that the SSDT-BATT.aml version will replace, we must rename the method in DSDT to something else, which will allow the SSDT version to override. Just as in post #1, this part follows the “Rename/Replace” pattern.The methods that need replacements are FBST, _BIX, BIFA, SMBR, SMBW, ECSB, and TACH. For this step, it is useful to create a mixed bytecode listing for the native DSDT.aml.It can be created with: “iasl -l -dl DSDT.aml”, which creates a mixed listing in DSDT.dsl For the FBST method: Method (FBST, 4, NotSerialized) { And (Arg1, 0xFFFF, Local1) Store (Zero, Local0) FF74: 14 43 12 46 42 53 54 04 7B 69 0B FF FF 61 70 00 // .C.FBST.{i...ap. FF84: 60 A potential rename patch (FBST-&gt;XBST): 12Find: &lt;46 42 53 54 04&gt;Replace: &lt;58 42 53 54 04&gt; It is a good idea to verify that there is only one match for the Find hex data by searching for it in a hex editor such as Hex Fiend. Because the patch should ONLY apply to the method definition, not other code that may be present in the DSDT (or native SSDTs). The target name you choose must be unique within the scope that the method resides. Creating a duplicate method will cause kernel panic. Changing the first letter to ‘X’ is usually ok, but no guarantee. Patches for the rest of the methods: 123_BIX-&gt;XBIX:Find: &lt;5F 42 49 58 00&gt;Replace: &lt;58 42 49 58 00&gt; 123BIFA-&gt;XIFA:Find: &lt;42 49 46 41 00&gt;Replace: &lt;58 49 46 41 00&gt; 123SMBR-&gt;XMBR:Find: &lt;53 4D 42 52 0B&gt;Replace: &lt;58 4D 42 52 0B&gt; 123SMBW-&gt;XMBW:Find: &lt;53 4D 42 57 0D&gt;Replace: &lt;58 4D 42 57 0D&gt; 123ECSB-&gt;XCSB:Find: &lt;45 43 53 42 07&gt;Replace: &lt;58 43 53 42 07&gt; 123TACH-&gt;XACH:Find: &lt;54 41 43 48 09&gt;Replace: &lt;58 41 43 48 09&gt; After adding those patches to config.plist/ACPI/DSDT/Patches, the methods in native DSDT will be renamed by Clover. And as a result of the renaming, the patched methods defined in SSDT-BATT.aml will override. ConclusionHotpatching for battery status is one of the most complex hotpatch tasks possible. The process of writing all the ‘External’ refernences is tedious and boring. It will take some time (several hours into the text you’re reading here). Do not rush it. Disabling discrete/switched GPU with HotpatchThis third post is dedicated to hotpatching required for disabling the discrete GPU in a switched dual-GPU laptop, using the same example ACPI fils as the static patch guide. https://www.tonymacx86.com/threads/guide-disabling-discrete-graphics-in-dual-gpu-laptops.163772/ You should download the ACPI/origin files that are attached to that guide, so you can follow along. As in the static patch guide, the goal is relatively simple: call the _OFF method (from an _INI method) for the discrete GPU during ACPI initialization. But the details make it more complex due to the fact that _OFF can contain EC related code which needs to be executed in _REG instead of _INI. Building the replacement _INI/_OFF/_REG methodsIn the example, the target _INI method is in SSDT-7, _OFF is in SSDT-8. The path of the discrete device is _SB.PCI0.RP05.PEGP. In the example files, _OFF contains EC related code that must be moved to _REG. To complete this patching process, we need to replace _INI, _OFF, and _REG, therefore each will need to be renamed to XINI, XOFF, and XREG Note: The methods you need to patch may in fact be different. It all depends on the code within the _OFF path. For example, with other ACPI sets, it happens that SGOF (may be some other name) has EC related code that must be moved to _REG. In that case, you would need to use rename/replace for the SGOF, and perhaps not the _OFF method. Analyze your existing code carefully. The Clover config.plist patches will be worked out later. For now, lets look at the SSDT for the replacement methods. The SSDT will consist of the patched methods: DefinitionBlock(&quot;&quot;, &quot;SSDT&quot;, 2, &quot;hack&quot;, &quot;D-GPU&quot;, 0) { External(_SB.PCI0.RP05.PEGP, DeviceObj) External(_SB.PCI0.RP05.PEGP.XINI, MethodObj) External(_SB.PCI0.RP05.PEGP.XOFF, MethodObj) External(_SB.PCI0.RP05.PEGP.XINI, MethodObj) External(_SB.PCI0.LPCB.EC0, DeviceObj) External(_SB.PCI0.LPCB.EC0.XREG, MethodObj) External(_SB.PCI0.LPCB.EC0.SPIN, MethodObj) Scope(_SB.PCI0.RP05.PEGP) { Method(_INI) { XINI() // call original _INI, now renamed XINI _OFF() // call (patched) _OFF } Method(_OFF, 0, Serialized) { If (LEqual (CTXT, Zero)) { /* \_SB.PCI0.LPCB.EC0.SPIN (0x96, Zero) */ If (LNotEqual (GPRF, One)) { Store (VGAR, VGAB) } Store (One, CTXT) } SGOF () } } Scope(_SB.PCI0.LPCB.EC0) { Method(_REG, 2) { XREG(Arg0, Arg1) // call original _REG, now renamed XREG If (3 == Arg0 &amp;&amp; 1 == Arg1) // EC ready? { \_SB.PCI0.LPCB.EC0.SPIN (0x96, Zero) // code that was removed from _OFF } } } At this point, the code won’t compile, as some of the symbols referenced in _OFF are not available.Just like the battery patching guide, we must add the appropriate External declarations. Use the compiler errors to determine which symbols you need to find, then add the appropriate External declartions. In the example case: External(_SB.PCI0.RP05.PEGP.CTXT, IntObj) External(_SB.PCI0.RP05.PEGP.GPRF, IntObj) External(_SB.PCI0.RP05.PEGP.VGAR, FieldUnitObj) External(_SB.PCI0.RP05.PEGP.VGAB, BuffObj) External(_SB.PCI0.RP05.PEGP.SGOF, MethodObj) The resulting SSDT: DefinitionBlock(&quot;&quot;, &quot;SSDT&quot;, 2, &quot;hack&quot;, &quot;D-GPU&quot;, 0) { External(_SB.PCI0.RP05.PEGP, DeviceObj) External(_SB.PCI0.RP05.PEGP.XINI, MethodObj) External(_SB.PCI0.RP05.PEGP.XOFF, MethodObj) External(_SB.PCI0.RP05.PEGP.XINI, MethodObj) External(_SB.PCI0.LPCB.EC0, DeviceObj) External(_SB.PCI0.LPCB.EC0.XREG, MethodObj) External(_SB.PCI0.LPCB.EC0.SPIN, MethodObj) External(_SB.PCI0.RP05.PEGP.CTXT, IntObj) External(_SB.PCI0.RP05.PEGP.GPRF, IntObj) External(_SB.PCI0.RP05.PEGP.VGAR, FieldUnitObj) External(_SB.PCI0.RP05.PEGP.VGAB, BuffObj) External(_SB.PCI0.RP05.PEGP.SGOF, MethodObj) Scope(_SB.PCI0.RP05.PEGP) { Method(_INI) { XINI() // call original _INI, now renamed XINI _OFF() // call (patched) _OFF } Method(_OFF, 0, Serialized) { If (LEqual (CTXT, Zero)) { /* \_SB.PCI0.LPCB.EC0.SPIN (0x96, Zero) */ If (LNotEqual (GPRF, One)) { Store (VGAR, VGAB) } Store (One, CTXT) } SGOF () } } Scope(_SB.PCI0.LPCB.EC0) { Method(_REG, 2) { XREG(Arg0, Arg1) // call original _REG, now renamed XREG If (3 == Arg0 &amp;&amp; 1 == Arg1) // EC ready? { \_SB.PCI0.LPCB.EC0.SPIN (0x96, Zero) // code that was removed from _OFF } } } } Now it compiles without error, but there is one warning: “39, 3079, _REG has no corresponding Operation Region”. And this warning is important. The _REG will not be called unless we add a dummy EC OperationRegion. We can add it: ... Scope(_SB.PCI0.LPCB.EC0) { OperationRegion(RME3, EmbeddedControl, 0x00, 0xFF) Method(_REG, 2) { ... Resulting complete SSDT: External(_SB.PCI0.RP05.PEGP, DeviceObj) External(_SB.PCI0.RP05.PEGP.XINI, MethodObj) External(_SB.PCI0.RP05.PEGP.XOFF, MethodObj) External(_SB.PCI0.RP05.PEGP.XINI, MethodObj) External(_SB.PCI0.LPCB.EC0, DeviceObj) External(_SB.PCI0.LPCB.EC0.XREG, MethodObj) External(_SB.PCI0.LPCB.EC0.SPIN, MethodObj) External(_SB.PCI0.RP05.PEGP.CTXT, IntObj) External(_SB.PCI0.RP05.PEGP.GPRF, IntObj) External(_SB.PCI0.RP05.PEGP.VGAR, FieldUnitObj) External(_SB.PCI0.RP05.PEGP.VGAB, BuffObj) External(_SB.PCI0.RP05.PEGP.SGOF, MethodObj) Scope(_SB.PCI0.RP05.PEGP) { Method(_INI) { XINI() // call original _INI, now renamed XINI _OFF() // call (patched) _OFF } Method(_OFF, 0, Serialized) { If (LEqual (CTXT, Zero)) { /* \_SB.PCI0.LPCB.EC0.SPIN (0x96, Zero) */ If (LNotEqual (GPRF, One)) { Store (VGAR, VGAB) } Store (One, CTXT) } SGOF () } } Scope(_SB.PCI0.LPCB.EC0) { OperationRegion(RME3, EmbeddedControl, 0x00, 0xFF) Method(_REG, 2) { XREG(Arg0, Arg1) // call original _REG, now renamed XREG If (3 == Arg0 &amp;&amp; 1 == Arg1) // EC ready? { \_SB.PCI0.LPCB.EC0.SPIN (0x96, Zero) // code that was removed from _OFF } } } At this point, you can save the SSDT (suggestion: SSDT-DGPU.aml).It is ready to go to ACPI/patched. But we still need to rename the original methods in native ACPI. Renaming the methodsAs mentioned earlier, the following methods need renaming:_SB.PCI0.RP05.PEGP._INI -&gt; XINI_SB.PCI0.RP05.PEGP._OFF -&gt; XOFF_SB.PCI0.LPCB.EC0._REG -&gt; XREG To determine the binary patches needed, we need a mixed listing of DSDT.aml, SSDT-7.aml, and SSDT-8.aml.Create with: 1iasl -dl -l DSDT.aml SSDT-7.aml SSDT-8.aml The resulting mixed listing is in DSDT.dsl, SSDT-7.dsl, and SSDT-8.dsl. Here is the mixed listing for _REG in DSDT.dsl:Code (Text): Method (_REG, 2, NotSerialized) // _REG: Region Availability { D2B8: 14 12 5F 52 45 47 02 // .._REG. If (LEqual (Arg0, 0x03)) { D2BF: A0 0B 93 68 0A 03 // ...h.. Store (Arg1, ECFL) } } } } D2C5: 70 69 45 43 46 4C The patch used should rename only this _REG, not other _REG methods in the ACPI set. We can rename it by grabbing the name/header plus a few bytes from the code. This pattern grabs enough bytes to be unique for sure: 12Find: &lt;5F 52 45 47 02 A0 0B 93 68 0A 03 70 69 45 43 46 4C&gt;Replace: &lt;58 52 45 47 02 A0 0B 93 68 0A 03 70 69 45 43 46 4C&gt; And the mixed listing for the target _INI in SSDT-7.dsl: Method (_INI, 0, NotSerialized) // _INI: Initialize { 03D1: 14 1F 5F 49 4E 49 00 // .._INI. Store (Zero, \_SB.PCI0.RP05.PEGP._ADR) } 03D8: 70 00 5C 2F 05 5F 53 42 5F 50 43 49 30 52 50 30 // p.\/._SB_PCI0RP0 03E8: 35 50 45 47 50 5F 41 44 52 // 5PEGP_ADR ​ Resulting patch… 12Find: &lt;5F 49 4E 49 00 70 00 5C 2F 05 5F 53 42 5F 50 43 49 30 52 50 30 35 50 45 47 50&gt;Replace: &lt;58 49 4E 49 00 70 00 5C 2F 05 5F 53 42 5F 50 43 49 30 52 50 30 35 50 45 47 50&gt; And the _OFF in SSDT-8.dsl: Method (_OFF, 0, Serialized) // _OFF: Power Off { 032B: 14 45 04 5F 4F 46 46 08 // .E._OFF. If (LEqual (CTXT, Zero)) { \_SB.PCI0.LPCB.EC0.SPIN (0x96, Zero) 0333: A0 39 93 43 54 58 54 00 5C 2F 05 5F 53 42 5F 50 // .9.CTXT.\/._SB_P 0343: 43 49 30 4C 50 43 42 45 43 30 5F 53 50 49 4E 0A // CI0LPCBEC0_SPIN. 0353: 96 00 The patch… 12Find: &lt;5F 4F 46 46 08 A0 39 93 43 54 58 54&gt;Replace: &lt;58 4F 46 46 08 A0 39 93 43 54 58 54&gt; Note: Each of these patches could probably be reduced, but you would need to check carefully in all native DSDT and SSDTs for the Find pattern as you don’t want to match on any methods but the target methods. Because _REG, _INI and _OFF are very common names for methods in other scopes, we need to be careful. A simple exampleThe files for the ASUS mentioned above were complex due to the need to patch _OFF, _INI, and _REG. But let’s take a look at an example that is much simpler. The files are for an Asus K550VX-DM406T, and they are attached to this post. Please download them so you can follow along. When we look at the _OFF method in SSDT-14, there is no EC related code. And it calls PGOF, but the PGOF method, defined in SSDT-3, also has no EC related code: Method (_OFF, 0, Serialized) // _OFF: Power Off { If (LEqual (CTXT, Zero)) { If (LNotEqual (GPRF, One)) { Store (VGAR, VGAB) } Store (One, CTXT) } PGOF (Zero) } This means _OFF can be called directly from an _INI. If you look at all the _INI methods in the ACPI set, you will find there is no _INI at the path of _OFF (_SB.PCI0.PEG0.PEGP). Which means we can simply add an SSDT that has an _INI at the correct path, and that _INI simply calls _OFF. It is a one-liner method: 12345DefinitionBlock(&quot;&quot;, &quot;SSDT&quot;, 2, &quot;hack&quot;, &quot;DGPU&quot;, 0)&#123; External(_SB.PCI0.PEG0.PEGP._OFF, MethodObj) Method(_SB.PCI0.PEG0.PEGP._INI) &#123; _OFF() &#125;&#125; Just as mentioned in the main discrete disable guide (static patch), sometimes you need to call _PS3 instead of _OFF. It is a trial and error process to determine which is best. Same code as above, but calling _PS3: 12345DefinitionBlock(&quot;&quot;, &quot;SSDT&quot;, 2, &quot;hack&quot;, &quot;DGPU&quot;, 0)&#123; External(_SB.PCI0.PEG0.PEGP._PS3, MethodObj) Method(_SB.PCI0.PEG0.PEGP._INI) &#123; _PS3() &#125;&#125; Save it as SSDT-DGPU.aml and the Nvidia should be disabled. The simple example turned not so simple Although the method mentioned above will usually work in this scenario (even with other laptops that present the same scenario: no EC access in _OFF path, no existing _INI at the path), this specific laptop needed additional patching in order to turn off the dedicated Nvidia fan. A little investigation was needed. As we can see by looking at the _OFF code, it calls PGOF(Zero) to do most of the work. And if we search for other examples of PGOF being called with Arg0==Zero, we find this code in SSDT-3.dsl: ElseIf (LAnd (LGreater (OSYS, 0x07D9), PEGS ())) { FAOF () PGOF (Zero) ... Note the call to FAOF. Could that be for “FAN OFF”? Seems likely. And look, we have FAOF and FAON in SSDT-3: Method (FAON, 0, Serialized) { \_SB.PCI0.LPCB.EC0.WRAM (0x052B, 0x9E) \_SB.PCI0.LPCB.EC0.WRAM (0x0520, 0x8B) Store (\_SB.PCI0.LPCB.EC0.RRAM (0x0521), Local0) And (Local0, 0xCF, Local0) Or (Local0, 0x20, Local0) \_SB.PCI0.LPCB.EC0.WRAM (0x0521, Local0) } Method (FAOF, 0, Serialized) { Store (\_SB.PCI0.LPCB.EC0.RRAM (0x0521), Local0) And (Local0, 0xCF, Local0) \_SB.PCI0.LPCB.EC0.WRAM (0x0521, Local0) \_SB.PCI0.LPCB.EC0.WRAM (0x0520, 0x89) \_SB.PCI0.LPCB.EC0.WRAM (0x03A4, Zero) \_SB.PCI0.LPCB.EC0.WRAM (0x03A5, Zero) } And you can see it does a bunch of EC manipulations. Typically the EC controls the system fans, so this seems to confirm these methods are for “FAN ON”, and “FAN OFF”. Since these methods manipulate the EC, we cannot call FAOF without the EC being ready. To do that, we need to patch _REG. So, adding the necessary code to our SSDT: 1234567891011121314151617181920DefinitionBlock(&quot;&quot;, &quot;SSDT&quot;, 2, &quot;hack&quot;, &quot;DGPU&quot;, 0)&#123; External(_SB.PCI0.PEG0.PEGP._OFF, MethodObj) Method(_SB.PCI0.PEG0.PEGP._INI) &#123; _OFF() &#125; External(_SB.PCI0.LPCB.EC0, DeviceObj) External(_SB.PCI0.LPCB.EC0.XREG, MethodObj) External(_SB.PCI0.PEG0.FAOF, MethodObj) Scope(_SB.PCI0.LPCB.EC0) &#123; OperationRegion(RME3, EmbeddedControl, 0x00, 0xFF) Method(_REG, 2) &#123; XREG(Arg0, Arg1) // call original _REG, now renamed XREG If (3 == Arg0 &amp;&amp; 1 == Arg1) // EC ready? &#123; \_SB.PCI0.PEG0.FAOF() // turn dedicated Nvidia fan off &#125; &#125; &#125;&#125; And the patch we need to rename _REG to XREG (again, based on a mixed listing of DSDT.aml): 12Find: &lt;5F 52 45 47 02 A0 0B 93 68 0A 03&gt;Replace: &lt;58 52 45 47 02 A0 0B 93 68 0A 03&gt; With the patch in config.plist, EC0._REG is renamed XREG. The eventual call to _REG by the system lands in our modified _REG, which, in turn, calls the original _REG (renamed to XREG) and calls FAOF to turn the fan off. ConclusionHotpatching discrete GPU disable code is a bit simpler than battery status, but involves similar concepts. Creditshttps://github.com/RehabMan/OS-X-Clover-Laptop-Confighttps://www.tonymacx86.com/threads/guide-using-clover-to-hotpatch-acpi.200137/]]></content>
      <categories>
        <category>Hackintosh</category>
      </categories>
      <tags>
        <tag>Hacintosh</tag>
        <tag>SSDT</tag>
        <tag>hotpatch</tag>
        <tag>ACPI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HP OMEN by HP Laptop]]></title>
    <url>%2FHP-OMEN-by-HP-Laptop.html</url>
    <content type="text"><![CDATA[Laptop Configuration123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159----------------------------------以下信息由电脑管家提供导出时间：2017-12-13 19:6:32----------------------------------电脑概览电脑型号 HP OMEN by HP Laptop操作系统 Microsoft Windows 10 家庭中文版 (64位)CPU (英特尔)Intel(R) Core(TM) i5-6300HQ CPU @ 2.30GHz(2304 MHz)主板 HP 8257内存 8.00 GB ( 2133 MHz)主硬盘 130 GB ( S2HUNX0H463693 已使用时间: 3745小时)显卡 NVIDIA GeForce GTX 960M显示器 (Standard monitor types) 32位真彩色 60Hz声卡 Realtek High Definition Audio网卡 Intel(R) Dual Band Wireless-AC 7265----------------------------------------------------------------------------------------------------------------------------CPU详情CPU厂商 GenuineIntelCPU (英特尔)Intel(R) Core(TM) i5-6300HQ CPU @ 2.30GHzCPU核心数 4CPU默认频率 2304 MHzCPU外频 100 MHzCPU当前频率 2304 MHz二级缓存 1024 KB三级缓存 6144 KBCPU电压 0.800 VCPU序列号 BFEBFBFF000506E3数据宽度 64bit指令集 MMX,SSE,SSE2,SSE3,SSSE3,SSE4.1,SSE4.2,EM64T扩展版本 Ext.Family 0 Ext.Model 5----------------------------------------------------------------------------------------------------------------------------主板详情制造商 HP主板型号 8257制造日期 2016/07/04主板序列号 5CD62862N1BIOS厂商 InsydeBIOS版本 HPQOEM - 0 F.08BIOS大小 0 Bytes芯片组 英特尔 电脑厂商 HP电脑型号 OMEN by HP Laptop系统安装日期 2017/04/14最近启动时间 2017/11/13----------------------------------------------------------------------------------------------------------------------------内存1详情内存名称 2133 MHz内存大小 4 GB内存频率 2133 MHz插槽 Bottom-Slot 1(left) 数据宽度 64bit内存2详情内存名称 2133 MHz内存大小 4 GB内存频率 2133 MHz插槽 Bottom-Slot 2(right)数据宽度 64bit----------------------------------------------------------------------------------------------------------------------------显卡1详情显卡名称 Intel(R) HD Graphics 530显存大小 1024 MB内核名称 Intel(R) HD Graphics Family显卡2详情显卡名称 NVIDIA GeForce GTX 960M显存大小 2048 MB内核名称 GeForce GTX 960M----------------------------------------------------------------------------------------------------------------------------显示器详情显示器厂商 (Standard monitor types)显示器代号 LGD0532屏幕尺寸 15.3 英寸 (34厘米X19厘米)屏幕比例 16:9当前分辨率 1920 * 1080 (32位真彩色@60Hz)最大分辨率 1920 * 1080制造时间 2016/1----------------------------------------------------------------------------------------------------------------------------硬盘1详情硬盘名称 SAMSUNG MZNLF128HCHP-000H1硬盘大小 130 GB硬盘已使用时间 3745小时 (S.M.A.R.T.)硬盘序列号 SAMSUNG MZNLF128HCHP-000H1 (BIOS 版本: FXT21H)硬盘2详情硬盘名称 HGST HTS721010A9E630硬盘大小 1000 GB硬盘缓存 32 MB硬盘已使用时间 3743小时 (S.M.A.R.T.)硬盘序列号 HGST HTS721010A9E630 (BIOS 版本: JB0OA3)----------------------------------------------------------------------------------------------------------------------------声卡1详情声卡名称 Realtek High Definition Audio声卡厂商 Realtek声卡2详情声卡名称 英特尔(R) 显示器音频声卡厂商 Intel(R) Corporation----------------------------------------------------------------------------------------------------------------------------网卡1详情网卡名称 Intel(R) Dual Band Wireless-AC 7265网卡厂商 Intel CorporationMac地址 A4:02:B9:44:77:AD网卡2详情网卡名称 Realtek PCIe GBE Family Controller网卡厂商 RealtekMac地址 EC:8E:B5:4E:C7:F8----------------------------------------------------------------------------------------------------------------------------键盘详情名称 增强型(101 或 102 键)类型 USB Input Device----------------------------------------------------------------------------------------------------------------------------其它硬件1详情名称 USB Input Device其它硬件2详情名称 USB Composite Device其它硬件3详情名称 英特尔(R) 无线 Bluetooth(R)---------------------------------------------------------------------------------------------------------------------------- WorkingClover EFI bootloaderHP OMEN by HP Laptop FinallyPlease respect the author’s work and please indicate the address of the original post if you want reprint the repo!]]></content>
      <categories>
        <category>Hackintosh</category>
      </categories>
      <tags>
        <tag>Hacintosh</tag>
        <tag>光影精灵</tag>
        <tag>暗影精灵</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ASUS-X455LD-i5-4210u]]></title>
    <url>%2FASUS-X455LD-i5-4210u.html</url>
    <content type="text"><![CDATA[Laptop Configuration123456789101112131415161718Computer model Asus F455LD NotebookCPU Intel Core i5-4210uOperate System Windows10 Education 64bit + macOS High Sierra 17B25c + Windows7 Ultimate + ElementaryOS base on Ubuntu 16.04Main board Asus X455LD Intel Haswell-ULT - Lynx Point-LPDiscret egraphics Nvidia GeForce 820M 2G Integrated graphics HD4400Audio Realtek @ Intel Lynx Point-LP High Definition Audio (CX20751)Ethernet Realtek RTL8168/8111/8112 Gigabit Ethernet Controller / AsusWireless network adapter Atheros AR956X Working NotesAbout ALCPlugFixFirstly，Unzip ALCPlugFix to your desktop after you have installed Hackintosh。Secondly，open terminal：123$ cd ~/Desktop/ALCPlugFix/alc_fix$ chmod +x install.sh$ ./install.sh The script can fix your audio with good input and switch。 About 一键开启HIDPI并注入EDID Just double click 双击.command，and input your password。 Then it can working as Macintosh。 Clover EFI bootloaderASUS-F455LD-i5-4210u FinallyPlease respect the author’s work and please indicate the address of the original post if you want reprint the repo!]]></content>
      <categories>
        <category>Hackintosh</category>
      </categories>
      <tags>
        <tag>Hacintosh</tag>
        <tag>X455LD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Solve problem of subset sum with backtracking method]]></title>
    <url>%2FSolve-problem-of-subset-sum-with-backtracking-method.html</url>
    <content type="text"><![CDATA[问题描述子集和问题的一个实例为&lt;S,t&gt;。其中，S={x1,x2,x3,&hellip;,xn}是一个正整数的集合，c是一个正整数。子集和问题判定是否存在S的一个子集S1，使得 S1中的所有元素之和等于c。试设计一个解子集和问题的回溯法。 输入第1行有2个正整数n和c，n表示S的大小，c是子集和的目标值。接下来的1行中，有n个正整数，表示集合S中的元素。 输出输出子集和问题的解。当问题无解时，输出No solution!。 样例输入125 102 2 6 5 4 样例输出12 2 6 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;#define n 5#define c 10int array[n]=&#123;2,2,6,5,4&#125;;int a[n]=&#123;0&#125;;int sum=0;int flag=0;void traceback(int t)&#123; if(t==n)&#123; if(sum==c)&#123; flag=1; for(int i=0;i&lt;n;i++)&#123; if(a[i])&#123; printf(&quot;%3d&quot;,array[i]); &#125; &#125; printf(&quot;\n&quot;); return; &#125; &#125; else&#123; sum+=array[t]; a[t]=1; traceback(t+1); a[t]=0; sum-=array[t]; traceback(t+1); &#125;&#125;int main()&#123; traceback(0); if(!flag)&#123; printf(&quot;No Solutions!\n&quot;); &#125; return 0;&#125; 结果输出]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>子集和问题</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Install macOS on laptop]]></title>
    <url>%2FInstall-macOS-on-laptop.html</url>
    <content type="text"><![CDATA[前言Clover支持两种启动方式，启动过程如下： 基于BIOS的电脑（老式主板）BIOS -&gt; MBR -&gt; PBR -&gt; boot -&gt; CLOVERX64.efi -&gt; OSLoader 基于UEFI的电脑（新式主板）UEFI -&gt; CLOVERX64.efi -&gt; OSLoader 对于支持UEFI的机器，我们通常用CLOVER引导原版安装，这种方式最大的优点就是有恢复分区可以正常升级，当然前提要把引导做好。 前期知识储备CLOVER的目录结构CLOVER正常工作需要的完整目录包括config.plist、CLOVERX64.efi两个文件以及ACPI、drivers64UEFI、kexts、和themes几个目录，如图所示： 其中，config.plist是最核心的文件—-配置文件，CLOVER所实现的多数功能都是通过这个文件进行配置的，对其进行配置修改的最好用的工具就是Clover Configurator，主页面如下： 详细的配置方法下面会有介绍。 另外一个文件是CLOVERX64.efi，这个文件用以启动CLOVER引导，通过EasyUEFI或者BIOS对启动项进行添加操作时，就是指向的这个文件。 ACPI是用以存放机器ACPI表单的，全称是”高级配置和电源管理接口”(Advanced Configuration and Power Interface)，其子目录由origin、patched、WINDOWS构成，其中origin用以保存通过在CLOVER引导界面按F4或Fn F4提取的原始表单，此目录的所有表文件是不加载的，需要对其进行编译得到.dsl文件，然后对其进行修改拍错，最后保存成.aml文件保存至patched目录才会在启动时加载，而WINDOWS目录则可以忽略不计。在黑果中，我们用到的表单文件只有SSDT和DSDT，其中DSDT主要是对各种设备的描述，而SSDT则主要是用以实现某个功能。 drivers64UEFI是由各种EFI驱动组成，在笔记本黑果需要用到的有FSInject-64.efi、HFSPlus-64.efi、OsxAptioFixDrv-64.efi、APFS.efi以及OsxFatBinaryDrv-64.efi，在新版CLOVER中只需要FSInject-64.efi、HFSPlus-64.efi、OsxAptioFixDrv-64.efi、以及APFS.efi kexts主要用于存储各种驱动(OS X称为内核扩展) themes用以存储CLOVER引导界面的主题 根据机器配置定制kextkext在EFI的配置中是相当重要的，好的kext配置可以弥补config的不足，不好的kext配置也会让本应完美的config发挥不出作用。 FakeSMC.kext:FakeSMC是现今的⿊黑苹果过程中唯⼀一的”必要性”内核扩展程序。对于⿊黑苹果有着⽆与伦比的重要性，但是很多⼈并不知道FakeSMC为什么重要，只是知道必须有它才⾏行，。简⽽而⾔言之就是: FakeSMC是⽤用于将PC主板上的各种控制芯⽚片伪装成Mac独有的硬件控制芯片SMC以骗过系统从⽽而是系统正常启动的⼀一个内核扩展(其实很复杂,这⾥里不多说了)。在系统启动的阶段，FakeSMC负责告知系统有关主板上SMC芯⽚片(伪装出来的)的各种加密信息，欺骗系统。也就是说呢，无论你笔记本是什么配置，此驱动是必须的。 ApplePS2SmartTouchPad.kext、VoodooI2C.kext和VoodooPS2Controller.kext:此驱动用以驱动键盘鼠标以及触摸板，两者选择一个即可，两者区别就是适用的类型不一样，有PS/2、Synaptics、alps、i2c等等，其中Synaptics、alps用ApplePS2SmartTouchPad.kext适配性好一些，VoodooI2C.kext比较麻烦，仅适用于i2c触摸板。具体怎么确定走的总线类型，大家参考百度就好了，这里就不再赘述。 FakePCIID.kext:这个kext的目的是与IOPCIDevice设备建立连接，以便当另一个驱动程序连接到同一设备时，它可以提供备用的PCI ID。也就是说，如果用到Fake-PCI-ID中的其他任何kext的话，此驱动都是必要的。 FakePCIID_Intel_HD_Graphics.kext:此驱动主要用于核显HD4200 HD4400 HD4600 P4600、Iris 540 Iris 550 Iris Pro 580、HD510 HD515 HD520 HD530 P530（多数530不需要这个）、P4000、P6300 - 162a、UHD620 KabyLake-R、UHD630 CoffeeLake。 FakePCIID_Intel_HDMI_Audio.kext:其目的是为不支持的HDAU提供支持(通常称为B0D3，但需要将其重命名为HDAU，以满足Apple的期望值)在Haswell以上的系统中提供HDMI-audio的设备。 FakePCIID_BCM57XX_as_BCM57765.kext:这个kext将与众多不受支持的BCM57XX以太网设备建立连接，以使本机驱动程序为兼容的更广泛的BCM以太网芯片组工作。 FakePCIID_Intel_GbX.kext:这个kext将与一些Intel以太网设备建立连接，以使基于Intel芯片组的驱动程序工作。 FakePCIID_XHCIMux.kext:将会连接到8086:1e31, 8086:9c31, 8086:9cb1, 8086:9c31, 8086:8cb1这个注入器是正常的FakePCIID任务的一部分。它实际上并没有伪造任何PCI id。相反，它将某些值强加于Intel XHCI USB3控制器上的XUSB2PR (PCI配置偏移0xD0)。其效果是将任何USB2设备与XHC端口上的USB2引脚连接到EHC1。换句话说，使用USB2驱动而不是USB3驱动程序(AppleUSBEHCI vs AppleUSBXHCI)处理USB2设备。 FakePCIID_AR9280_as_AR946x:这是FakePCIID.kext的特殊应用，是在一个AR9280被重新命名为其他设备的情况下使用的。例如，在联想u430中，将一个AR9280作为AR946x重新命名是很有用的，因为该设备可以被BIOS白名单所允许，而AR9280不是。通过使用FakePCIID，我们可以将PCI id重新映射回AR9280 (168c:002a)，即使该设备本身报告的是168c:0034。 FakePCIID_Broadcom_WiFi.kext:这个kext将连接到14e4:43b1, 14e4:4357, 14e4:4331, 14e4:4353, 14e4:432b, 14e4 . 432b, 14e4:43a3，或14e4:43a0。以及106b:4e, 14e4:4312, 14e4:4313, 14e4:4318, 14e4:431a, 14e4:4320, 14e4:4324, 14e4:4324, 14e4:4328, 14e4:432d。最初是为BCM94352Z创建的，这个特殊的FakePCIID应用程序。在使用多种支持的Broadcom WiFi设备时，kext被用来模拟真正的Apple Airport(苹果无线网卡)。 ACPIBatteryManager.kext:用以使笔记本正确显示电量，但通常需要配合DSDT的patch才能发挥作用。 VoodooHDA.kext:万能声卡驱动，用以禁用AppleHDA来驱动声卡。 AppleALC.kext:通过对AppleHDA的动态patch实现对AppleHDA的完整加载。 Lilu.kext:一个开放源码的内核扩展，为macOS系统提供了一个任意的kext、库和程序补丁的平台。 IntelGraphicsDVMTFixup.kext:修复因BIOS显存分配不足造成的KP。建议broadwell+平台使用。 IntelGraphicsFixup.kext:动态修复核显的各种问题(例如腾讯视频死机，开机二阶段花屏等)，建议Haswell+平台使用。 CoreDisplayFixup.kext:为不受支持的4K机器(非Iris)开启高分辨率支持。 AzulPatcher4600.kext:针对HD4600的额外修复，仅推荐HD4600使用。 HibernationFixup.kext:修复睡眠，以支持某些机器在3和28休眠模式下的正常休眠。 NvidiaGraphicsFixup.kext:修复某些n卡的黑屏。 WhateverGreen.kext:用以驱动A卡。 RealtekRTL8111.kext:用以驱动RealtekRTL8111.kext以太网卡设备。 AppleIGB.kext、IntelMausiEthernet.kext:用以驱动Intel板载网卡设备。 根据机器配置定制configClover 可以根据硬件进行自动配置，但是自动配置组件并不总是完美的。这也是保留用户可以自定义配置的原因。用户可以修改配置文件config.plist中的配置参数，或者基于GUI的配置界面进行修改配置。配置文件是基于XML的，可以以文本文件来处理。它可以用纯文本编辑器进行编辑，也可以用plist编辑器进行编辑，如PlistEdit。配置文件 (config.plist) 必须放在EFI/CLOVER目录下。 这里遵循一个原则，尽可能简单的设置config，不知道具体作用的就让他空着好了，如果你不知道参数的需求值是什么，就从配置文件中排除！不要用没有值的参数。 正所谓前人种树，后人乘凉，很多黑果的热心朋友已经为我们做好了教程，这里我直接拿来用了。 ACPI BOOT CPU Device Disable Drivers GUI Graphics Kernel and Kext Patches Rt Variables SMBIOS System Parameters 不敢下手的没关系，我给一个最简单的模板，全按这个来就足可以装上最常见的。 敢下手了，没有Mac环境？没关系，送你们在线编辑器，点这里传送门。里面目前加入了一些常见的配置，帮你完成一部分工作。 了解drivers64UEFI各个.EFI文件的作用，精简引导BIOS启动过程中要用到drivers32或drivers64目录，UEFI启动过程中则使用drivers64UEFI目录。它们的内容会根据配置和BIOS版本而有所不同。 必须要提的一点是这些驱动程序只在bootloader运行时有效，不会影响最终启动的操作系统。 至于到底要使用哪些驱动程序由用户来决定。 NTFS.efi NTFS文件系统驱动程序。用于启动Windows EFI系统。 HFSPlus.efiHFS+文件系统驱动程序。这个驱动对于10.13之前的系统版本来启动Mac OS X是必须的。 APFS.efiAPFS文件系统驱动程序。这个驱动对于在10.13的系统版本通过APFS装的黑果来启动Mac OS X是必须的。 VBoxHFS.efiHFSPlus.efi的替代品，性能要差一点。 VBoxExt2.efiEXT2/3文件系统驱动。用于启动Linux EFI系统。 VBoxExt4.efiEXT4文件系统驱动。用于启动Linux EFI系统。 FSInject.efi控制文件系统注入kext到系统的可能性。 PartitionDxe.efi已经存在于在CloverEFI和UEFI中，但没有为Apple分区优化，也没有为GPT/MBR优化。 OsxFatBinaryDrv.efi允许加载FAT模块比如boot.efi。 OsxAptioFixDrv.efi修复AMI Aptio EFI内存映射。如果没有就不能启动OS X。 OswLowMemFix.efi是OsxAptioFixDrv的简化版。两个不能同时使用。 DataHubDxe.efi已经存在于在CloverUEFI中。建议还是使用它，不会产生冲突。 CsmVideoDxe.efi比UEFI里提供更多分辨率的显卡驱动。 看了这么多，千万不要崩溃，我告诉大家一个经验，一般Drivers64UEFI目录只需要下面几个.EFI驱动就够了。 进攻ACPI，完美黑苹果(进阶篇)论坛贡献会员daxuexinsheng已经翻译了RehabMan的DSDT教程，可以说是非常详细，可以直接参考:使用补丁修改DSDT/SSDT，以及RehabMan的原贴。 如果你喜欢hotpatch，可以参考我的翻译帖Clover-ACPI-hotpatch，不过由于我太懒还没翻译完哈哈。当然还是推荐RehabMan的原贴。 准备工作 集成CLOVER的原版镜像 链接:https://pan.baidu.com/s/1gfTmRj9 密码:s3dv Transmac 链接:https://pan.baidu.com/s/1oAn79Zc 密码:yafn easyUEFI 链接:https://pan.baidu.com/s/1nwqbnMp 密码:gxoc Clover Configurator四叶草助手 链接:https://pan.baidu.com/s/1ht2wFQW 密码:tbce DiskGenius 链接:https://pan.baidu.com/s/1cVyULo 密码:pfrm 鲁大师/AIDA64(推荐)/也可以用设备管理器 自行度娘 安装步骤利用Transmac将原版镜像写入u盘打开TransMac,右键选择欲制作的USB盘符，选择Restore with Disk Image,选择下载好的dmg文件,会弹出窗口,提示将要格式化USB磁盘,点击OK按钮继续，耐心等待写盘的完成。写入完成，若弹出对话框提示将其格式化，点击取消。 利用鲁大师等软件查看自己机器的配置信息，来定制config和需要用的kext这一步想必不用我多说，大家利用鲁大师或者AIDA64看一下自己配置好了。有一点提示，尽量在安装过程中不考虑各种kext，尽量用少的驱动去安装，安装完成后再完善驱动，这样可以减少许多安装中的错误，也利于排错，但需要注意的必备的驱动一定要放，例如FakeSMC.kext、还有就是键盘驱动。当然老鸟无所谓了，直接把需要用到的都放上就OK了。以我自己机器为例，配置如下： 1234567891011主板 Asus X455LD Intel Haswell-ULT - Lynx Point-LP独立显卡 Nvidia GeForce 820M 2G 核心显卡 HD4400声卡 Realtek @ Intel Lynx Point-LP High Definition Audio (CX20751)以太网卡 Realtek RTL8168/8111/8112 Gigabit Ethernet Controller / Asus无线网卡 Atheros AR956X 按照上面的驱动简要说明，我以太网卡是RTL8111，那么需要RTL8111.kext、核心显卡是HD4400，就需要FakePCIID.kext、FakePCIID_Intel_HD_Graphics.kext，声卡比较麻烦，暂时不考虑，无线网卡是Atheros AR956X，那么我需要ATH9KFixup.kext，又要依赖Lilu.kext，所以需要Lilu.kext，四代低压机器，我需要IntelGraphicsFixup.kext来解决腾讯视频死机的问题，所以放上这个。暂时只考虑这些驱动吧，下面就进入安装阶段。 重启利用U盘启动选择安装盘开机按esc键进入启动项列表，不同厂商热键不同，参考下图： 选择U盘进入，这里就不介绍太多了，大家玩黑果的想必对BIOS不会陌生，不过需要注意的是需要将BIOS中的安全启动关掉。 接下来就会进入CLOVER引导界面 通过键盘方向键选中Boot OS X Install from ***，***代表你的镜像名字，然后回车。 等待进入安装界面。 这里选择自己擅长的语言好啦。 磁盘工具分区选择磁盘工具，并继续 选择显示所有设备 选择SSD Media,点击抹掉按钮,选择默认的Mac OS扩展(日志型)，在10.13中如果装在SSD上，也可以选择APFS,将名称修改为Macintosh HD（名字随意啦，自己喜欢就好，但要是英文）,点击抹掉按钮，抹掉完成后，点击完成按钮。 然后退出磁盘工具，到这里，磁盘工具的动作就已经结束了。 退出磁盘工具，选择安装macos选中刚才抹掉的分区开始安装选择安装macOS，并继续 接下来按照提示一步一步来就好了，有一步需要注意的就是选择安装分区时，选择自己之前抹掉的那个分区。 接下来静静等待，会有一次自动重启，依然用U盘启动，注意这次会在引导界面多出一个图标，选择除第一次选的图标外的另一个图标。然后继续等待 系统安装完成后,重启进入系统设置向导，接下来根据下面的图一步一步设置就好了 这里选择现在不传输任何信息 这里注意，一定不要选择加密！！！ 转移CLOVER到硬盘ESP，摆脱U盘引导这里用到前期准备的EasyUEFI，在Windows下安装打开此软件，添加CLOVER启动项，并置顶。具体操作参考：黑苹果安装从0开始—-clover优盘引导改硬盘引导篇 后期的驱动安装以及优化屏蔽无用的独显降低温度参考我之前的帖子：Disable the discrete GPU in laptop 摆脱万能声卡，利用AppleALC加载原生声卡参考我之前的帖子：Driver-audio-for-hackintosh还有这个帖子：自己动手用上AppleALC，使用原生AppleHDA 通过对DSDT打补丁完善电池显示参考pcbetadaxuexinsheng的帖子tonymacx86RehabMan的帖子 加载x86实现变频和原生电源管理，完善节能器信息 对于Haswell以及Broadwell平台，利用ssdtPRGen生成SSDT，在config中drop掉CpuPm和Cpu0Ist两个表，并利用FakeSMC或DSDT或hotpatch加载AppleLPC 对于Skylake及以上平台，选择支持HWP的合适的机型，并勾选HWPEnable。 注入HiDPI和显示器信息完善唤醒后的花屏、闪屏、撕裂屏问题参考：macOS Sierra 10.12下 开启HiDPI 傻瓜式开启教程 写在最后本帖多处引用现成帖子，只是将整个流程做个陈述，意在整理思路，以便大家更好地理解实践。本人水平有限，帖子中的不正确之处希望大家积极批评指出，一起完善。 楼主真的是懒到蜕皮(手动滑稽哈哈)帖子中图片很多是出自黑果小兵的博客：macOS安装教程兼小米Pro安装过程记录。 感谢各位黑果前辈的好帖子，引用太多，文中也有说明，就不一一列出了。 如果你在帖子中有任何不明白的地方，欢迎加入Hackintosh Club（群号580864366），一起探讨，当然啦，此群只为讨论技术，伸手党不要进来哈，只接受有些技术的，进群会有一段时间的考核哦。 待续……]]></content>
      <categories>
        <category>Hackintosh</category>
      </categories>
      <tags>
        <tag>Hacintosh</tag>
        <tag>黑苹果</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dell-Inspiron-15-7000-i7-8550u]]></title>
    <url>%2FDell-Inspiron-15-7000-i7-8550u.html</url>
    <content type="text"><![CDATA[Laptop Configuration123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315 --------[ 鲁大师 ]-------------------------------------------------------------------------------- 软件: 鲁大师 5.15.16.1025 时间: 2017-12-10 04:49:26 网站: http://www.ludashi.com--------[ 概览 ]---------------------------------------------------------------------------------- 电脑型号 戴尔 Inspiron 7572 笔记本电脑 操作系统 Windows 10 64位 ( DirectX 12 ) 处理器 英特尔 Core i7-8550U @ 1.80GHz 四核 主板 戴尔 0JV22R ( 英特尔 Xeon E3 - 1200 v6/7th Gen Intel Core/DRAM Registers - 5914 - 7th Generation Intel Processor Fami ) 显卡 英特尔 UHD Graphics 620 ( 128 MB / 戴尔 ) 内存 8 GB ( 海力士 DDR4 2401MHz ) 主硬盘 闪迪 X400 M.2 2280 128GB ( 128 GB / 固态硬盘 ) 显示器 京东方 BOE06B4 ( 15.3 英寸 ) 声卡 瑞昱 @ 英特尔 High Definition Audio 控制器 网卡 瑞昱 RTL8168/8111/8112 Gigabit Ethernet Controller / 戴尔--------[ 主板 ]---------------------------------------------------------------------------------- 主板型号 戴尔 0JV22R 芯片组 英特尔 Xeon E3 - 1200 v6/7th Gen Intel Core/DRAM Registers - 5914 - 7th Generation Intel Processor Fami 序列号 /CN3QYL2/CN1296679U0050/ 主板版本 A00 BIOS 戴尔 Inc. 1.0.0 / 制造日期: 2017年08月14日 BIOS的大小 16384 KB 板载设备 &quot;Intel HD Graphics&quot; / 视频设备 (启用)--------[ 处理器 ]-------------------------------------------------------------------------------- 处理器 英特尔 Core i7-8550U @ 1.80GHz 四核 速度 3.70 GHz (100 MHz x 37.0) 处理器数量 核心数: 4 / 线程数: 8 插槽/插座 U3E1 一级数据缓存 4 x 32 KB, 8-Way, 64 byte lines 一级代码缓存 4 x 32 KB, 8-Way, 64 byte lines 二级缓存 4 x 256 KB, 4-Way, 64 byte lines 三级缓存 8 MB, 16-Way, 64 byte lines 特征 MMX, SSE, SSE2, SSE3, SSSE3, SSE4.1, SSE4.2, HTT, EM64T, EIST, Turbo Boost--------[ 硬盘 ]---------------------------------------------------------------------------------- 产品 希捷 ST1000LM035-1RK172 大小 1 TB 转速 10000 转/分 硬盘已使用 共 100 次，累计 40 小时 固件 SDM2 接口 SATA Rev 2.5 数据传输率 300 MB/秒 特征 S.M.A.R.T, APM, 48-bit LBA, NCQ 产品 闪迪 X400 M.2 2280 128GB (固态硬盘) 大小 128 GB 硬盘已使用 共 102 次，累计 42 小时 固件 X4152012 接口 SATA III 数据传输率 600 MB/秒 特征 S.M.A.R.T, APM, 48-bit LBA, NCQ 产品 日立 HGST HTS545050A7E680 大小 500 GB 转速 5400 转/分 缓存 8 MB 接口 SATA III 数据传输率 600.00 MB/秒--------[ 内存 ]---------------------------------------------------------------------------------- DIMM 1 海力士 DDR4 2401MHz 8GB 制造日期 2017 年 08月 型号 AD HMA81GS6AFR8N-UH 序列号 81B5711B 厂商 Hynix 模块位宽: 64 Bits 模块电压: SSTL 1.2V--------[ 显卡 ]---------------------------------------------------------------------------------- 主显卡 英特尔 UHD Graphics 620 显存 128 MB 制造商 戴尔 制造商 Intel 驱动版本 22.20.16.4735 驱动日期 2017年07月07日 显卡 Nvidia GeForce MX150 显存 4 GB 制造商 戴尔 制造商 Nvidia 驱动版本 22.21.13.8278 驱动日期 2017年07月10日--------[ 显示器 ]-------------------------------------------------------------------------------- 产品 京东方 BOE06B4 厂商 京东方 固件日期 2016 年 01月 屏幕尺寸 15.3 英寸 (34 厘米 x 19 厘米) 显示比例 宽屏 16 : 9 分辨率 1536 x 864 32 位真彩色 Gamma 2.20 最大分辨率 1920 x 1080--------[ 其他设备 ]------------------------------------------------------------------------------ 网卡 瑞昱 RTL8168/8111/8112 Gigabit Ethernet Controller 制造商 戴尔 无线网卡 Atheros Killer Wireless-n/a/ac 1525 Wireless Network Adapter 制造商 戴尔 声卡 瑞昱 @ 英特尔 High Definition Audio 控制器 键盘 PS/2 标准键盘 键盘 HID 标准键盘 鼠标 HID-compliant 鼠标 鼠标 PS/2 兼容鼠标 鼠标 HID-compliant 鼠标 摄像头 Integrated Webcam--------[ PCI设备 ]------------------------------------------------------------------------------- 设备 Xeon E3 - 1200 v6/7th Gen Intel Core Host Bridge/DRAM Registers - 5914 设备ID 5914 制造商 Intel 制造商ID 8086 类别 Bridge / PCI to HOST 子系统制造商 Dell 子系统ID 08291028 设备 UHD Graphics 620 设备ID 5917 制造商 Intel 制造商ID 8086 类别 Display / VGA 子系统制造商 Dell 子系统ID 08291028 设备 Dynamic Platform and Thermal Framework Processor Participant 设备ID 1903 制造商 Intel 制造商ID 8086 类别 Data Aquisition &amp; Signal Processing / Other 子系统制造商 Dell 子系统ID 08291028 设备 USB 3.0 可扩展主机控制器 - 1.0 (Microsoft) 设备ID 9D2F 制造商 Intel 制造商ID 8086 类别 Serial / USB (UHCI) 子系统制造商 Dell 子系统ID 08291028 设备 100 Series Chipset Family Thermal subsystem - 9D31 设备ID 9D31 制造商 Intel 制造商ID 8086 类别 Data Aquisition &amp; Signal Processing / Other 子系统制造商 Dell 子系统ID 08291028 设备 Serial IO I2C Host Controller - 9D60 设备ID 9D60 制造商 Intel 制造商ID 8086 类别 Data Aquisition &amp; Signal Processing / Other 子系统制造商 Dell 子系统ID 08291028 设备 Management Engine Interface 设备ID 9D3A 制造商 Intel 制造商ID 8086 类别 Simple Communication / Other 子系统制造商 Dell 子系统ID 08291028 设备 6th Generation Core Processor Family Platform I/O SATA AHCI Controller 设备ID 9D03 制造商 Intel 制造商ID 8086 类别 Storage / Serial ATA (AHCI 1.0) 子系统制造商 Dell 子系统ID 08291028 设备 100 Series Chipset Family PCI Express Root Port #1 - 9D10 设备ID 9D10 制造商 Intel 制造商ID 8086 类别 Bridge / PCI to PCI 子系统ID 00000000 设备 100 Series Chipset Family PCI Express Root Port #5 - 9D14 设备ID 9D14 制造商 Intel 制造商ID 8086 类别 Bridge / PCI to PCI 子系统ID 00000000 设备 100 Series Chipset Family PCI Express Root Port #6 - 9D15 设备ID 9D15 制造商 Intel 制造商ID 8086 类别 Bridge / PCI to PCI 子系统ID 00000000 设备 Mobile 6th Generation Intel Processor Family I/O SCC: SDCard - 9D2D 设备ID 9D2D 制造商 Intel 制造商ID 8086 类别 System / SD Host Controller (With DMA) 子系统制造商 Dell 子系统ID 08291028 设备 Mobile 7th Generation Intel Processor Family I/O LPC Controller - 9D4E 设备ID 9D4E 制造商 Intel 制造商ID 8086 类别 Bridge / PCI to ISA 子系统制造商 Dell 子系统ID 08291028 设备 100 Series Chipset Family PMC - 9D21 设备ID 9D21 制造商 Intel 制造商ID 8086 类别 Memory / Other 子系统制造商 Dell 子系统ID 08291028 设备 High Definition Audio 控制器 设备ID 9D71 制造商 Intel 制造商ID 8086 类别 Multimedia / Hi-definition Audio 子系统制造商 Dell 子系统ID 08291028 设备 100 Series Chipset Family SMBus - 9D23 设备ID 9D23 制造商 Intel 制造商ID 8086 类别 Serial / SMBus Controller 子系统制造商 Dell 子系统ID 08291028 设备 GeForce MX150 设备ID 1D10 制造商 Nvidia 制造商ID 10DE 类别 Display / 3D 子系统制造商 Dell 子系统ID 08291028 设备 RTL8168/8111/8112 Gigabit Ethernet Controller 设备ID 8168 制造商 Realtek 制造商ID 10EC 类别 Network / Ethernet 子系统制造商 Dell 子系统ID 08291028 设备 Killer Wireless-n/a/ac 1525 Wireless Network Adapter 设备ID 003E 制造商 Atheros 制造商ID 168C 类别 Network / Other 子系统制造商 Dell 子系统ID 03101028--------[ USB设备 ]------------------------------------------------------------------------------- 制造商ID 152D 产品ID 1337 类别 0 / 0 / 0 设备 jmicron jmicron Serial 7F833EEF5DC0 制造商ID 0BDA 产品ID 5689 类别 239 / 2 / 1 设备 版本 USB 2.0 制造商ID 1C4F 产品ID 0034 类别 0 / 0 / 0 设备 SIGMACHIP Usb Mouse Serial ? 版本 USB 1.1 制造商ID 0CF3 产品ID E007 类别 224 / 1 / 1 设备 制造商ID 0BDA 产品ID 0129 类别 255 / 255 / 255 设备 版本 USB 2.0--------[ 传感器 ]-------------------------------------------------------------------------------- CPU温度 40℃ CPU核心 42℃ CPU封装 42℃ 显卡 39℃ 硬盘温度 31℃ Working NotesDisplayVendorID-9e5 can fix problems after sleep and awake such as macroblocking。Please put it in /System/Library/Displays/Contents/Resources/Overrides/。 Clover EFI bootloaderDell-Inspiron-15-7000-i7-8550u FinallyPlease respect the author’s work and reprint the source!]]></content>
      <categories>
        <category>Hackintosh</category>
      </categories>
      <tags>
        <tag>Hacintosh</tag>
        <tag>燃7000</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Change NetBeans's language to Chinese in macOS]]></title>
    <url>%2FChange-NetBeans's-language-to-Chinese-in-macOS.html</url>
    <content type="text"><![CDATA[macOS下修改NetBeans的界面语言在Applications中找到NetBeans的安装目录：/Applications/NetBeans/NetBeans 8.2.app/Contents/Resources/NetBeans/etc/netbeans.conf，以纯文本文档格式打开，搜索netbeans_default_options，在最后加上--locale zh:CN，改为英文则是--locale en:US，如图所示：]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>NetBeans</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Driver audio for hackintosh]]></title>
    <url>%2FDriver-audio-for-hackintosh.html</url>
    <content type="text"><![CDATA[前言 在vit9696推出AppleALC后，经过越来越多人仿冒声卡得到的数据的提交整理，AppleALC的数据越来越集中，也使声卡驱动变得越来越简单。 本文提供使用AppleALC驱动声卡的思路以及常见错误和驱动后的问题进行修复。 前期准备 需要下载Xcode 在AppleStore下载 下载AppleALC 通过终端执行下面的命令，会下载到你的用户根目录 1$ git clone https://github.com/vit9696/AppleALC 下载Lilu 在下面的网址下载DEBUG和RELEASE 1https://github.com/vit9696/Lilu/releases 提取Codec 这一步需要用到Linux环境，首先下载Ubuntu镜像，我个人提供一个 1链接:http://pan.baidu.com/s/1i47I0jN 密码:de4v 当然也可以去官网下载，下载好镜像之后，将U盘格式化为Fat32，然后将镜像解压到U盘，重启以U盘启动，选择试用进入Ubuntu系统界面，打开终端输入 1$ cat /proc/asound/card0/codec#0 &gt; ~/Desktop/Codec.txt 执行完后会将Codec.txt提取到桌面，将其保存到U盘 PS: 一般来说提取的Codec会有10k左右大小，如果大小不够，很有可能提取错误，可以尝试以下命令 1$ cat /proc/asound/card0/codec#1 &gt; ~/Desktop/Codec.txt 或者 1$ cat /proc/asound/card0/codec#2 &gt; ~/Desktop/Codec.txt 或者 1$ cat /proc/asound/card1/codec#0 &gt; ~/Desktop/Codec.txt Codec.txt的数据整理 记录Address和Vendor Id值 Codec.txt开头部分 提取节点信息 搜索Pin Default记录Node和节点描述，以我的为例 PS: N/A节点无效无需整理，如下面的不需要整理 记录HP Out at Ext Left节点的tag和enable值 PS: Unsolicited Response的设定是为了解决耳机和外放切换的问题。需设定 HP Out at Ext 所在的节点，并且节点信息中有Unsolicited: tag=xx, enabled=1 这一行。设定命令为Address+NodeID+708+&lt;设定值&gt; 设定值是8位的一个二进制数，记作a7 a6 a5 a4 a3 a2 a1 a0，推算出此二进制数之后，四四拆分转换为2位的十进制数加1即为此设定值 a7表示enabled。a6=0，没具体应用，不用管。a5~a0，存放tag。** 记录Mic at Ext节点的Pin-ctls值 PS: Pin Control Widget的设定是为了解决耳机杂音的。 需要设定的是 Mic at Ext 所在的节点，设定的值可以从codec dump中读取。 设定命令是 Address+NodeID+707+Pin-ctls值。 整理完后，会得到如下所示的数据集合 PS: 常见的节点设备描述如下： Mic at Ext–线路输入(耳麦) Mic at In–内建输入 HP Out–耳机扬声器 Speaker–内建扬声器(外放) 至此，Codec 数据的整理到此结束 AppleALC中数据的筛选 依次打开下载的AppleALC源码里面/AppleALC/Resources/PinConfigs.kext/Contents下的Info.plist 搜索之前记录的CodecID 记录搜索到的所有的ID中的configdata，如下整理 每一行的每一串的第一个字符代表Address值 每一行的第三串倒数第二个字符代表这个节点的设备描述，具体对应关系如下 根据上图设备对应关系和Address值排除掉无效的ID数据 开工 将下载的Debug的Lilu.kext放进 AppleALC 源码根目录； 删除/AppleALC/Resources中多余文件夹，只留下你的声卡型号文件夹、Pinconfigs.kext以及四个plist文件，以cx20751这个声卡为例剩下如下文件 然后打开计算器，显示为编程器 打开你整理的Codec，找到Vendor Id，拷贝后面的字符串，在计算器选中十六进制，粘贴这个字符串 然后选中十进制，就换转换成十进制形式 拷贝这个十进制数，打开/AppleALC/Resources/CX20751_2/Info.plist(此处的CX20751_2需要换成你的声卡型号)，把codecid换成刚才拷贝的十进制数 保存退出，右键PinConfigs.kext显示包内容，打开里面的Info.plist，搜索刚才拷贝的十进制数，记下LayoutID数据，有几个记几个，都记下来，然后将IOKitPersonalities-&gt;HDA Hardware Config Resource-&gt;HDAConfigDefault中的其他型号删除，(为避免出错，这里的删除可以不操作，删除只是为了精简做出来的AppleALC)，保存退出。 然后双击打开 AppleALC 中的工程文件： 按图示操作 点击右面的export next where填上桌面，点export就生成AppleALC在桌面上了，一层一层打开它，将其中的AppleALC.kext放到clover驱动目录，注意之前下载的Release的Lilu也要放到clover驱动目录，最后不要忘了在config注入LayoutID： 如图Audio处写上刚才记下的LayoutID，如果重启后你的声卡不能驱动，或者已驱动但是没有输入或输出，这时很有可能是该LayoutID对应的configdata数据有错误，这时就挨个尝试刚才记录的所有ID。 至此， AppleALC 驱动声卡部分结束。 关于解决耳机与内建输入的切换 如果驱动工作完成后，声卡可以工作，但不能自动切换，请接着往下看 打开终端，输入 1git clone https://github.com/goodwin/ALCPlugFix 回车就将ALCPlugFix下载到了你的用户目录，打开此目录中的ALCPlugFix中的main.m下拉到最下方，注意这一部分： 下载had-tools,将codec复制到had-tools目录，打开终端，cd到此目录，输入 1./widget_dump.sh 回车 找到nid = 0x19和nid = 0x1a，这里我的19为 line in，1a为mic in，记录下最后两位，我的是04和24就这么改 PS: 这里需要设定的节点数据分别是line in和mic in，其他节点无效，思想就是捕获系统在不插耳机时由于其输入输出正常的这两个节点的输出值，然后就可以知道插耳机正常应该输出的值，进而利用AppleALC守护进程动态守护。如果出现插耳机正常，不插无效的情况，请按照这个思路反过来操作，思想都是一样的。其中图上的高亮处最上面一部分是默认情况，中间是耳机移除，最下面是耳机插入，请结合自身使用情况合理设定 保存退出，双击按照AppleALC的编译方法编译这个 然后将生成的ALCPlugFix替换alc_fix中的ALCPlugFix，终端cd到alc_fix目录，执行 1./install.sh 耳机就可以自动切换了，三节点的朋友运气好的话杂音应该也解决了，这时插入耳机在执行 1./widget_dump.sh 就可以发现之前的19和1a后面的数据反过来了 其实这里的数据就是侦测耳机插拔状态，向系统发送相关指令来做到切换正常 需要设定的就是两个节点Mic at Ext(有时是Line In)和Mic at In Mic at Ext(有时是Line In)表示线路输入，即耳麦，多为0x19节点 Mic at In为内建输入 PS: 如果widget_dump.sh脚本得不到想要的结果，请在点击这里下载CodecCommander，将Release里面的hda-verb利用命令拷贝到/usr/bin/ 如果不行重启一次应该就好了。 至此，解决耳机与内建输入的切换部分结束。 关于唤醒无声 可以先尝试下面两个驱动 CodecCommanderEAPDFix 提取密码:w4yr PS: 关于CodecCommander，可以点击这里参考RehabMan的说明 另外四叶草助手中也提供了相关选项(ResetHDA和dartweak)，但是本人没有亲自尝试，大家可以自行尝试这些组合： 本人对唤醒无声研究不多，至此，解决耳机与内建输入的切换部分结束，欢迎补充。 关于万能声卡 很多人不喜欢万能声卡，说万能有杂音(但是有一些人的AppleALC也可能有杂音)，甚至说用万能声卡是不完美的表现，其实我认为不然，万能是一种很好的渠道，有不少人用万能声卡，他们的切换、输入甚至HDMI都能很好的输出，而且杂音也是可以减小的。 这里我给出官方的项目地址，有兴趣的可以试一下 https://sourceforge.net/projects/voodoohda/ PS: 需要注意的是有人用的是VoodooHDA.pkg安装的，这种情况需要将AppleHDADisabler.kext放到Clover的驱动目录来禁用AppleHDA，否则很有可能会造成KP五果，所以我建议直接用kext，让Clover注入器注入即可。 关于完整仿冒前言 声卡型号众多，虽然AppleALC让数据更集中了，但还是有些声卡不在目前的AppleALC支持的列表里面，对于这种情况来说，我们只能完整制作仿冒声卡。 接下来以我的CX20751为例简述仿冒声卡制作过程。 完整制作仿冒声卡思路 整理Codec，提取所有有效Node值 将整理出的所有Node的Pin Default值进行转换得出需要的值 根据某些规律或者规则得出ConfigData PathMap的获取和整理 知识普及 每一个Node的ConfigData值都是由四个八位的字符串组成，这四个串的最后两位分别是一个八位的设定值的1 2、3 4、5 6、7 8位，这四个八位的字符串的设定规则分别是是Address+Node+71C+1 2位设定值、Address+Node+71D+3 4位设定值、Address+Node+71E+5 6位设定值、Address+Node+71F+7 8位设定值。 这里需要注意，有两个不同的八位被提及，其中一个八位(这八位每一位都有特定的含义，也是仿冒成功最关键的地方，在后面我称之为设定值)是被均分四份从而放到ConfigData的各个节点所对应的四个串的七八位 而这个八位的设定值每一位的含义如下： 第一位：代表节点设定值(Address)，一般不需要改变； 第二位：同组装置的优先顺序，一般为 0~3，不可出现字母； 第三位：插口颜色，笔记本忽略，不作处理； 第四位：插孔侦测，0为开启(外设基本为0)，1为关闭(内建基本为1)； 第五位：装置类型，笔记本忽略； 第六位：连接类型，圆口为1，内接为0，基本可以忽略； 第七位：代表是否有插孔及插孔位置0=外接，9=内建，耳机扬声器和耳麦均为外接； 第八位：代表插孔所在位置，0=内建，1=外接； 开始整理Codec，提取所有有效Node值 与上面利用AppleALC的思路不同，这里我们需要提取的数据有设备描述、Node值和Pin Default值。具体提取方法上文已有说明，这里不再赘述，下面是我的CX20751提取的数据： 将整理出的所有Node的Pin Default值进行转换修正得出需要的设定值 对于Pin Default值，我们的处理方法为八位四分、二二逆置，例如0x16节点，首先得出40 10 21 03，同理得出： 12340x16: 40 10 21 030x17: 10 01 17 900x19: 30 10 A1 030x1a: 20 01 A7 95 根据八位设定值的规则描述，对上面得出的设定值进行修正。 拿0x16为例，这是一个耳机扬声器节点。 第1、2、3位没什么好说的保持不变；第4位插孔侦测，耳机设备属于外接设备，所以应当是0，这里是0不用动；第5位装置类型笔记本忽略；第6位连接类型，插口为圆口，所以是1，这里是1，保持不变；第7位代表是否有插孔，耳机是外接设备，所以是0，这里是0，保持不变；第8位插孔所在位置，耳机是外接设备，所以是1； 其他Node节点也是如此设定； 修正后的数据如下： 12340x16: 40 10 21 010x17: 10 01 17 900x19: 30 10 81 010x1a: 20 01 A0 90 根据规律或者规则得出ConfigData 根据上面得出的设定值，我可以得出以下ConfigData值： 123401671C40 01671D10 01671E21 01671F0101771C10 01771D01 01771E17 01771F9001971C30 01971D10 01971E81 01971F0101a71C20 01a71D01 01a71EA0 01a71F90 PS: 搜索一下codec里面有没有EAPD这个字符串，有的话就在ConfigData的最后面加上一串01470C02这组数字。 PathMap的获取和整理 在声卡仿冒的过程中这一步是最麻烦的。有几个需要注意的地方。 对于声音节点来说，节点路径的推断遵循一个规律： 输入是从后往前推断节点，输出是从前往后推。 首先利用codecgraph得到路径图，该操作需要安装graphviz，这里我推荐利用终端npm install graphviz安装即可，然后执行下面的命令下载codecgraph 1$ git clone https://github.com/athlonreg/codecgraph.git 这样就下载到了你的用户根目录，将你的Codec.txt拷贝到下载的codecgraph目录下，然后 12$ cd codecgraph$ ./codecgraph Codec.txt 就在codecgraph目录下生成了你的声卡路径图，格式为svg，用safari即可打开，当然也可以转换为其他格式，这里我转换成了png格式，例如我的 可以看到0x16节点只连接了0x10，HP Out为输出，从前往后推，转换为十进制得到0x22 -&gt; 0x16; 0x17节点只连接了0x11，Speaker为输出，从前往后推，转换为十进制得到0x23 -&gt; 0x17; 0x19节点只连接了0x14，Mic at Int为输入，从后往前推，转换为十进制得到0x20 -&gt; 0x25; 0x1a节点只连接了0x13，Mic at Ext为输入，从后往前推，转换为十进制得到0x19 -&gt; 0x26; 整理得到路径如下： 设备名称 有效节点 路径 HP Out 0x16 0x22-&gt;0x16 Speaker Out 0x17 0x23-&gt;0x17 Mic In 0x1a 0x26&lt;-0x19 0x26&lt;-0x20 Line In 0x19 0x25&lt;-0x20 0x26&lt;-0x19 PS: 我的声卡比较奇葩，对于多数声卡来说，输入一般为0x8 -&gt; 0x35 -&gt; 0x18，输出一般为0x33 -&gt; 0x13 -&gt; 0x3，看下图： AppleHDA 修改Creditvit9696goodwinRehabManDolnordalianskyVoodooHDA 写在最后 码字不易，如果觉得文章不错，欢迎打赏，你们的支持是我最大的动力。]]></content>
      <categories>
        <category>Hackintosh</category>
      </categories>
      <tags>
        <tag>Hacintosh</tag>
        <tag>黑苹果</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[How to import a project from NetBeans to MyEclipse faultlessly]]></title>
    <url>%2FHow-to-import-a-project-from-NetBeans-to-MyEclipse-faultlessly.html</url>
    <content type="text"><![CDATA[写在前面最近，在一次网络编程课中，实验室的 PC 机有好多 NetBeans 打不开，经过一节课的摸索和董老师的帮助，终于找到一种方法将 NetBeans 写的项目导入 MyEclipse 中，并且可以减少很多错误以及乱码的情况出现 进入主题 将 NetBeans 写的项目导入 MyEclipse 中的时候最常见的错误有以下三种： 在 NetBeans 中如果一条语句过长会有自动换行的情况，但在 MyEclipse 中并不能识别这种换行，于是像 try-catch 和 if 语句这种代码往往在导入工程之后跑到了注释后面，造成语法错误； MyEclipse 默认编码方式为 GBK,所以将 NetBeans 写的项目导入 MyEclipse 中的时候，项目代码里面的中文注释将会出现乱码； 如果 NetBeans 中的 Java 代码在一个自己建的 package 下，会出现很多需要将代码移动到这个 package 下的错误。 针对这些常见的情况，可以找到下面一种方法进行导入操作 在 MyEclipse 新建一个 Java Project； 右键这个 Project -&gt; 属性 -&gt; Text file encoding，将编码方式设置为 UTF-8； 展开这个 Project，右键其下面的 src 包，新建一个 Package，这里我用 cn.edu.ldu 来表示； 右键新建的 cn.edu.ldu 包 -&gt; Import -&gt; General -&gt; File System -&gt; Next，在 From directory 中选择要导入的项目，然后在弹出的对话框中勾选这个项目，选择 Finish 就可以了。 操作完成之后只剩下一些内部包的导入工作需要额外操作，其余均比较完美 运行结果也很好 大家快去试一下吧 收工咯]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>NetBeans</tag>
        <tag>MyEclipse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RW NTFS partition natively on macOS]]></title>
    <url>%2FRW-NTFS-partition-natively-on-macOS.html</url>
    <content type="text"><![CDATA[实现 MAC 原生读写 NTFS 分区 打开终端，输入命令 1$ diskutil list 输入命令 1$ sudo vim /etc/fstab 编辑内容如下 1LABEL=Win\040Ntfs\040Drive none ntfs rw,auto,nobrowse 注意 Win\040Ntfs\040Drive 这串字符中\040代表空格，Win\040Ntfs\040Drive 这一串出现在diskutil list那个屏幕里面，比如下图就是HD-E1 最后一步 1$ sudo ln -s /Volumes ~/Desktop/Volumes Credit 转自爱情守望者 转载请注明原帖地址]]></content>
      <categories>
        <category>Hackintosh</category>
      </categories>
      <tags>
        <tag>Hacintosh</tag>
        <tag>黑苹果</tag>
        <tag>NTFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Change launchpad icon grid layout in your MAC]]></title>
    <url>%2FChange-launchpad-icon-grid-layout-in-macOS.html</url>
    <content type="text"><![CDATA[prefaceLaunchpad is the quick application launcher available from the Mac OS X Dock and a keystroke that looks quite a bit like the Homescreen of iOS. By default, the Launchpad app grid usually displays icons in 7 rows and 5 columns of apps, but with a little adjustment from the command line of OS X you can switch and customize the Launchpad icon grid to any number of apps you’d like to see on the Mac. This uses the command line and defaults strings to customize the Launchpad grid layout, if you’re not comfortable with Terminal you’re probably better off leaving this alone and enjoying the default Launchpad app icon grid. We’ll combine the commands into a single syntax string for ease of use first, but you can break them apart as we show you a bit further below. How to Adjust the Icon Grid Count of Launchpad in Mac OS X Open the Terminal found in /Applications/Utilities/ and enter the following command syntax, replacing the X numbers for the appropriate columns and grid icon counts 1$ defaults write com.apple.dock springboard-columns -int X;defaults write com.apple.dock springboard-rows -int X;defaults write com.apple.dock ResetLaunchPad -bool TRUE;killall Dock It is: $ defaults write com.apple.dock springboard-columns -int X;defaults write com.apple.dock springboard-rows -int X;defaults write com.apple.dock ResetLaunchPad -bool TRUE;killall Dock For example, to set the Launchpad grid to 6×7 you’d use the following syntax: 1$ defaults write com.apple.dock springboard-columns -int 7;defaults write com.apple.dock springboard-rows -int 6;defaults write com.apple.dock ResetLaunchPad -bool TRUE;killall Dock It is: $ defaults write com.apple.dock springboard-columns -int 7;defaults write com.apple.dock springboard-rows -int 6;defaults write com.apple.dock ResetLaunchPad -bool TRUE;killall Dock Hit Return and wait for the Dock and Launchpad to refresh Open Launchpad as usual to see the layout change The settings change is immediate after the Dock refreshes: How to return to the default settingIf you want to return to the default setting, just change the column and row counts back to what yours was originally. The default on my MacBook Pro Retina display is a 5 x 7 grid, but yours may be different depending on screen size and screen resolution. 1$ defaults write com.apple.dock springboard-columns -int 7;defaults write com.apple.dock springboard-rows -int 5;defaults write com.apple.dock ResetLaunchPad -bool TRUE;killall Dock It is: $ defaults write com.apple.dock springboard-columns -int 7;defaults write com.apple.dock springboard-rows -int 5;defaults write com.apple.dock ResetLaunchPad -bool TRUE;killall Dock The commands for customizing the Launchpad layout can also be split apart if desired like so:Set the Launchpad Column Icon Count 1$ defaults write com.apple.dock springboard-columns -int 3 Set the Launchpad Row App Icon Count 1$ defaults write com.apple.dock springboard-rows -int 4 Reset Launchpad 1$ defaults write com.apple.dock ResetLaunchPad -bool TRUE; Relaunch the Dock with killall 1$ killall Dock Credit:Original Source: OSXDaily]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>launchpad</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Common Keyboard shortcut on MAC]]></title>
    <url>%2FCommon-Keyboard-shortcut-in-macOS.html</url>
    <content type="text"><![CDATA[写在前面 苹果 Mac 系统常用快捷键有很多，但是很多童鞋对于这些 Mac 快捷键都不是很熟悉，今天小编为大家整理了一份 Mac 系统常用快捷键大全，大家快收藏起来吧!平时在使用 Mac 系统的时候可以提高不少工作效率哦! 本文转自 Xclient.info，转载请注明原出处 小普及 Mac中主要有四个修饰键，分别是 Command，Control，Option 和 Shift。 这四个键分别有自己的图案，他们经常出现在Mac应用程序中的菜单栏里，方便你随时学习新的快捷键。 如下 正文通用快捷键 Command 是 Mac 里最重要的修饰键，在大多数情况下相当于 Windows 下的 Ctrl，黑果通常是 Alt 键。 Command + Z 撤销。 Command + X 剪切。 Command + C 拷贝(Copy)。 Command + V 粘贴。 Command + A 全选(All)。 Command + S 保存(Save)。 Command + F 查找(Find)。 系统快捷键 Option 开机后立即按下，将显示启动管理器。 Command + R 开机后立即按下，可打开OS X 的恢复功能。 Command + Option + P + R 开机后立即按下，重置 NVRAM。有些时候电脑会出现些小问题，重置 NVRAM 是你除了重新启动，尝试修复的第一选择。 Command + Option + Control + Power 退出所有应用程序，允许你进行文稿储存，然后关机。 按住 Power 按钮 5 秒 强制 Mac 关机。 截图 Command + Shift + 3 截取全部屏幕到文件。 Command + Shift + Control + 3 截取全部屏幕到剪贴板。 Command + Shift + 4 截取所选屏幕区域到一个文件，或按空格键仅捕捉一个窗口。 Command + Shift + Control + 4 截取所选屏幕区域到剪贴板，或按空格键仅捕捉一个窗口。 文件管理器 Command + Shift + N (New) 新建文件夹。 Command + Shift + G (Go) 调出窗口，可输入绝对路径直达文件夹。 return 这个其实不算快捷键，点击文件，按下可重命名文件。 Command + O 打开所选项。在 Mac 里打开文件不像 Windows 里直接按 Enter。 Command + Option + V 作用相当于Windows里的文件剪切。在其它位置上对文件复制(Command-C)，在目的位置按下这个快捷键，文件将被剪切到此位置。 Command + ↑ 打开包含当前文件夹的文件夹，相当于 Windows 里的“向上”。 Command + Delete 将文件移至废纸篓。 Command + Shift + Delete 清倒废纸篓。 Space 快速查看选中的文件，也就是预览功能。 切换 Command + Tab 在应用程序间切换。 Command + Shift + Tab 在应用程序间切换(反向)。 Command + ~ 在各应用中的窗口间切换。 浏览器 Command + L 光标直接跳至地址栏。 Control + Tab 转向下一个标签页。 Control + Shift + Tab 转向上一个标签页。 Command + ‘+’或’=’ 放大页面。 Command + ‘-‘ 缩小页面。 应用程序中 Command + H 隐藏(Hide)当前正在运行的应用程序窗口。 Command + Option + H 隐藏(Hide)其他应用程序窗口。 Command + Q 退出(Quit)最前面的应用程序。 Command + Shift + Z 重做，也就是撤销的逆向操作。 Command + Tab 在打开的应用程序列表中转到下一个最近使用的应用程序，相当于 Windows 中(Alt+Tab)。 Command + Option + esc 打开“强制退出”窗口，如果有应用程序无响应，可在窗口列表中选择强制退出。 文本处理 Command + B 切换所选文字粗体(Bold)显示。 fn + Delete 相当于 PC 全尺寸键盘上的 Delete，也就是向后删除。 fn + ↑ 向上滚动一页(Page Up)。 fn + ↓ 向下滚动一页(Page Down)。 fn + ← 滚动至文稿开头(Home)。 fn + → 滚动至文稿末尾(End)。 Command + → 将光标移至当前行的行尾。 Command + ← 将光标移至当前行的行首。 Command + ↓ 将光标移至文稿末尾。 Command + ↑ 将光标移至文稿开头。 Option + → 将光标移至下一个单词的末尾。 Option + ← 将光标移至上一个单词的开头。 Control + A 移至行或段落的开头。 更多快捷键如果你还想学习更多快捷键，请点击这里查看苹果官方的快捷键帮助文档。]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>快捷键</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Connect Network in Windows 10]]></title>
    <url>%2FConnect-Network-in-Windows-10.html</url>
    <content type="text"><![CDATA[开工 首先右击我的电脑-&gt;管理-&gt;任务计划程序-&gt;任务计划程序 中间窗口空白处右键 -&gt; 创建基本任务 弹出的下列窗口名称处输入 PPPOE 继续选择 当用户登录时 选择 启动程序 在 程序或脚本 处按照以下格式输入你的本地宽带连接账号 1rasdial 宽带连接 宽带账号 宽带密码 比如我的则为 经网友反馈，发现图中“宽带连接”后少了一个空格，请大家自主添加 一路下一步直到完成]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>自动连接</tag>
        <tag>宽带</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sync your hexo with several terminal]]></title>
    <url>%2FSync-your-hexo-with-several-terminal.html</url>
    <content type="text"><![CDATA[前言 Sync your hexo with several terminal转载请注明原出处 准备工作 首先在 GitHub 建立一个分支用于存储 hexo 本地源文件 本地 hexo 源上到 GitHub在本地博客根目录下使用 git 指令上传项目到 GitHub 的 hexo 分支 123456$ git init $ git remote add origin 仓库地址 $ git checkout -b hexo $ git add . $ git commit -m &quot;&quot; $ git push origin hexo 其它设备同步建立同步目录1$ mkdir blog 同步 hexo 源1234$ cd blog/$ git init$ git remote add origin 仓库地址$ git pull -r origin hexo 本地搭建 hexo 环境 需要安装 Git 和 Node.js 12$ npm install hexo --save$ npm install 第一次运行需要验证 GitHub 和 coding 账号 ( 取决于你用什么部署的 blog ) 12$ git config --global user.email &quot;you@example.com&quot;$ git config --global user.name &quot;Your Name&quot; 完工 做完上面的步骤就可以在这一台设备继续发博文了 1234$ hexo new post &quot;新建博客名字&quot; $ hexo clean $ hexo g$ hexo d -g]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>同步</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Resolve short duration lag after wake and after login on haswell or broadwell]]></title>
    <url>%2FResolve-short-duration-lag-after-wake-and-after-login-on-haswell-or-broadwell.html</url>
    <content type="text"><![CDATA[写在前面 本文来自 tonymacx86.com原作者 RehabMan转载请注明 原出处 开工 在 macOS Sierra 10.12.4 中，有不少 Haswell 和 Broadwell 机器出现了一种情况，就是在开机后的登录界面会有大约 20s 的无响应延迟状态，这种情况在之前是没有出现的，如果你的机器恰好是这两个平台的一种并且出现了这种情况，那么请注意，你会需要对你的 config.plist 做一些调整，如下: 123Comment: 0x0a260006 9MB cursor bytes (vbo), 2 ports only (RehabMan)Find: &lt;0600260a 01030303 00000002 00003001 00006000&gt;Replace: &lt;0600260a 01030202 00000002 00003001 00009000&gt; 123Comment: 0x0a260006 disable 0204 port, change 0105 DP port to 0204 HDMI (RehabMan)Find: &lt;01050900 00040000 87000000 02040900 00040000 87000000&gt;Replace: &lt;02040900 00080000 87000000 FF000000 01000000 40000000&gt; 将这两个 patch 打到 config.plist -&gt; Kernel and Kext Patches -&gt; KextsToPatch 处，保存即可，如果你的机器是 Haswell 的 HD4600 并且上面的 patch 不能解决这个问题，请尝试放 AzulPatcher4600.kext 到 /EFI/CLOVER/Kexts/Other ，此项目 GitHub 地址: 1https://github.com/coderobe/AzulPatcher4600]]></content>
      <categories>
        <category>Hackintosh</category>
      </categories>
      <tags>
        <tag>黑苹果</tag>
        <tag>short duration lag</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Disable the discrete GPU in laptop]]></title>
    <url>%2FDisable-the-discrete-GPU-in-laptop.html</url>
    <content type="text"><![CDATA[写在前面最近我根据 RehabMan 的 hotpatch 添加了一些路径做了一个屏蔽独显得 hotpatch 来屏蔽独显解决一些升级 10.13 后因为 nv_disable 参数失效而卡在 Window Server Service only ran for 0 seconds 的错误，发现有些成功，有些失败。于是把我琢磨到的一种方法分享给大家！希望该帖子能帮助到各位！ 感谢： PCBETA (远景论坛) yearjinheng 版主的帖子 tonymacx86.com Rehabman 的帖子 转载请注明 原贴地址 屏蔽独显方法不一： 第一种：直接在 DSDT SSDT 上做修改 第二种：手动制作一个适合自己机器的 hotpatch 屏蔽独显达到屏蔽独显的作用 开工 本帖主要采用第二种方法，大致思路如下： 提取 ACPI 原始表单 反编译这些文件 搜索一个名为 _OFF 的方法 检查文件的结果以确定 _OFF 的路径 修改 RehabMan 的 hotpatch 加入自己的路径 提取 ACPI 原始表单并提取 _OFF 路径 打开电脑进入四叶草引导界面，按下 F4 或者 FN+F4 即可提取原始表单到 /EFI/CLOVER/ACPI/origin ，然后进入 MAC 将 origin 拷贝到桌面删掉除 SSDT DSDT 之外的所有 aml 文件，打开终端： 1234$ cd ~/Desktop/origin $ iasl -da -dl *.aml $ rm *.aml $ grep -l Method.*_OFF *.dsl 以我修改的一个机器为例，上一条命令得到的结果如下 1234DSDT.dslSSDT-7.dslSSDT-8.dslSSDT-9.dsl 依次打开这四个表单搜索 _OFF ，找到一个类似于下面这个函数： 图片左下角的路径就是我们最终所需要的: 1_SB.PCI0.RP05.PEGP 修改 RehabMan 的 hotpatch 添加这个路径 首先去 RehanMan 的 GitHub 下载 hotpatch 包 1https://github.com/RehabMan/OS-X-Clover-Laptop-Config.git 我们只需要 SSDT-Disable_DGPU 这个文件，编译成 aml 文件 1$ iasl SSDT-Disable_DGPU.dsl 打开编译后得到的 aml 文件 按照这个格式添加自己的路径 保存放到 /EFI/CLOVER/ACPI/patched 一个注意点 如果在 Config.plist 中使用了 SortedOrder (通常 Clover 安装后默认没有设置)，需要在其内添加 SSDT-Disable_DGPU.aml 这一项。因为如果指定了 SortedOrder ，则 Clover 只加载其中指定的 SSDT 。如果没有出现在列表中,即使在 ACPI/patched 中，它也不会加载。 完工]]></content>
      <categories>
        <category>Hackintosh</category>
      </categories>
      <tags>
        <tag>Hacintosh</tag>
        <tag>黑苹果</tag>
        <tag>Window Server Service only ran for 0 seconds</tag>
        <tag>Disable DGPU</tag>
        <tag>屏蔽独显</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sync the codes between native and remote by git]]></title>
    <url>%2FSync-the-codes-between-native-and-remote-by-git.html</url>
    <content type="text"><![CDATA[前言 Sync the codes between native and remote by git转载请注明原出处 代码放到 git 仓库，然后本地修改同步至仓库，这在生活中是很常见的，下面是一个最简单的案例远程仓库内容同步到本地仓库 新建一个本地仓库用于后续工作 123$ cd ~/Desktop/$ mkdir test $ cd test 初始化这个本地目录 1$ git init 关联到远程仓库(以我新建的 Test 这个仓库为例) 1$ git remote add origin https://github.com/athlonreg/Test.git 合并远程仓库的文件到本地 1$ git pull --rebase origin master 修改本地仓库并推送到远程仓库 对本地仓库的一些修改 123$ mkdir inner $ cd inner $ touch a.txt 现在将我新建的 inner 目录和 a.txt 文档推送到远程仓库 git add 命令添加新建目录与文件 1$ git add . git commit 提交修改，引号内为修改的概要 1$ git commit -m &quot;add some files&quot; 这里会提示配置用户身份(两条命令的引号内分别为你 github 账号绑定的邮箱和用户名) 12$ git config --global user.email &quot;15563836030@163.com&quot; $ git config --global user.name &quot;athlonreg&quot; 这是继续提交修改就可以了 1$ git commit -m &quot;add some files&quot; 推送修改后的本地仓库到远程仓库 1$ git push -u origin master 这时终端会让你输入你的 github 用户名和密码，根据提示输入完，就推送完成了，再去 github 网页端就发现仓库已经更新至和本地相同了。 Windows 用户安装好 git 可以利用 git bash 来操作 下面是我在 Windows 下利用 git bash 工具的一些截图，大家可以作参考]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>同步</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Problem about police and gangster 110]]></title>
    <url>%2FProblem-about-police-and-gangster-110.html</url>
    <content type="text"><![CDATA[问题描述 思路1、一共九个数字，八个操作符；2、每个操作符有三种情况，即留空、加或者减，分别用0、1和2表示；3、共有 3^8 种情况，遍历每种情况判断输出；4、需要注意的是留空和’+’、’-‘需要分开处理，因为留空之后需要将其前后的数据连在一起。5、以12+34+56+7-8+9为例，给和sum赋初值为0，第一次循环操作符为留空，需要先加上第一位的1，然后进行这一次运算，即1x10+2，然后下一次循环操作符为+，需要计算的就是12+3，同理在3、4之间的空需要计算的是3x10+4，而不是（12+3）x10+4，所以需要一个临时变量来记录上次的操作数，还需要一个变量来记录上次的操作符将上次的结果进行统计处理，原因就在于我们无法确定下次的操作符是不是留空。6、由于我们在统计和时，只有在下一次循环才能处理最后一个操作数，所以需要将9最后单独处理。 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;stdio.h&gt; #include &lt;math.h&gt; int main() &#123; int a[9]=&#123;1,2,3,4,5,6,7,8,9&#125;; int sum; int temp; int oper,lastoper; int number; int i,j; for(i=0;i&lt;pow(3,8);i++) &#123; sum=0; temp=1; lastoper=1; number=i; for(j=1;j&lt;=8;j++) &#123; //操作八次 oper=number%3; number=number/3; if (!oper) temp=temp*10+a[j]; //留空单独处理 if (oper==1) &#123; //当前操作符 if(lastoper==1)&#123; //前一次操作符 sum=sum+temp; temp=a[j]; &#125; if(lastoper==2)&#123; sum=sum-temp; temp=a[j]; &#125; lastoper=oper; //更新上次操作符 &#125; if(oper==2)&#123; if(lastoper==1)&#123; sum=sum+temp; temp=a[j]; &#125; if(lastoper==2)&#123; sum=sum-temp; temp=a[j]; &#125; lastoper=oper; &#125; &#125; if(lastoper==1) //第九次操作单独处理 sum=sum+temp; if(lastoper==2) sum=sum-temp; if(sum==110) &#123; number=i; for(j=1;j&lt;=8;j++) &#123; printf(&quot;%d&quot;,a[j-1]); oper=number%3; number=number/3; if(oper==1) printf(&quot;+&quot;); if(oper==2) printf(&quot;-&quot;); else continue; &#125; printf(&quot;9\n&quot;); &#125; &#125; return 0;&#125; 运行结果]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
        <tag>警匪110</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Problem about Sending out death squads]]></title>
    <url>%2FProblem-about-Sending-out-death-squads.html</url>
    <content type="text"><![CDATA[问题描述 思路1、首先将所有士兵直属上级的编号放于数组a；2、每个人有两种选择，去和不去，用0和1表示，转换为二进制放于数组b；3、最后判断每个士兵是不是与其直属上级同时执行任务，进而对count进行统计。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;stdio.h&gt; #include &lt;math.h&gt; int main() &#123; int number; int count=0; int flag; scanf(&quot;%d&quot;,&amp;number);//派遣的人数 int i,j; int temp; int a[number],b[number];//a a[0]=0;//将军 for(i=1;i&lt;number;i++)&#123; scanf(&quot;%d&quot;,&amp;a[i]);//每个人的直属上级 &#125; for(i=1;i&lt;pow(2,number);i++)&#123; temp=i; for(j=0;j&lt;number;j++)&#123; //遍历所有情况 b[j]=temp%2; temp/=2; &#125; flag=1; for(j=1;j&lt;number;j++)&#123; //将军没有上级，不用判断 if(b[j]==1&amp;&amp;b[a[j]-1]==1)&#123; //判断是否士兵和上级同时执行任务 //b[j]为编号为j+1的士兵去不去 //b[a[j]-1]为编号为j+1的士兵的直接上级去不去 flag=0; break; &#125; &#125; if(flag==1) count++; &#125; printf(&quot;%d\n&quot;,count); return 0;&#125; 运行结果]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
        <tag>派遣敢死队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Problem about rollover price tag]]></title>
    <url>%2FProblem-about-rollover-price-tag.html</url>
    <content type="text"><![CDATA[问题描述 思路1、已知是一个四位数，那么共有1001-9999种情况；2、一个数颠倒之后，数字顺序颠倒并且每个数字颠倒，例如1269颠倒之后就是6921；3、0不能是第一位也不能是最后一位。 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;stdio.h&gt;#include&lt;math.h&gt;int array[4]=&#123;0&#125;;int inverse(int a)&#123;//求一个数颠倒之后的结果 int b=0; int arr[4]=&#123;0&#125;; for(int i=0;i&lt;4;i++)&#123; arr[i]=(int)(a/pow(10,3-i))%10; if(arr[i]==9) b+=6*pow(10,i); else if(arr[i]==6) b+=9*pow(10,i); else b+=arr[i]*pow(10,i); &#125; return b;&#125;int main()&#123; int i,j; int k=0,l=0; int temp; int flag; int up[50]=&#123;0&#125;,down[50]=&#123;0&#125;;//分别存放赚钱和赔钱的价牌 for(i=1001;i&lt;10000;i++)&#123; temp=i; flag=1; for(j=0;j&lt;4;j++)&#123; array[j]=(int)(temp/pow(10,3-j))%10; if(array[j]==3||array[j]==4||array[j]==7)&#123;//分割数字排除不能翻转的数字 flag=0; break; &#125; &#125; if(flag)&#123; if(array[0]==0 || array[3]==0)//0不能位于第一位和最后一位 continue; if(inverse(i)-i&gt;800&amp;&amp;inverse(i)-i&lt;900) up[k++]=i; if(i-inverse(i)&gt;200&amp;&amp;i-inverse(i)&lt;300) down[l++]=i; &#125; &#125; for(i=0;i&lt;50;i++)&#123;//依次输出赚钱的原价，颠倒价、赚的钱、赔钱的原价、颠倒价、赔的钱 for(j=0;j&lt;50;j++)&#123; if((inverse(up[i])-up[i])-(down[j]-inverse(down[j]))==558)&#123; printf(&quot;%d\t%d\t%d\t&quot;,up[i],inverse(up[i]),inverse(up[i])-up[i]); printf(&quot;%d\t%d\t%d\n&quot;,down[j],inverse(down[j]),down[j]-inverse(down[j])); &#125; &#125; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
        <tag>价牌翻转</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Allow apps downloaded from anywhere on macOS]]></title>
    <url>%2FAllow-apps-downloaded-from-anywhere-in-macOS.html</url>
    <content type="text"><![CDATA[Allow apps downloaded from anywhere on许多朋友升级到 macOS Sierra 后在”安全性与隐私”中找不到”任何来源”选项，这里我教给大家怎么打开”任何来源”。 打开终端，输入以下代码回车： 1sudo spctl --master-disable 会提示输入密码，根据提示输入密码回车之后就可以在”安全性与隐私”中打开”任何来源”选项了]]></content>
      <categories>
        <category>Hackintosh</category>
      </categories>
      <tags>
        <tag>Hacintosh</tag>
        <tag>黑苹果</tag>
        <tag>终端</tag>
        <tag>任何来源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Config NexT to beautify your blog with hexo]]></title>
    <url>%2FConfig-NexT-to-beautify-your-blog-with-hexo.html</url>
    <content type="text"><![CDATA[前言Hexo 是高效的静态站点生成框架，她基于 Node.js。 通过 Hexo 你可以轻松地使用 Markdown 编写文章，除了 Markdown 本身的语法之外，还可以使用 Hexo 提供的 标签插件 来快速的插入特定形式的内容。在这篇文章中，假定你已经成功安装了 Hexo，并使用 Hexo 提供的命令创建了一个站点。 在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。 为了描述方便，在以下说明中，将前者称为 站点配置文件， 后者称为 主题配置文件。 安装 NexTHexo 安装主题的方式非常简单，只需要将主题文件拷贝至站点目录的 themes 目录下， 然后修改下配置文件即可。具体到 NexT 来说，安装步骤如下。 下载主题在终端窗口下，定位到 Hexo 站点目录下。使用 Git checkout 代码：12$ cd your-hexo-site$ git clone https://github.com/iissnan/hexo-theme-next themes/next 启用主题与所有 Hexo 主题启用的模式一样。 当 克隆/下载 完成后，打开站点配置文件， 找到 theme 字段，并将其值更改为 next。 启用 NexT 主题 1theme: next 验证主题首先启动 Hexo 本地站点，并开启调试模式（即加上 –debug），整个命令是 hexo s –debug 。 在服务启动的过程，注意观察命令行输出是否有任何异常信息，如果你碰到问题，这些信息将帮助他人更好的定位错误。 当命令行输出中提示出： 1INFO hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop. 此时即可使用浏览器访问 http://localhost:4000 ，检查站点是否正确运行。 成功安装并启用了 NexT 主题后。下一步我们将要更改一些主题的设定，包括个性化以及集成第三方服务。 主题设定选择 SchemeScheme 是 NexT 提供的一种特性，借助于 Scheme，NexT 为你提供多种不同的外观。同时，几乎所有的配置都可以 在 Scheme 之间共用。目前 NexT 支持三种 Scheme，他们是： 123Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白Mist - Muse 的紧凑版本，整洁有序的单栏外观Pisces - 双栏 Scheme，小家碧玉似的清新 Scheme 的切换通过更改 主题配置文件，搜索 scheme 关键字。 你会看到有三行 scheme 的配置，将你需用启用的 scheme 前面注释 # 去除即可。 选择 Pisces Scheme 123#scheme: Muse#scheme: Mistscheme: Pisces 设置 语言编辑 站点配置文件， 将 language 设置成你所需要的语言。建议明确设置你所需要的语言，例如选用简体中文，配置如下： 1language: zh-Hans 目前 NexT 支持的语言如以下表格所示： 语言 代码 示例 English en language: en 简体中文 zh-Hans language: zh-Hans Français fr-FR language: fr-FR Português pt language: pt or language: pt-BR 繁體中文 zh-hk 或者 zh-tw language: zh-hk Русский язык ru language: ru Deutsch de language: de 日本語 ja language: ja Indonesian id language: id Korean ko language: ko 设置菜单菜单配置包括三个部分，第一是菜单项（名称和链接），第二是菜单项的显示文本，第三是菜单项对应的图标。 NexT 使用的是 Font Awesome 提供的图标， Font Awesome 提供了 600+ 的图标，可以满足绝大的多数的场景，同时无须担心在 Retina 屏幕下 图标模糊的问题。 编辑 主题配置文件，修改以下内容： 设定菜单内容，对应的字段是 menu。 菜单内容的设置格式是：item name: link。其中 item name 是一个名称，这个名称并不直接显示在页面上，她将用于匹配图标以及翻译。 菜单示例配置 1234567menu: home: / archives: /archives #about: /about #categories: /categories tags: /tags #commonweal: /404.html 若你的站点运行在子目录中，请将链接前缀的 / 去掉 NexT 默认的菜单项有 键值 设定值 显示文本 home home: / 主页 archives archives: /archives 归档页 categories categories: /categories 分类页 tags tags: /tags 标签页 about about: /about 关于页面 commonweal commonweal: /404.html 公益 404 2.设置菜单项的显示文本。在第一步中设置的菜单的名称并不直接用于界面上的展示。Hexo 在生成的时候将使用 这个名称查找对应的语言翻译，并提取显示文本。这些翻译文本放置在 NexT 主题目录下的 languages/{language}.yml （{language} 为你所使用的语言）。 以简体中文为例，若你需要添加一个菜单项，比如 something。那么就需要修改简体中文对应的翻译文件 languages/zh-Hans.yml，在 menu 字段下添加一项： 123456789menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 commonweal: 公益404 something: 有料 3.设定菜单项的图标，对应的字段是 menu_icons。 此设定格式是 item name: icon name，其中 item name 与上一步所配置的菜单名字对应，icon name 是 Font Awesome 图标的 名字。而 enable 可用于控制是否显示图标，你可以设置成 false 来去掉图标。 菜单图标配置示例 123456789menu_icons: enable: true # Icon Mapping. home: home about: user categories: th tags: tags archives: archive commonweal: heartbeat 在菜单图标开启的情况下，如果菜单项与菜单未匹配（没有设置或者无效的 Font Awesome 图标名字） 的情况下，NexT 将会使用 ? 作为图标。 请注意键值（如 home）的大小写要严格匹配 设置 侧栏默认情况下，侧栏仅在文章页面（拥有目录列表）时才显示，并放置于右侧位置。 可以通过修改 主题配置文件 中的 sidebar 字段来控制侧栏的行为。侧栏的设置包括两个部分，其一是侧栏的位置， 其二是侧栏显示的时机。 1.设置侧栏的位置，修改 sidebar.position 的值，支持的选项有： 12left - 靠左放置right - 靠右放置 目前仅 Pisces Scheme 支持 position 配置。影响版本5.0.0及更低版本。 12sidebar: position: left 2.设置侧栏显示的时机，修改 sidebar.display 的值，支持的选项有： post 默认行为，在文章页面（拥有目录列表）时显示 always 在所有页面中都显示 hide 在所有页面中都隐藏（可以手动展开） remove 完全移除 12sidebar: display: post 已知侧栏在 use motion: false 的情况下不会展示。 影响版本5.0.0及更低版本。 设置 头像编辑 主题配置文件， 修改字段 avatar， 值设置成头像的链接地址。其中，头像的链接地址可以是： 地址 值 完整的互联网URI http://example.com/avatar.png 站点内的地址 将头像放置主题目录下的 source/uploads/ (新建 uploads 目录若不存在)，配置为：avatar: /uploads/avatar.png；或者 放置在 source/images/ 目录下，配置为：avatar: /images/avatar.png 头像设置示例 1avatar: http://example.com/avatar.png 设置作者昵称编辑站点配置文件， 设置 author 为你的昵称。 站点描述编辑站点配置文件， 设置 description 字段为你的站点描述。站点描述可以是你喜欢的一句签名 : ) 主题配置设置 RSSNexT 中 RSS 有三个设置选项，满足特定的使用场景。 更改 主题配置文件，设定 rss 字段的值： 123false： 禁用 RSS，不在页面上显示 RSS 连接。留空： 使用 Hexo 生成的 Feed 链接。 你可以需要先安装 hexo-generator-feed 插件。具体的链接地址：适用于已经烧制过 Feed 的情形。 添加「标签」页面新建「标签」页面，并在菜单中显示「标签」链接。「标签」页面将展示站点的所有标签，若你的所有文章都未包含标签，此页面将是空的。 底下代码是一篇包含标签的文章的例子： 12345title: 标签测试文章tags: - Testing - Another Tag--- 请参阅 Hexo 的分类与标签文档，了解如何为文章添加标签或者分类。 新建页面在终端窗口下，定位到 Hexo 站点目录下。使用 hexo new page 新建一个页面，命名为 tags ： 12$ cd your-hexo-site$ hexo new page tags 设置页面类型编辑刚新建的页面，将页面的类型设置为 tags ，主题将自动为这个页面显示标签云。页面内容如下： 1234title: 标签date: 2014-12-22 12:39:04type: &quot;tags&quot;--- 在菜单中添加链接。编辑 主题配置文件 ， 添加 tags 到 menu 中，如下:1234menu: home: / archives: /archives tags: /tags 注意：如果有集成评论服务，页面也会带有评论。 若需要关闭的话，请添加字段 comments 并将值设置为 false，如： 禁用评论示例 12345title: 标签date: 2014-12-22 12:39:04type: &quot;tags&quot;comments: false--- 添加「分类」页面新建「分类」页面，并在菜单中显示「分类」链接。「分类」页面将展示站点的所有分类，若你的所有文章都未包含分类，此页面将是空的。 底下代码是一篇包含分类的文章的例子： 123title: 分类测试文章categories: Testing--- 请参阅 Hexo 的分类与标签文档，了解如何为文章添加标签或者分类。 新建页面在终端窗口下，定位到 Hexo 站点目录下。使用 hexo new page 新建一个页面，命名为 categories ： 12$ cd your-hexo-site$ hexo new page categories 设置页面类型编辑刚新建的页面，将页面的 type 设置为 categories ，主题将自动为这个页面显示分类。页面内容如下： 1234title: 分类date: 2014-12-22 12:39:04type: &quot;categories&quot;--- 修改菜单在菜单中添加链接。编辑 主题配置文件 ， 添加 categories 到 menu 中，如下: 1234menu: home: / archives: /archives categories: /categories 注意：如果有集成评论服务，页面也会带有评论。 若需要关闭的话，请添加字段 comments 并将值设置为 false，如： 禁用评论示例 12345title: 分类date: 2014-12-22 12:39:04type: &quot;categories&quot;comments: false--- 设置字体 注意： 此特性在版本 5.0.1 中引入，要使用此功能请确保所使用的 NexT 版本在此之后 为了解决 Google Fonts API 不稳定的问题，NexT 在 5.0.1 中引入此特性。 通过此特性，你可以指定所使用的字体库外链地址；与此同时，NexT 开放了 5 个特定范围的字体设定，他们是： 123456789全局字体：定义的字体将在全站范围使用标题字体：文章内标题的字体（h1, h2, h3, h4, h5, h6）文章字体：文章所使用的字体Logo字体：Logo 所使用的字体代码字体： 代码块所使用的字体各项所指定的字体将作为首选字体，当他们不可用时会自动 Fallback 到 NexT 设定的基础字体组：非代码类字体：Fallback 到 &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, sans-serif代码类字体： Fallback 到 consolas, Menlo, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, monospace 另外，每一项都有一个额外的 external 属性，此属性用来控制是否使用外链字体库。 开放此属性方便你设定那些已经安装在系统中的字体，减少不必要的请求（请求大小）。 配置示例 12345678910111213141516171819202122232425262728293031font: enable: true # 外链字体库地址，例如 //fonts.googleapis.com (默认值) host: # 全局字体，应用在 body 元素上 global: external: true family: Monda # 标题字体 (h1, h2, h3, h4, h5, h6) headings: external: true family: Roboto Slab # 文章字体 posts: external: true family: # Logo 字体 logo: external: true family: Lobster Two size: 24 # 代码字体，应用于 code 以及代码块 codes: external: true family: PT Mono 设置代码高亮主题NexT 使用 Tomorrow Theme 作为代码高亮，共有5款主题供你选择。 NexT 默认使用的是 白色的 normal 主题，可选的值有 normal，night， night blue， night bright， night eighties。 更改 highlight_theme 字段，将其值设定成你所喜爱的高亮主题，例如： 高亮主题设置示例 1234# Code Highlight theme# Available value: normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: normal 侧边栏社交链接侧栏社交链接的修改包含两个部分，第一是链接，第二是链接图标。 两者配置均在 主题配置文件 中。 1.链接放置在 social 字段下，一行一个链接。其键值格式是 显示文本: 链接地址。 配置示例 1234567# Social linkssocial: GitHub: https://github.com/your-user-name Twitter: https://twitter.com/your-user-name 微博: http://weibo.com/your-user-name 豆瓣: http://douban.com/people/your-user-name 知乎: http://www.zhihu.com/people/your-user-name 2.设定链接的图标，对应的字段是 social_icons。其键值格式是 匹配键: Font Awesome 图标名称， 匹配键 与上一步所配置的链接的 显示文本 相同（大小写严格匹配），图标名称 是 Font Awesome 图标的名字（不必带 fa- 前缀）。 enable 选项用于控制是否显示图标，你可以设置成 false 来去掉图标。 配置示例 1234567# Social Iconssocial_icons: enable: true # Icon Mappings GitHub: github Twitter: twitter 微博: weibo 开启打赏功能 由 habren 贡献越来越多的平台（微信公众平台，新浪微博，简书，百度打赏等）支持打赏功能，付费阅读时代越来越近，特此增加了打赏功能，支持微信打赏和支付宝打赏。 只需要 主题配置文件 中填入 微信 和 支付宝 收款二维码图片地址 即可开启该功能。 打赏功能配置示例 123reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！wechatpay: /path/to/wechat-reward-imagealipay: /path/to/alipay-reward-image 友情链接 由 iamwent 贡献编辑 主题配置文件 添加： 友情链接配置示例 12345# titlelinks_title: Linkslinks: MacTalk: http://macshuo.com/ Title: http://example.com/ 站点建立时间这个时间将在站点的底部显示，例如 © 2013 - 2015。 编辑 主题配置文件，新增字段 since。 配置示例 1since: 2013 设置「动画效果」NexT 默认开启动画效果，效果使用 JavaScript 编写，因此需要等待 JavaScript 脚本完全加载完毕后才会显示内容。 如果您比较在乎速度，可以将设置此字段的值为 false 来关闭动画。 编辑 主题配置文件， 搜索 use_motion，根据您的需求设置值为 true 或者 false 即可： 12use_motion: true # 开启动画效果use_motion: false # 关闭动画效果 设置「背景动画」NexT 自带两种背景动画效果 编辑 主题配置文件， 搜索 canvas_nest 或 three_waves，根据您的需求设置值为 true 或者 false 即可： 注意： three_waves 在版本 5.1.1 中引入。只能同时开启一种背景动画效果。 canvas_nest 配置示例 1234567# canvas_nestcanvas_nest: true //开启动画canvas_nest: false //关闭动画three_waves 配置示例# three_wavesthree_waves: true //开启动画three_waves: false //关闭动画 腾讯公益 404 页面 由 xirong 贡献腾讯公益404页面，寻找丢失儿童，让大家一起关注此项公益事业！ 效果如下 使用方法，新建 404.html 页面，放到主题的 source 目录下，内容如下： 123456789101112131415161718&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8;&quot;/&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot; /&gt; &lt;meta name=&quot;robots&quot; content=&quot;all&quot; /&gt; &lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://qzone.qq.com/gy/404/style/404style.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=&quot;text/plain&quot; src=&quot;http://www.qq.com/404/search_children.js&quot; charset=&quot;utf-8&quot; homePageUrl=&quot;/&quot; homePageName=&quot;回到我的主页&quot;&gt; &lt;/script&gt; &lt;script src=&quot;https://qzone.qq.com/gy/404/data.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://qzone.qq.com/gy/404/page.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Credits NexT基本使用转自官方说明文档]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>静态博客</tag>
        <tag>NexT</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Enable BCM94352z on your hacintosh]]></title>
    <url>%2FEnable-BCM94352z-on-hacintosh.html</url>
    <content type="text"><![CDATA[添加仿冒 ID 启用蓝牙：1config.plist -&gt; Device -&gt; FakeID -&gt; WIFI 中填写 0x43a014e4 在 Clover 的配置文件 config.plist -&gt; Kernel and Kext Patches 添加以下代码块12345678910111213141516&lt;dict&gt; &lt;key&gt;Comment&lt;/key&gt; &lt;string&gt;10.11+-BT4LE-Handoff-Hotspot-lisai9093&lt;/string&gt; &lt;key&gt;Disabled&lt;/key&gt; &lt;false/&gt; &lt;key&gt;Find&lt;/key&gt; &lt;data&gt; SIX/dEdIiwc= &lt;/data&gt; &lt;key&gt;Name&lt;/key&gt; &lt;string&gt;IOBluetoothFamily&lt;/string&gt; &lt;key&gt;Replace&lt;/key&gt; &lt;data&gt; Qb4PAAAA60Q= &lt;/data&gt;&lt;/dict&gt; 下载并安装驱动1234https://github.com/vit9696/Lilu/releaseshttps://bitbucket.org/RehabMan/os-x-fake-pci-id/downloads/ https://bitbucket.org/RehabMan/os-x-brcmpatchram/downloads/https://sourceforge.net/projects/airportbrcmfixup/files/?source=navbar 将以下驱动拷贝到 CLOVER/EFI/CLOVER/kexts/Other 文件夹下(由于 AirportBrcmFixup.kext 是依赖于 Lilu 运行的插件，所以还需要确保该目录下必须存在 Lilu.kext) 123456AirportBrcmFixup.kext FakePCIID.kext FakePCIID_Broadcom_WiFi.kext BrcmPatchRAM2.kext BrcmFirmwareData.kextLilu.kext 重建缓存123sudo rm -rf /System/Library/Caches/com.apple.kext.caches/Startup/kernelcachesudo rm -rf /System/Library/PrelinkedKernels/prelinkedkernelsudo touch /System/Library/Extensions/ &amp;&amp; sudo kextcache -u / 重启]]></content>
      <categories>
        <category>Hackintosh</category>
      </categories>
      <tags>
        <tag>Hacintosh</tag>
        <tag>黑苹果</tag>
        <tag>BCM94352z</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Problem about low-carbon lifestyle answering]]></title>
    <url>%2FProblem-about-low-carbon-lifestyle-answering.html</url>
    <content type="text"><![CDATA[问题描述某电视台举办了低碳生活大奖赛。题目的计分规则相当奇怪： 1、每位选手需要回答10个问题（其编号为1到10），越后面越有难度。答对的，当前分数翻倍；答错了则扣掉与题号相同的分数（选手必须回答问题，不回答按错误处理）。 2、每位选手都有一个起步的分数为10分。 某获胜选手最终得分刚好是100分，如果不让你看比赛过程，你能推断出他（她）哪个题目答对了，哪个题目答错了吗？ 3、如果把答对的记为1，答错的记为0，则10个题目的回答情况可以用仅含有1和0的串来表示。例如：0010110011 就是可能的情况。 4、你的任务是算出所有可能情况。每个答案占一行。 解题思路一共十个问题，每个问题两种情况，要么对要么错，那么结果就会有 0000000000 ~ 1111111111 = pow（2，10）种，就可以用暴力搜索将所有情况枚举出来然后判断符合要求的情况； 分数的控制可以直接利用遍历所有情况的 for 循环分别判断两种情况； 如果用输出 1 代表回答正确， 0 代表错误，不难想到任何一个正整数对 2 取余结果只有 1 和 0 两种情况， 输出的时候也就成了进制转换问题； 代码实现1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt; #include &lt;math.h&gt; int main() &#123; int i,j; int score,temp; for(i=0;i&lt;pow(2,10);i++)&#123; temp=i; score=10; for(j=0;j&lt;10;j++)&#123; if(temp%2 == 1) score*=2; else score-=j+1; temp/=2; &#125; if(score==100)&#123; temp=i; for(j=0;j&lt;10;j++)&#123; printf(&quot;%d &quot;, temp%2); temp/=2; &#125; printf(&quot;\n&quot;); &#125; &#125; return 0;&#125; 运行结果1231 0 1 1 0 1 0 0 0 0 0 1 1 1 0 1 0 0 0 0 0 0 1 0 1 1 0 0 1 1]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
        <tag>低碳生活答题问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The simplest case demo about client and server]]></title>
    <url>%2FThe-simplest-case-demo-about-client-and-server.html</url>
    <content type="text"><![CDATA[EchoClient.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/* * To change this license header, choose License Headers in Project Properties. * To change this template file, choose Tools | Templates * and open the template in the editor. */ package athlonreg.top;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.net.InetSocketAddress;import java.net.Socket;import java.net.SocketAddress;/** * * @author athlonreg */ public class EchoCilent &#123; /** * @param args the command line arguments */ public static void main(String[] args) &#123; // TODO code application logic here Socket clientSocket = null; BufferedReader in = null; BufferedWriter out = null; try &#123; //1.创建客户机套接字 clientSocket = new Socket(); SocketAddress remoteAddr=new InetSocketAddress(&quot;localhost&quot;,5000); System.out.println(&quot;1.创建客户机套接字成功！&quot;); //2.连接服务器 clientSocket.connect(remoteAddr); System.out.println(&quot;2.客户机连接服务器localhost端口5000成功！&quot;); System.out.println(&quot;客户机使用的地址和端口：&quot;+clientSocket.getLocalSocketAddress()); //与服务器会话 in = new BufferedReader( new InputStreamReader( clientSocket.getInputStream())); out = new BufferedWriter( new OutputStreamWriter( clientSocket.getOutputStream())); String sendStr=&quot;有朋自远方来&quot;; out.write(sendStr); //向服务器发送字符串 out.newLine(); out.flush(); System.out.println(&quot;3.1向服务器发送字符串成功!&quot;+sendStr); String recvStr=in.readLine(); //从服务器接收字符串 System.out.println(&quot;3.2从服务器接收回送字符串成功！&quot;+recvStr); &#125; catch (IOException ex) &#123; System.out.println(&quot;异常信息：&quot;+ex.getMessage()); &#125; //关闭套接字和流 try &#123; if (in != null) in.close(); if (out != null) out.close(); if (clientSocket != null) clientSocket.close(); System.out.println(&quot;4.关闭套接字和流成功！&quot;); &#125; catch (IOException ex) &#123; System.out.println(&quot;异常信息：&quot;+ex.getMessage()); &#125; &#125; &#125; EchoServer.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/* * To change this license header, choose License Headers in Project Properties. * To change this template file, choose Tools | Templates * and open the template in the editor. */ package athlonreg.top;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.net.InetSocketAddress;import java.net.ServerSocket;import java.net.Socket;import java.net.SocketAddress;/** * * @author athlonreg */ public class EchoServer &#123; /** * @param args the command line arguments * @throws java.io.IOException */ public static void main(String[] args) throws IOException &#123; // TODO code application logic here //1.启动服务器 ServerSocket listenSocket = null; Socket clientSocket = null; BufferedReader in = null; BufferedWriter out = null; try &#123; listenSocket = new ServerSocket(); SocketAddress serverAddr=new InetSocketAddress(&quot;localhost&quot;,5000); listenSocket.bind(serverAddr); System.out.println(&quot;1.服务器启动成功！开始在localhost的5000端口侦听连接...&quot;); //2.处理连接 clientSocket = listenSocket.accept(); System.out.println(&quot;2.客户机连接成功！客户机地址和端口：&quot;+clientSocket.getRemoteSocketAddress()); //3.与客户机会话 in = new BufferedReader( new InputStreamReader( clientSocket.getInputStream())); out = new BufferedWriter( new OutputStreamWriter( clientSocket.getOutputStream())); String recvStr=in.readLine(); //从客户机接收字符串 System.out.println(&quot;3.1 服务器收到字符串：&quot;+recvStr); out.write(recvStr); //向客户机回送字符串 out.newLine(); out.flush(); System.out.println(&quot;3.2 服务器回送字符串成功：&quot;+recvStr); &#125; catch (IOException ex) &#123; System.out.println(&quot;异常信息：&quot;+ex.getMessage()); &#125; //4.关闭套接字和流 try &#123; if (in != null) in.close(); if (out != null) out.close(); if (listenSocket != null) listenSocket.close(); if (clientSocket != null) clientSocket.close(); System.out.println(&quot;4.关闭套接字和流成功！&quot;); &#125; catch (IOException ex) &#123; System.out.println(&quot;异常信息&quot;+ex.getMessage()); &#125; &#125; &#125;]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>网络编程</tag>
        <tag>客户机与服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Speed up the hackintosh to boot]]></title>
    <url>%2FSpeed-up-the-hackintosh-to-boot.html</url>
    <content type="text"><![CDATA[知识普及有的黑苹果重启速度特别慢（大约2、3分钟），这问题多半与Clover的 Reset Address 与 Reset Value 有关 ( 这里只针对 Clover ) 。 这个问题和 Reset Address 与 Reset Value 参数有关，这两个参数位于 Clover Configurator 的Acpi部分左下方。如果什么都不填默认值分别为：0x64与0xFE，即：重启通过PS控制器完成，PS控制器只有黑苹果才有，白苹果则是通过PCI实现，所以，如果你的电脑恰好也是通过PCI控制，那么就会有问题了。针对PCI这两个值应该填写：0x0CF9与0x06。 当然，还有一种更精确找到该值的办法，就是我们要用到的唯一一个表单，就是FACP这个表。 准备工作首先利用 CLOVER 在引导界面按 F4 或者 Fn+F4 提取原始 ACPI 表单，提取出来的表单就在 /EFI/CLOVER/ACPI/origin 开工提取 Reset Address 和 Reset Value 值用 MaciASL 打开 FACP 这个表单，Command + F 搜索 Reset Register ， Address 值和 Value to cause reset 值就是我们所说的 PCI 需要设定的两个值，如图高亮处： 设定Reset Address 和 Reset Value 值提取出来这两个值后就要修改 config 了，用 Clover Configurator 打开你的 config ，如图位置填上提取到的两个值： 保存重启就可以了. 完工]]></content>
      <categories>
        <category>Hackintosh</category>
      </categories>
      <tags>
        <tag>Hacintosh</tag>
        <tag>黑苹果</tag>
        <tag>开机速度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Check CPU frequences by using AppleIntelInfo]]></title>
    <url>%2FCheck-CPU-frequences-by-using-AppleIntelInfo.html</url>
    <content type="text"><![CDATA[前言很多朋友在查看自己机器变频时利用 CPU-S 发现并不准确，这里我教给大家一种比较准确的方法—-利用 AppleIntelInfo 查看变频 开工首先下载 AppleIntelInfo 源码编译，打开终端，输入：1cd ~/Desktop 回车继续敲： 1git clone https://github.com/athlonreg/AppleIntelInfo.git 回车后就把 AppleIntelInfo 源码下载在桌面了 然后打开 AppleIntelInfo 的工程文件进行编译生成 .kext 内和扩展文件，这一部分这里不再赘述，如果不会的话参考我的另一个帖子，里面有提到，链接在这(后面的汉字也是地址的一部分哦)： 1http://athlonreg.top/2017/08/31/解决Lilu造成的一些问题/ 将编译后的 AppleIntelInfo.kext 放到桌面 然后开始利用命令行看变频数据打开终端，输入： 1cd ~/Desktop 回车后继续敲 1sudo chown -R root:wheel AppleIntelInfo.kext 回车会提示输入密码，输入之后回车继续敲： 1sudo kextutil AppleIntelInfo.kext 再回车，接着敲： 1sudo cat /tmp/AppleIntelInfo.dat 回车之后变频数据就出来了，例如我的机器： 一般我们只看最后一行就可以了哦 比如我的机器就是 800、 1000、 …… 、 2700 ，单位是MHz，正好符合我的机器，最低 800MHz ，最高2.4GHz，可超频到2.7GHz。 完工行胜于言，快去试试你的机器是不是变频正常吧！！]]></content>
      <categories>
        <category>Hackintosh</category>
      </categories>
      <tags>
        <tag>Hacintosh</tag>
        <tag>黑苹果</tag>
        <tag>AppleIntelInfo</tag>
        <tag>变频</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[How to use xcode-select in terminal]]></title>
    <url>%2FHow-to-use-xcode-select-in-terminal.html</url>
    <content type="text"><![CDATA[It’s not uncommon developers to have multiple versions of Xcode installed. For example, I typically have the latest beta as well as the most current production release installed.However, there are times when you may want various tools, such as xcodebuild, to point to a specific Xcode folder. To faciliate this, you can use xcode-select. A common use case is if you use scripts and/or makefiles to build your projects.Once you set the Xcode folder, xcodebuild will be invoked from the folder you specified.The command line options are below: 1234xcode-select [-help]xcode-select [-switch xcode_folder_path]xcode-select [-print-path]xcode-select [-version] Here is how to print the current Xcode path:12$ xcode-select --print-path/Developer/Applications/Xcode.app Line number 2 shows the current version of Xcode that is ‘active.’ If you are accessing xcodebuild or other related tools from a script, –print-path is the preferred means to determine the current Xcode location.Use the -switch option to change to another version of Xcode on your system: 1$ sudo xcode-select --switch /Applications/Xcode-beta.app/Contents/Developer This changes to the Xcode-beta 9 on my system. Note that root access is required to set the Xcode location, thus I have used sudo to execute the command as root.Printing the path now looks as follows: 12$ xcode-select --print-path/Applications/Xcode-beta.app/Contents/Developer To switch back to Xcode installed in the /Applications directory:1$ sudo xcode-select -switch /Applications/Xcode.app/ You can read more about xcode-select by view the man page from a terminal:1$ man xcode-select]]></content>
      <categories>
        <category>Hackintosh</category>
      </categories>
      <tags>
        <tag>终端</tag>
        <tag>Mac</tag>
        <tag>Xcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Problem about coin array]]></title>
    <url>%2FProblem-about-coin-array.html</url>
    <content type="text"><![CDATA[问题描述有m*n枚金币在桌面上排列成一个m行n列的金币阵列。每一枚金币或正面朝上，或背面朝上。用数字表示金币状态，0表示正面朝上，1表示背面朝上。 金币阵列游戏的规则1、每次将任一行金币翻过来放在原来的位置上;2、每次可以任选2列，交换这2列金币的位置. 任务给定金币的初始状态和目标状态，编程计算按金币游戏规则，将金币排列从初始状态变换到目标状态所需的最少变换次数。 思路本例的实质是将一个二进制矩阵从一种形式利用相应规则变换到另一种形式。提供的规则有两种：1、将某一行的金币翻转;2、将某两列进行交换。 在这两种操作中，第一种操作可能会影响到某一行或者某一列中已经排列好的相关元素，因此，首先利用该规则进行变换，而后续的操作则不再利用该规则。 那么在程序中应该如下操作：1、将矩阵中的每一列作为第1列，并利用第一个规则将第1列中的相关元素与目标矩阵中第1列的元素进行配对，如果不相同，则利用每1个规则进行翻转； 2、从第2列开始，将处理后的列与目标列进行比较，如果相同，则转下一列；如果不同，看是否可以通过列的交换完成，如果可以，则继续扫描，否则无解。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;stdio.h&gt;#define row 4#define col 3int source[row][col] = &#123;1,0,1,0,0,0,1,1,0,1,0,1&#125;; //sourceint target[row][col] = &#123;1,0,1,1,1,1,0,1,1,1,0,1&#125;; //targetint temparr[row][col];nt number = 0; //转换的次数int minnum = 9999;void raw_change(int i) &#123; //行翻转 int j; for(j=0; j&lt;col; j++) &#123; temparr[i][j] = 1-temparr[i][j]; &#125; number++;&#125;void col_exchange(int i, int j) &#123; //列交换 int temp, k; int temp, k; for(k=0; k&lt;row; k++) &#123; temp = temparr[k][i]; temparr[k][i] = temparr[k][j]; temparr[k][j] = temp; &#125; if(i != j) number++; &#125;int judge(int i, int j) &#123; //temparr的i列是否和target的j列相同 int flag; for(int k=0; k&lt;row; k++) &#123; flag=1; if(temparr[k][i] != target[k][j]) &#123; flag=0; break; &#125; &#125; return flag;&#125;int main() &#123; // insert code here... int i,j,k; for(i=0; i&lt;col; i++) &#123; //代表source的列 for(j=0; j&lt;row; j++) &#123; for(k=0; k&lt;col; k++) &#123; temparr[j][k] = source[j][k]; //给替身数组赋值 &#125; &#125; number=0; col_exchange(0,i); //temparr数组的列先做交换，把其他列放到第一列的位置 for(j=0; j&lt;row; j++) &#123; //判断temparr的0号列和target的0号列是否相同，不同则翻转 if(temparr[j][0] != target[j][0]) &#123; raw_change(j); //如果第1列不匹配，那么行全部翻转 &#125; &#125; int found; for(j=0; j&lt;col; j++) &#123; //代表target，从第2行开始，到最后一行 found=0; for(k=j; k&lt;col; k++) &#123; //代表temparr，从第2行开始，直到最后一行 if(judge(k, j)) &#123; found=1; col_exchange(k, j); break; &#125; &#125; if(!found) &#123; break; &#125; &#125; if(found) &#123; minnum=number; &#125; &#125; if(minnum&lt;9999) &#123; printf(&quot;一共变换%d次！\n&quot;, minnum); &#125; else&#123; printf(&quot;无解！\n&quot;); &#125; return 0;&#125;]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
        <tag>金币阵列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Problem about dictionary order]]></title>
    <url>%2FProblem-about-dictionary-order.html</url>
    <content type="text"><![CDATA[问题描述在数据加密和数据压缩中常需要对特殊的字符串进行编码。给定的字母表A由26个小写字母组成。该字母表产生的升序字符串中字母从左到右出现的次序与字母在字母表中出现的次序相同，且每个字符最多出现1次。例如，a,b,ab,bc,xyz等字符串都是升序字符串。现在对字母表中产生的所有长度不超过6的升序字符串，计算它在字典中的编码。 思路首先判断字符串长度为3，先算长度为1和2的所有情况，即从26个字母中选1个或两个字母，因为是升序，即sum=C（26，1）+C（26，2）； 之后再看字符串的第一个字符，为’d’,之前有以a,b,c开头的长度为3的字符串，以a开头，后边2位需要在25个字母中选择（除了a），以b开头的后2位需要在24个字母中选择（除了a,b），以c开头的在23个字母（除了a,,b,c）中选择，即sum+=(C(25,2)+C(24,2)+C(23,2)); 然后再看下一个字母’g’，d与g之间有e,f,需要算以de开头以及以df开头的所有情况，即sum+=(C(21,1)+C(20,1))； 最后再加上h-‘a’+1; 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#include &lt;string.h&gt;int getCombinatorialNumber(int m, int n) &#123; int n_Product=1, m_Product=1; int i; for(i=1; i&lt;=n; i++) n_Product*=i; for(i=m; i&gt;m-n; i--) &#123; m_Product*=i; return m_Product/n_Product; &#125;&#125;int main(int argc, const char * argv[]) &#123; int number; //要统计字符串的个数 int sum; //存放字符串的序号 int length; char str[10]; //存放字符串 int a[10]; //存放字符串的每一位字符的值 int i, j; scanf(&quot;%d&quot;, &amp;number); while(number--) &#123; getchar(); sum=1; scanf(&quot;%s&quot;, str); length=(int)strlen(str); for(i=1; i&lt;length; i++) &#123; sum += getCombinatorialNumber(26, i); //小于字符串长度的字符串个数 &#125; for(i=0; i&lt;length; i++) &#123; a[i]=str[i]-96; //计算每个字符从a开始的序号数值, a~z分别对应1~26 //printf(&quot;%d &quot;, a[i]); &#125; //printf(&quot;%d\n&quot;, f(26, 2)); int temp=1; for(i=length; i&gt;0; i--) &#123; for(j=temp; j&lt;a[length-i]; j++) &#123; sum += getCombinatorialNumber(26-j, i-1); //依次扫描字符，计算所有情况 &#125; temp=a[length-i]+1; &#125; printf(&quot;%d\n&quot;, sum); &#125; return 0;&#125;]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
        <tag>字典序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Extract and fix DSDT SSDT simply]]></title>
    <url>%2FExtract-and-fix-DSDT-SSDT-simply.html</url>
    <content type="text"><![CDATA[开工准备工作首先在 CLOVER 引导界面按 F4 或者 FN + F4 提取原始表单，然后进入 Mac ，利用 Clover Configurator 挂载ESP分区，提取的表单就在 /EFI/CLOVER/ACPI/origin ,将 origin 整个拷贝到桌面，并删除 origin 中除 DSDT SSDT 以外的所有文件 然后下载要用到的工具 12iasl：https://bitbucket.org/RehabMan/acpica/downloads/MaciASL：链接:http://pan.baidu.com/s/1pKAksR5 密码:nxyr 将 iasl 放到 /usr/bin 然后安装 MaciASL 并添加补丁源： Rehabman 补丁源： 12Name：RehabMan Laptop URL：http://raw.github.com/RehabMan/Laptop-DSDT-Patch/master 打开终端，输入： 1cd ~/Desktop/origin 回车 然后输入: 1iasl –da –dl *.aml 回车 这时打开桌面的 origin 文件夹会发现多出了很多 .dsl 文件，我们要用到的就是这些文件 先不要急，终端继续执行 1rm –rf *.aml 回车 然后执行: 1rm –rf *x.dsl 回车，这时就会发现终端只剩下了不带 x 的 dsl 文件 开始操作然后用 MaciASL 打开 DSDT.dsl 点 Compile 编译后会弹出错误的窗口： 点这些错误就会定位到错误的代码位置 这里说一下常见的错误修复方法: 1、 PARSEOP_ZERO 错误，定位后会发现一堆 zero 代码，直接将他们删掉即可2、 Unexpected ‘}’ 错误： 定位后是这样： 我们会发现这个错误位于 ADBG 的方法下，这时只需打个补丁即可： 点Patch 找到 Fix ADBG Error 点一下，然后 Apply 应用即可，这时我们会发现再编译就没有错误了(警告可以不用管)，然后保存成aml文件 Save 即可，其他 SSDT 文件也是一样的操作 修改完成在修改完所有表单的错误并保存成aml格式后，将这些 aml 文件放到 /EFI/CLOVER/ACPI/patched 就可以了 完工]]></content>
      <categories>
        <category>Hackintosh</category>
      </categories>
      <tags>
        <tag>DSDT</tag>
        <tag>SSDT</tag>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Statistical problem]]></title>
    <url>%2FStatistical-problem.html</url>
    <content type="text"><![CDATA[问题描述一本书的页码从自然数 1 开始计数，直到自然数 n 。书的页码按照通常的习惯编排，每个页码都不包含多余的前导数字 0 。例如，第 6 页用数字 6 表示，而不是 06 或 006 等。数字计数问题要求对给定书的总页码 n ，计算出书的全部页码中分别用到多少次数字 0，1，2，…，9 。 思路:暴力求解。本题关键在于将每一页码的数字进行分解，这种方式可以利用整数的除法和对10取余计算。 代码实现123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;#include &lt;math.h&gt; int main(int argc, const char * argv[]) &#123; // insert code here... int array[10] = &#123;0&#125;; //存放0~9出现的次数 int low, temp, high; //以temp为分割点 将页数分为三部分 high和low分别代表高位和低位的数值 int paginations; //存放总页数 int i, j; printf(&quot;一共多少页: &quot;); scanf(&quot;%d&quot;, &amp;paginations); int count = 0; //存放除去最高位后总页码的位数 count = (int)log10(paginations); for(i = count; i &gt;= 0; i --) &#123; //i表示低位（low）的位数 low = paginations % (int)pow(10, i); //计算low的数值 temp = paginations / (int)pow(10, i) % 10; //计算temp的数值 high = paginations / (int)pow(10, i + 1); //计算high的数值 for(j = 0; j &lt; temp; j ++) array[j] += (high + 1) * pow(10, i); //计算 0&lt;中间位&lt;temp 出现的次数 array[temp] += high * pow(10, i) + low + 1; //计算 中间位=temp 出现的次数 for(j = temp + 1; j &lt; 10; j ++) //计算 temp&lt;中间位&lt;9 出现的次数 array[j] += high * pow(10, i); &#125; for(i = count; i &gt;= 0; i --) //除去多统计的a[0]出现的次数 array[0] -= pow(10, i); printf(&quot;0~9分别出现的次数为:\n&quot;); for(i = 0; i &lt; 10; i ++) //打印0~9分别出现的次数 printf(&quot;%d\n&quot;, array[i]); return 0;&#125;]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
        <tag>统计数字</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Install jdk on macOS]]></title>
    <url>%2FInstall-jdk-on-macOS.html</url>
    <content type="text"><![CDATA[安装 jdkMac系统自带jdk，但是版本比较老，我们可以去官网下载最新的Jdk，安装比较简单，这里不再赘述。 配置 jdk 环境变量打开终端输入 vim ~/.bash_profile 回车，然后按i进入编辑模式，在最后面输入以下内容： 1234567JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_60.jdk/Contents/HomePATH=$JAVA_HOME/bin:$PATH:.CLASSPATH=JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar:.export JAVA_HOMEexport PATHexport CLASSPATH 按下 esc ，然后输入 :wq 回车，保存退出 然后输入 source ~/.bash_profile 回车文件修改就生效了。 输入 java -version 回车可以查看 Java 版本，whereis java 可以查看 Java 位置，echo $JAVA_HOME 可以打印出 JAVA_HOME 。 安装eclipse为了更方便的进行开发工作，我们还需要安装Eclipse，去官网下载完成后解压，把.app文件拖进应用程序(Application)就可以了，然后创建一个workspace，也就是工作目录，用来存放工作代码。]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Java</tag>
        <tag>搭建</tag>
        <tag>环境</tag>
      </tags>
  </entry>
</search>
