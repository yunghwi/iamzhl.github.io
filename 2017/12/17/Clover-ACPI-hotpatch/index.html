<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">






  
  
  <link rel="stylesheet" media="all" href="/lib/Han/dist/han.min.css?v=3.3">




<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.proxy.ustclug.org/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hacintosh,SSDT,hotpatch,ACPI," />





  <link rel="alternate" href="/atom.xml" title="Athlonreg's Blog" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />





<script>
  (function(){
    if(''){
      if(prompt('请输入文章密码') !== ''){
        alert('密码错误!');
        history.back();
      }
    }
  })();
</script>

<meta name="description" content="Using Clover to &quot;hotpatch&quot; ACPI">
<meta name="keywords" content="Hacintosh,SSDT,hotpatch,ACPI">
<meta property="og:type" content="article">
<meta property="og:title" content="Clover ACPI hotpatch">
<meta property="og:url" content="http://yoursite.com/2017/12/17/Clover-ACPI-hotpatch/index.html">
<meta property="og:site_name" content="Athlonreg&#39;s Blog">
<meta property="og:description" content="Using Clover to &quot;hotpatch&quot; ACPI">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2017-12-17T11:02:19.394Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Clover ACPI hotpatch">
<meta name="twitter:description" content="Using Clover to &quot;hotpatch&quot; ACPI">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.2',
    sidebar: {"position":"left","display":"hide","offset":12,"offset_float":12,"b2t":true,"scrollpercent":true,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/12/17/Clover-ACPI-hotpatch/"/>





  <title>Clover ACPI hotpatch | Athlonreg's Blog</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?41fc030db57d5570dd22f78997dc4a7e";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <a href="https://github.com/athlonreg"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/a6677b08c955af8400f44c6298f40e7d19cc5b2d/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f677261795f3664366436642e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_gray_6d6d6d.png"></a>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Athlonreg's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">套陆的博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/17/Clover-ACPI-hotpatch/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="athlonreg/套陆">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Athlonreg's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Clover ACPI hotpatch</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-17T15:30:15+08:00">
                2017-12-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Hacintosh/" itemprop="url" rel="index">
                    <span itemprop="name">Hacintosh</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/12/17/Clover-ACPI-hotpatch/" class="leancloud_visitors" data-flag-title="Clover ACPI hotpatch">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">热度&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
                 <span>℃</span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  16,997 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  105 分钟
                </span>
              
            </div>
          

          
              <div class="post-description">
                  Using Clover to "hotpatch" ACPI
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        <h3 id="Preface–序言"><a href="#Preface–序言" class="headerlink" title="Preface–序言"></a>Preface–序言</h3><p>This blog is created by me to introduce how to using Clover to hotpatch ACPI，and provide an Chinese version。</p>
<blockquote>
<p>我写这篇博客是为了介绍如何使用<code>Clover</code>对<code>ACPI</code>使用<code>hotpatch</code>，并翻译原贴提供中文参考帖。</p>
</blockquote>
<h3 id="Brief-description-for-hotpatch–hotpatch概要"><a href="#Brief-description-for-hotpatch–hotpatch概要" class="headerlink" title="Brief description for hotpatch–hotpatch概要"></a>Brief description for hotpatch–<code>hotpatch</code>概要</h3><p>In RehabMan’s GitHub homepage, a repository named <code>OS-X-Clover-Laptop-Config</code> Contains some Clover <code>config.plist</code> for common Intel graphics and hotpatch for common configurations.More information in <a href="https://github.com/RehabMan/OS-X-Clover-Laptop-Config" target="_blank" rel="external">here</a>.</p>
<blockquote>
<p><code>RehabMan</code>的<code>GitHub</code>有一个仓库–<code>OS-X-Clover-Laptop-Config</code>,里面包含了一些适用于常见的英特尔核芯显卡的<code>config.plist</code>,还有<code>hotpatch</code>。点击<a href="https://github.com/RehabMan/OS-X-Clover-Laptop-Config" target="_blank" rel="external">这里</a>了解更多。</p>
</blockquote>
<p>There are some handy SSDTs for use with Clover ACPI hotpatch (in conjunction with hotpatch/config.plist) If you understand ACPI, you may find the SSDTs and hotpatch/config.plist quite useful.</p>
<blockquote>
<p>这儿有许多针对使用Clover ACPI hotpatch(连同使用hotpatch/config.plist)的SSDT。如果你理解了ACPI，你会发现这些<code>SSDT</code>和<code>hotpatch/config.plist</code>相当重要。</p>
</blockquote>
<p>Read here for the hotpatch guide: <a href="https://www.tonymacx86.com/threads/guide-using-clover-to-hotpatch-acpi.200137/" target="_blank" rel="external">https://www.tonymacx86.com/threads/guide-using-clover-to-hotpatch-acpi.200137/</a></p>
<blockquote>
<p>这里是<code>hotpatch</code>的‘入门引导贴。<br><a href="https://www.tonymacx86.com/threads/guide-using-clover-to-hotpatch-acpi.200137/" target="_blank" rel="external">https://www.tonymacx86.com/threads/guide-using-clover-to-hotpatch-acpi.200137/</a></p>
</blockquote>
<h4 id="A-brief-description-of-each-hotpatch-SSDT-is-provided-below–下面是每一个-hotpatch-SSDT-的概要"><a href="#A-brief-description-of-each-hotpatch-SSDT-is-provided-below–下面是每一个-hotpatch-SSDT-的概要" class="headerlink" title="A brief description of each hotpatch SSDT is provided below–下面是每一个 hotpatch SSDT 的概要"></a>A brief description of each hotpatch SSDT is provided below–下面是每一个 <code>hotpatch SSDT</code> 的概要</h4><p><code>SSDT-Config.dsl</code>: This file provides configuration data for other SSDTs. Read the comments within the file for more information.</p>
<blockquote>
<p><code>SSDT-Config.dsl</code>:这个文件为其他<code>SSDT</code>提供参数。请阅读文件中的注释以获得更多信息。</p>
</blockquote>
<p><code>SSDT-Debug.dsl</code>: This SSDT is for use with ACPIDebug.kext. Instead of patching your DSDT to add the RMDT device, you can use this SSDT and refer to the methods with External. See ACPIDebug.kext documentation for more information regarding the RMDT methods.</p>
<blockquote>
<p>这个<code>SSDT</code>和<code>ACPIDebug.kext</code>一起使用。不需要对你的<code>DSDT</code>打补丁增加<code>RMDT</code>设备，你可以使用这个<code>SSDT</code>通过<code>External</code>导入这个方法。关于<code>RMDT</code>方法，要了解更多请参阅<code>ACPIDebug.kext</code>文档。</p>
</blockquote>
<p><code>SSDT-XOSI.dsl</code>: This SSDT provides the XOSI method, which is a replacement for the system provided _OSI object when the _OSI-&gt;XOSI patch is being used. This is actually one of the examples in the Clover ACPI hotpatch guide, linked above.</p>
<blockquote>
<p>这个<code>SSDT</code>提供了<code>XOSI</code>方法，当打了<code>_OSI-&gt;XOSI</code>补丁时，<code>XOSI</code>方法会替换系统提供的<code>_OSI</code>对象。实际上，这就是<code>Clover ACPI hotpatch</code>入门参考帖的一个例子，链接在下面。</p>
</blockquote>
<p>SSDT-IGPU.dsl This SSDT injects Intel GPU properties depending on the configuration data in SSDT-Config and the device-id that is discovered to be present on the system. It assumes the IGPU is named IGPU (typical is GFX0, requring GFX0-&gt;IGPU rename). Configured with RMCF.TYPE, RMCF.HIGH, RMCF.IGPI, and SSDT-SkylakeSpoof.aml.</p>
<blockquote>
<p>这个<code>SSDT</code>根据<code>SSDT-config</code>的配置数据和系统中发现的设备id注入了Intel GPU–核芯显卡属性。它假定<code>IGPU</code>被命名成<code>IGPU</code>(通常是<code>GFX0</code>，需要重命名<code>GFX0-&gt;IGPU</code>)。通过<code>RMCF.TYPE, RMCF.HIGH, RMCF.IGPI, and SSDT-SkylakeSpoof.aml</code>来配置。</p>
</blockquote>
<p><code>SSDT-SkylakeSpoof.aml</code>: This SSDT is an optional SSDT that can be paired with SSDT-IGPU.dsl. When present, SSDT-IGPU uses the data within as an override for various KabyLake graphics devices which spoofs those devices as Skylake. Prior to 10.12.6, Skylake spoofing is the only option for KabyLake graphics. And even with 10.12.6 (or later, including 10.13.x), it still may be useful to spoof KabyLake graphics as Skyake. Keep in mind complete Skylake spoofing requires FakePCIID.kext + FakePCIID_Intel_HD_Graphics.kext.</p>
<blockquote>
<p>这个<code>SSDT</code>是一个可选的<code>SSDT</code>,它可以配合<code>SSDT-IGPU.dsl</code>使用。<code>SSDT-IGPU</code>使用这些数据对<code>KabyLake</code>图形设备的数据进行覆盖重写，把<code>KabyLake</code>仿冒成<code>Skylake</code>。10.12.6之前,<code>KabyLake</code>只有仿冒成’SkyLake’驱动核显，即使在10.12.6之后(或者更新的版本，包括10.13.x)，将<code>KabyLake</code>仿冒成’SkyLake’仍然是很有用的，需要注意的是完整的仿冒需要<code>FakePCIID.kext + FakePCIID_Intel_HD_Graphics.kext</code>。</p>
</blockquote>
<p>SSDT-IMEI.dsl This SSDT injects fake device-id as required for IMEI when using mixed HD3000/7-series or HD4000/6-series. Be sure to read the comments within carefully, as customization is required if your system already has an IMEI identity in ACPI.</p>
<p>SSDT-PNLF.dsl This SSDT injects a PNLF device that works with IntelBacklight.kext or AppleBacklight.kext. Configured with RMCF.BKLT, RMCF.LMAX, RMCF.FBTP. See guide for more information: <a href="https://www.tonymacx86.com/threads/guide-laptop-backlight-control-using-applebacklightinjector-kext.218222/" target="_blank" rel="external">https://www.tonymacx86.com/threads/guide-laptop-backlight-control-using-applebacklightinjector-kext.218222/</a></p>
<p>SSDT-LPC.dsl This SSDT injects properties to force AppleLPC to load for various unsupported LPC device-ids. It assumes the LPC device is named LPCB.</p>
<p>SSDT-SATA.dsl This SSDT injects properties (fake device-id, compatible) to enable the SATA controller with certain unsupported SATA controllers. It assumes the SATA device is named SATA (typical is SAT0, thus requiring SAT0-&gt;SATA rename).</p>
<p>SSDT-Disable_DGPU.dsl This SSDT provides an _INI method that will call _OFF for a couple of common paths for a discrete GPU in a switched/dual GPU scenario. This SSDT can work to disable the Nvidia or AMD graphics device, if the path matches (or is modified to math) and your _OFF method code path has no EC related code. Refer to the hotpatch guide for a complete example.</p>
<p>SSDT-SMBUS.dsl This SSDT injects the missing DVL0 device. Mostly used with Sandy Bridge and Ivy Bridge systems.</p>
<p>SSDT-GPRW.dsl and SSDT-UPRW.dsl This SSDT is used in conjuction with the GPRW-&gt;XPRW or UPRW-&gt;XPRW patch. Used together this SSDT can fix “instant-wake” by disabling “wake on USB”. It overrides the _PRW package return for GPE indexes 0x0d or 0x6d. Potential companion patches are provided in hotpatch/config.plist</p>
<p>SSDT-LANC_PRW.dsl Also part of fixing “instant wake”, but this is for _PRW on the Ethernet device. Potential companion patches are provided in hotpatch/config.plist.</p>
<p>SSDT-PTSWAK.dsl This SSDT provides overrides for both _PTS and _WAK. When combined with the appropriate companion patches from hotpatch/config.plist, these methods can provide various fixes. The actions are controlled by RMCF.DPTS, RMCF.SHUT, RMCF.XPEE, RMCF.SSTF. Refer to SSDT-Config.dsl for more information on those options.</p>
<p>SSDT-Disable_EHCI.dsl This SSDT can disable both EHCI controllers. It is assumed both have been renamed to EH01/EH02 (typically original names are EHC1/EHC2)</p>
<p>SSDT-Disable_EH01.dsl, SSDT-Disable_EH02.dsl Each of these SSDTs is just SSDT-Disable_EHCI.dsl broken down to only disable EH01 or only EH02. Use as appropriate depending on which EHCI controllers are active/present in your ACPI set.</p>
<p>SSDT-XWAK.dsl, SSDT-XSEL.dsl, SSDT-ESEL.dsl Each of these SSDTs provides an empty XWAK, XSEL, and ESEL methods (respectively). Use with the appropriate companion patch from hotpatch/config.plist. Typically, these methods are disabled (by having no code in them) to disable certain actions native ACPI may be doing on wake from sleep or during startup that cause problems with the xHCI/EHCI configuration.</p>
<p>SSDT-PluginType1.dsl This SSDT injects “plugin-type”=1 on CPU0. It assumes ACPI Processor objects are in Scope(_PR). It can be used to enable native CPU power management on Haswell and later CPUs. See guide for more information: <a href="https://www.tonymacx86.com/threads/guide-native-power-management-for-laptops.175801/" target="_blank" rel="external">https://www.tonymacx86.com/threads/guide-native-power-management-for-laptops.175801/</a></p>
<p>SSDT-HDEF.dsl and SSDT-HDAU Injects layout-id, hda-gfx, and PinConfiguration properties on HDEF and HDAU in order to implement audio with patched AppleHDA.kext Configured with: RMCF.AUDL</p>
<p>SSDT-EH01.dsl, SSDT-EH02.dsl, and SSDT-XHC.dsl These SSDTs inject USB power properties and control over FakePCIID_XHCIMux (dending on SSDT-Disable_EH*.dsl).</p>
<p>SSDT-ALS0.dsl Injects a fake ALS device (ambient light sensor). This SSDT is used to fix problems with restoring brightness upon reboot.</p>
<p>Introduction</p>
<p>Patching ACPI is always necessary to enable (near) full functionality when installing OS X on non-Apple hardware.</p>
<p>There is a complete guide here: <a href="http://www.tonymacx86.com/threads/guide-patching-laptop-dsdt-ssdts.152573/" target="_blank" rel="external">http://www.tonymacx86.com/threads/guide-patching-laptop-dsdt-ssdts.152573/</a></p>
<p>That guide uses what is known as “static patching”. In order to inject patched ACPI files, we extract native ACPI, disassemble them, make changes, then recompile and place the files in ACPI/patched, so that Clover injects the patched ACPI instead of native ACPI. With the techniques detailed in this guide, the changes can be made directly to the ACPI binaries provided by BIOS, skipping the extract, disassembly, and recompilation steps.</p>
<p>You should have a solid understanding of static ACPI patching before attempting to hotpatch. You should also have an understanding of the ACPI spec, binary patching, programming, and ACPI concepts. Don’t expect step-by-step and spoon feeding in this thread.</p>
<p>Clover mechanisms</p>
<p>Clover provides a few methods for accomplishing ACPI hotpatch:</p>
<ul>
<li>config.plist/ACPI/DSDT/Fixes</li>
<li>config.plist/ACPI/DSDT/Patches</li>
<li>ability to inject additional SSDTs</li>
</ul>
<p>DSDT/Fixes provide fixed function ACPI patching. Each “Fix” can do a particular kind of patching that can be used instead of typical patching you might do with MaciASL and static patching. For example, “IRQ Fix” can be accomplished with “FixHPET_0010” “FixIPIC_0040” “FIX_RTC_20000” and “FIX_TMR_40000”. As an other example, “Fix _WAK Arg0 v2” can be accomplished with “FIX_WAK_200000”. You can read the Clover wiki for more information on each patch. Most of the time, there are not many DSDT “Fixes” needed for basic functionality. DSDT “Fixes” are useful for implementing patches that are difficult or impossible to implement with ACPI/DSDT/Patches or additional SSDTs.</p>
<p>DSDT/Patches allows for binary search and replace by Clover. Clover loads the native ACPI files, applies the patches specified in ACPI/Patches using binary search/replace, then injects the patched ACPI. You need to have an understanding of the binary AML format. It is fully documented in the ACPI spec.</p>
<p>ACPI namespace is built by merging the DSDT and SSDTs at load time. By placing additional SSDTs into ACPI/patched, we can essentially add code to this ACPI set. Since many OS X patches involve adding properties to ioreg with a _DSM method, it is often adequate to simply add an SSDT which contains the additional _DSM method instead of patching the native ACPI files. A perfect example you’re already familiar with is the SSDT.aml that is generated by Pike’s ssdtPRgen.sh.</p>
<p>In some cases, more than one mechanism must be used to accomplish a single goal. For example, you might use binary patching to disable or rename components in the native ACPI set, and then replace it with additional SSDTs.</p>
<p>Renaming ACPI objects</p>
<p>Since OS X can depend on specific ACPI object names used by Macs, a common patch is to rename an object in the native ACPI set. For example, most PC laptops use GFX0 for the integrated Intel GPU object (Intel HD Graphics). In OS X, power management for Intel graphics is not enabled unless this device is named IGPU. Using static patching, we apply “Rename IGPU to GFX0” in order to rename this object. The patch must be applied to the DSDT and all SSDTs that reference it.</p>
<p>With hotpatch, we can rename GFX0 to IGPU using a simple Clover patch in ACPI/DSDT/Patches. Such patches apply to DSDT and all native SSDTs (DSDT/Patches do not apply to SSDTs that are added via ACPI/patched). The patch for the rename would be:</p>
<p>Comment: Rename GFX0 to IGPU<br>Find: <4746 5830=""><br>Replace: <4947 5055=""></4947></4746></p>
<p>The hex values in Find and Replaces are the ASCII codes for GFX0 and IGPU, respectively.</p>
<p>Note:<br>Code (Text):</p>
<p>u430:~ RehabMan$ echo -n GFX0|xxd<br>0000000: 4746 5830                                GFX0<br>u430:~ RehabMan$ echo -n IGPU|xxd<br>0000000: 4947 5055                                IGPU</p>
<p>There are number of common renames, and most are in the config.plist that are part of my Clover/hoptpatch project:</p>
<p><a href="https://github.com/RehabMan/OS-X-Clover-Laptop-Config/tree/master/hotpatch" target="_blank" rel="external">https://github.com/RehabMan/OS-X-Clover-Laptop-Config/tree/master/hotpatch</a></p>
<p>In fact, the hotpatch SSDTs that are part of the same project depend on the renames being implemented.</p>
<p>Common renames:<br>GFX0 -&gt; IGPU<br>SAT0 -&gt; SATA<br>EHC1 -&gt; EH01<br>EHC2 -&gt; EH02<br>XHCI -&gt; XHC<br>HECI -&gt; IMEI<br>MEI -&gt; IMEI<br>LPC -&gt; LPCB<br>HDAS -&gt; HDEF<br>AZAL -&gt; HDEF</p>
<p>Note: All ACPI identifiers are 4 characters. Shorter names are padded with underscore. So, for example, XHC is represented in the AML binary as XHC<em>, EC would be EC__, EC0 would be EC</em>, MEI would be MEI_, etc.</p>
<p>Removing methods</p>
<p>It is very difficult to remove ACPI objects, (methods, names, devices, etc) using Clover binary patches. Commonly, we must add _DSM methods to inject properties that describe various hardware properties. But added _DSM methods can conflict with existing _DSM methods that may already be in the native ACPI files. With static patching, “Remove _DSM methods” would be used.</p>
<p>Since it is difficult to remove the methods, but we don’t want the native methods to conflict with new _DSM methods that are added, the fix is to rename the native methods to something else.</p>
<p>So… again, we use a simple rename patch:</p>
<p>Comment: Rename _DSM to XDSM<br>Find: <5f44534d><br>Replace: <5844534d></5844534d></5f44534d></p>
<p>Sometimes, you might rename an object to effectively disable it so it does not cause problems. For example, my Intel DH67GD DSDT defines an APSS object. If this object is left in the DSDT it interferes with power management (causes panic). I use a rename from APSS -&gt; APXX. Because AppleIntelCPUPowerManagement is looking for APSS, it does not cause a problem once renamed to APXX.</p>
<p>Redirect and Replace</p>
<p>In some cases, we would like to replace code to change the behavior. For this, we can rename the object and provide an alternate implementation in an SSDT.</p>
<p>A common fix is spoofing the ACPI code in DSDT and SSDTs such that it behaves as if a certain version of Windows is the ACPI host. When static patching, we might use “OS Check Fix (Windows 8)”. When applied, it changes code from:<br>Code (Text):</p>
<p>If (_OSI(“Windows 2012”))</p>
<p>To:<br>Code (Text):</p>
<p>If (LOr(_OSI(“Darwin”),_OSI(“Windows 2012”))</p>
<p>Since the _OSI implementation in OS X only responds to “Darwin” the code is changed so that this specific _OSI check also accomodates “Darwin”.</p>
<p>With hotpatching, the opposite approach is taken. Instead of changing the code using _OSI, we change the code so it calls a different method that emulates the _OSI implementation that would be in the Windows ACPI host.</p>
<p>This technique relies on two of the techniques… a patch to change all calls from _OSI to XOSI… and an implementation of XOSI that emulates what Windows would do for a certain Windows version.</p>
<p>First, changing the code to call XOSI instead of _OSI:</p>
<p>Comment: Change _OSI to XOSI<br>Find: <5f4f 5349=""><br>Replace: <584f 5349=""></584f></5f4f></p>
<p>The hex codes above should be no mystery (they are ASCII for _OSI and XOSI, respectively).</p>
<p>Now the code mentioned above, after patching by Clover, will read:</p>
<p>Code (Text):</p>
<p>If (XOSI(“Windows 2012”))</p>
<p>Now we need an SSDT that implements XOSI. You will find such an implementation in the repository (SSDT-XOSI.dsl).</p>
<p>Note that without the SSDT that implements the XOSI method, the (patched) calls to XOSI would cause an ACPI abort (ACPI abort causes execution of the ACPI method to be terminated immediately with an error). Don’t use the _OSI-&gt;XOSI patch without the XOSI method.</p>
<p>Rename and Replace</p>
<p>A second pattern, similar to “Redirect and Replace” is “Rename and Replace”. In this case, instead of changing all the call sites, we change the method definition such that the method is named something different than it was originally, but leave the original method name at the call sites. This allows the method that is the target of the calls to be replaced.</p>
<p>For example, it is very common for USB devices to cause “instant wake”. As a work around, wake on USB can be disabled. Most laptops don’t have a BIOS option for it, so instead the _PRW methods that control this feature are patched.</p>
<p>For example, the native _SB.PCI0.EHC1._PRW method might read:<br>Code (Text):</p>
<pre><code>Method (_PRW, 0, NotSerialized)  // _PRW: Power Resources for Wake
{
    Return (GPRW (0x6D, 0x03))
}
</code></pre><p>In order to patch it so USB devices on EHCI#1 cannot cause wake, it would be changed:<br>Code (Text):</p>
<pre><code>Method (_PRW, 0, NotSerialized)  // _PRW: Power Resources for Wake
{
    Return (GPRW (0x6D, 0))
}
</code></pre><p>Usually, there are several such call sites to GPRW that need to be changed (also, keep in mind not all ACPI sets use the specific name GPRW). Instead of trying to patch all the call sites as above, we can instead patch the method definition of GPRW instead:</p>
<p>With the original code:<br>Code (Text):</p>
<p>Method (GPRW, 2, NotSerialized)<br>{<br>   …<br>}</p>
<p>If we change it to:<br>Code (Text):</p>
<p>Method (XPRW, 2, NotSerialized)<br>{<br>   …<br>}</p>
<p>Since you don’t want to change any call sites, the patch must be constructed such that it affects only the method itself and not the call sites. According to ACPI spec, a method definition starts with bytecode 14, is followed by the method size, the method name, argument count/flags. You can use the “-l” option in iasl to generate a mixed listing of your ACPI file. For example, the Lenovo u430 GPRW method mixed listing:<br>Code (Text):</p>
<pre><code>4323:          Method (GPRW, 2, NotSerialized)
</code></pre><p>00003F95:  14 45 08 47 50 52 57 02     “.E.GPRW.”</p>
<pre><code>4324:          {
4325:              Store (Arg0, Index (PRWP, Zero))
</code></pre><p>00003F9D:  70 68 ………………    “ph”<br>00003F9F:  88 50 52 57 50 00 00 …    “.PRWP..”</p>
<p>We could do a find replace using the method header bytes:<br>Find: <14 45="" 47="" 50="" 52="" 57="" 08="" 02=""><br>Replace: <14 45="" 50="" 52="" 57="" 58="" 08="" 02=""></14></14></p>
<p>But what happens if the method differs slightly between different versions of BIOS or models that are similar, but not exactly the same? In that case, the byte following the 14 will change due to the change in the method length.</p>
<p>My thought is that the beginning of the method body is less likely to be different than the total length of the method, so it helps to add a few extra bytes from the body of the method to the find/replace specification:</p>
<p>Find: <47 50="" 52="" 57="" 68="" 70="" 02=""><br>Replace: <58 50="" 52="" 57="" 68="" 70="" 02=""></58></47></p>
<p>The number of follow-on bytes that you use depends on how many you need to make the find/replace affect only the method definition. You can verify by looking at the native AML binary in a hex editor such as Hex Fiend (it is a nice hex editor and is also open source).</p>
<p>Note: Although you could search just for the method name + arg count/flags, it is possible that the same pattern will find a call site to the method which you don’t want to change. In the case of the u430 that wasn’t the case, so I was able to find/replace with just the method name+flags.</p>
<p>Find: <47505257 02=""><br>Replace: <58505257 02=""></58505257></47505257></p>
<p>In the case of the ProBook UPRW, it was necessary to use the follow-on bytes that are part of the method body:</p>
<p>Find: <55505257 0a7012=""><br>Replace: <58505257 0a7012=""></58505257></55505257></p>
<p>Now any code that calls GPRW (or UPRW in the ProBook example) will not call the implementation in XPRW because the name doesn’t match. The original XPRW is now unreachable code. Which means the GPRW implementation can be changed for our purpose:</p>
<p>Code (Text):</p>
<p>Method(GPRW, 2)<br>{<br>    If (0x6d == Arg0) { Return(Package() { 0x6d, 0, }) }<br>    External(\XPRW, MethodObj)<br>    Return(XPRW(Arg0, Arg1))<br>}</p>
<p>Explaining the code: For any call to GPRW with the first argument set to 0x6d (the GPE we are trying to disable for wake), instead of returning what the original GPRW would, we return a package with 0x6d and 0 (which disables wake). And for other GPE values, the code simply calls the original GPRW method now named XPRW.</p>
<p>Another simple case is patching EC query methods to fix the brightness keys. A simple rename of the _Qxx methods involved to XQxx, and a new definition of the method with the original name is all that is needed.</p>
<p>For example, in the HP Envy Haswell repo:<br>Code (Text):</p>
<pre><code>// _Q13 called on brightness/mirror display key
Method (_Q13, 0, Serialized)  // _Qxx: EC Query
{
    External(\HKNO, FieldUnitObj)
    Store(HKNO, Local0)
    If (LEqual(Local0,7))
    {
        // Brightness Down
        Notify(\_SB.PCI0.LPCB.PS2K, 0x0405)
    }
    If (LEqual(Local0,8))
    {
        // Brightness Up
        Notify(\_SB.PCI0.LPCB.PS2K, 0x0406)
    }
    If (LEqual(Local0,4))
    {
        // Mirror toggle
        Notify(\_SB.PCI0.LPCB.PS2K, 0x046e)
    }
}
</code></pre><p>And the associated patch:<br>Comment: change Method(_Q13,0,S) to XQ13<br>Find: <5f513133 08=""><br>Replace: <58513133 08=""></58513133></5f513133></p>
<p>This same “Rename and Replace” mechanism can be used in cases that are much more complex than this. For example, it is typically used to patch battery methods, which need to be patched to avoid access to multibyte EC fields.</p>
<p>Tips for complex Rename and Replace</p>
<p>As you probably already know, patching for battery status (multibyte EC fields) can be very complex and can involve a lot of code changes to many methods.</p>
<p>This section will detail some of the techniques and procedures used for battery patching.</p>
<p>It is advisable to patch for battery without using hotpatch first. After you get it working, then attempt hotpatch. Also, the difference between the code not patched for battery and the code patched for battery is very helpful. You can use a tool like ‘diffmerge’ to compare each. This is especially true if there is already a static battery patch for your laptop in my laptop repository.</p>
<p>General procedure:</p>
<ul>
<li>start with native ACPI</li>
<li>patch for battery status using static patching (verify it works)</li>
<li>use diffmerge to compare the unpatched code with patched code</li>
<li>for each method that is different, implement the “Rename and Replace” pattern</li>
<li>for the EC fields, create another EC OperationRegion (use a name that is different from the original) and Field definition as a sort of “overlay” which contains only the EC fields you need to patch</li>
<li>to create the EC overlay, you can use the patched Field/OperationRegion in the patched DSDT, then eliminate unpatched fields</li>
<li>use External to allow the replacement methods in the SSDT to access the fields defined elsewhere in the ACPI set (usually DSDT)</li>
<li>let the compiler point out where you need to use External</li>
<li>watch out for symbols with duplicate names in different scopes</li>
</ul>
<p>An example is provided in post #2 of this thread.</p>
<p>Code value patching</p>
<p>Consider the case of “Fix Mutex with non-zero SyncLevel”. This patch finds all Mutex objects and replaces the SyncLevel with 0. We use this patch since OS X does not support Mutex debugging correctly and aborts on any Acquire with a Mutex that has a non-zero SyncLevel.</p>
<p>As an example, the u430 has Mutexes delcared as such:<br>Code (Text):</p>
<pre><code>Mutex (MSMI, 0x07)
</code></pre><p>To make it compatible with OS X it must be changed:<br>Code (Text):</p>
<pre><code>Mutex (MSMI, 0)
</code></pre><p>The ACPI spec defines how a Mutex object is encoded in the AML, but it can be helpful to look at a mixed disassembly of a small ACPI file:<br>Code (Text):</p>
<p>DefinitionBlock (“”, “DSDT”, 2, “test”, “test”, 0)<br>{<br>    Mutex(ABCD, 7)<br>}</p>
<p>The iasl compiler can create a mixed listing file with the “-l” option.</p>
<p>If we compile the above file with: iasl -l test.dsl, test.lst contains:<br>Code (Text):</p>
<pre><code>1:  DefinitionBlock (&quot;&quot;, &quot;DSDT&quot;, 2, &quot;test&quot;, &quot;test&quot;, 0)
</code></pre><p>00000000:  44 53 44 54 2B 00 00 00     “DSDT+…”<br>00000008:  02 36 74 65 73 74 00 00     “.6test..”<br>00000010:  74 65 73 74 00 00 00 00     “test….”<br>00000018:  00 00 00 00 49 4E 54 4C     “….INTL”<br>00000020:  10 04 16 20 …………    “… “</p>
<pre><code>2:  {
3:      Mutex(ABCD, 7)
</code></pre><p>00000024:  5B 01 41 42 43 44 07 …    “[.ABCD.”<br>       4:  }</p>
<p>As you can see, the Mutex(ABCD, 7), is encoded as <5b 41="" 42="" 43="" 44="" 01="" 07=""></5b></p>
<p>It is now very easy to construct a patch for it:</p>
<p>Comment: Change Mutex(ABCD,7) to Mutex(ABCD,0)<br>Find: <5b 41="" 42="" 43="" 44="" 01="" 07=""><br>Replace: <5b 41="" 42="" 43="" 44="" 01="" 00=""></5b></5b></p>
<p>Clover ACPI configuration</p>
<p>With static patching, DropOem=true is used and patched DSDT and SSDTs are added to ACPI/patched. With hotpatch, instead use DropOem=false, and only add-on SSDTs are placed in ACPI/patched.</p>
<p>It is important to note that config.plist/ACPI/patches are applied only to native SSDTs, and not the SSDTs in ACPI/patched. This means that if you are renaming objects using config.plist, the add-on SSDTs must refer to the new names, not the old names. Unlike SSDTs in ACPI/patched, binary patches in ACPI/Patches <em>do apply</em> to DSDT.aml that might be in ACPI/patched. Keep this in mind if you’re using a combination of static and hotpatching.</p>
<p>Also, with static patching, SortedOrder is used to specify the order of SSDTs in ACPI/patched. With hotpatch it is not strictly necessary as it is possible to construct the code in each SSDT such that the code is not order dependent. Especially if you place all add-on code in a single SSDT such as many of my laptop repo examples. Unless your add-on SSDTs are order dependent, you do not have to name each one in SortedOrder.</p>
<p>It is also not necessary to choose “numbered names” for each SSDT. Instead you can use meaningful names, such as “SSDT-USB.aml”, SSDT-XOSI.aml”, etc. Using numbers instead of meaningul names will just confuse you. Don’t do it.</p>
<p>Troubleshooting</p>
<p>You can use patchmatic to look at your complete ACPI set as injected by Clover after patching. By runnning ‘patchmatic -extract’, patchmatic will write all injected DSDT.aml and SSDT<em>.aml in the order they were injected by Clover. You can disassemble them with ‘iasl -da -dl </em>.aml’. If iasl shows errors with the disassembly (for example duplicate symbols), it is likley OS X is also rejecting the conflicting SSDTs.</p>
<p>If you’re a novice with this technique, it is a good idea to implement one patch at a time, and slowly build it up to a full set of working patches + SSDTs. Trying to do all at once can make it difficult to locate your mistake.</p>
<h3 id="Battery-Status-Hotpatch"><a href="#Battery-Status-Hotpatch" class="headerlink" title="Battery Status Hotpatch"></a>Battery Status Hotpatch</h3><p>This second post is dedicated to patching battery status with Clover hotpatch. To demonstrate the process, we will work through an example DSDT. The example files used are from the guide for disabling discrete graphics, an “Asus UX303LN”.</p>
<p><a href="https://www.tonymacx86.com/threads/guide-disabling-discrete-graphics-in-dual-gpu-laptops.163772/" target="_blank" rel="external">https://www.tonymacx86.com/threads/guide-disabling-discrete-graphics-in-dual-gpu-laptops.163772/</a></p>
<p>You should download the ACPI/origin files that are attached to that guide, so you can follow along.</p>
<p>As mentioned in post #1, the general procedures are as follows:</p>
<ul>
<li>start with native ACPI</li>
<li>patch for battery status using static patching (verify it works)</li>
<li>use diffmerge to compare the unpatched code with patched code</li>
<li>for each method that is different, implement the “Rename and Replace” pattern</li>
<li>for the EC fields, create another EC OperationRegion (use a name that is different from the original) and Field definition as a sort of “overlay” which contains only the EC fields you need to patch</li>
<li>to create the EC overlay, you can use the patched Field/OperationRegion in the patched DSDT, then eliminate unpatched fields</li>
<li>use External to allow the replacement methods in the SSDT to access the fields defined elsewhere in the ACPI set (usually DSDT)</li>
<li>let the compiler point out where you need to use External</li>
<li>watch out for symbols with duplicate names in different scopes</li>
</ul>
<p>Using diffmerge to find patched vs. native differences</p>
<p>Start by disassembling the origin files: iasl -da -dl *.aml<br>(you should be familiar with this part as it is part of normal ACPI patching)</p>
<p>Next apply the battery patch only using MaciASL to DSDT.dsl. In this case, we apply the “ASUS N55SL/VivoBook”. There is no need to fix any errors, as we are interested only in the differences created by applying the battery patch. Save the patched file as DSDT_patched.dsl.</p>
<p>Now you can run diffmerge to see the differences between DSDT.dsl and DSDT_patched.dsl. I usually just do this from Terminal:<br>Code (Text):</p>
<p>diffmerge DSDT.dsl DSDT_patched.dsl</p>
<p>The initial diffmerge window will look something like this:<br>batthot_diffmerge_initial.png</p>
<p>From there, we can examine the parts that have changes by clicking on the markers in the left column.</p>
<p>In the examples, the groups of changes you find:</p>
<ul>
<li>group 1: is the changes to the EC fields (multibyte to single byte)</li>
<li>group 2: addition of RDBA, WRBA, RDBB, WRBB methods</li>
<li>group 3: patched FBST, _BIX, B1FA methods</li>
<li>group 4: patched SMBR, SMBW, ECSB methods</li>
<li>group 5: patched TACH method</li>
<li>final group: addition of B1B2 method</li>
</ul>
<p>Constructing the initial SSDT</p>
<p>Start with an empty SSDT in MaciASL:<br>Code (Text):</p>
<p>DefinitionBlock(“”, “SSDT”, 2, “hack”, “batt”, 0)<br>{<br>}</p>
<p>Next, add all methods that were added by the patch. In the example, this includes RDBA, WRBA, RDBB, WRBB and B1B2 methods. You can copy them directly from the DSDT_patched.dsl.</p>
<p>You want to be certain each method is placed in the same scope. For example, here is the “group 2” methods added:</p>
<p>Code (Text):</p>
<p>DefinitionBlock(“”, “SSDT”, 2, “hack”, “batt”, 0)<br>{<br>    Scope (_SB.PCI0.LPCB.EC0)<br>    {<br>        Scope (EC0)<br>        {<br>            Method (RDBA, 0, Serialized)<br>            {<br>                Name (TEMP, Buffer(0x20) { })<br>                Store (BA00, Index(TEMP, 0x00))<br>                Store (BA01, Index(TEMP, 0x01))<br>                Store (BA02, Index(TEMP, 0x02))<br>                Store (BA03, Index(TEMP, 0x03))<br>                Store (BA04, Index(TEMP, 0x04))<br>                Store (BA05, Index(TEMP, 0x05))<br>                Store (BA06, Index(TEMP, 0x06))<br>                Store (BA07, Index(TEMP, 0x07))<br>                Store (BA08, Index(TEMP, 0x08))<br>                Store (BA09, Index(TEMP, 0x09))<br>                Store (BA0A, Index(TEMP, 0x0A))<br>                Store (BA0B, Index(TEMP, 0x0B))<br>                Store (BA0C, Index(TEMP, 0x0C))<br>                Store (BA0D, Index(TEMP, 0x0D))<br>                Store (BA0E, Index(TEMP, 0x0E))<br>                Store (BA0F, Index(TEMP, 0x0F))<br>                Store (BA10, Index(TEMP, 0x10))<br>                Store (BA11, Index(TEMP, 0x11))<br>                Store (BA12, Index(TEMP, 0x12))<br>                Store (BA13, Index(TEMP, 0x13))<br>                Store (BA14, Index(TEMP, 0x14))<br>                Store (BA15, Index(TEMP, 0x15))<br>                Store (BA16, Index(TEMP, 0x16))<br>                Store (BA17, Index(TEMP, 0x17))<br>                Store (BA18, Index(TEMP, 0x18))<br>                Store (BA19, Index(TEMP, 0x19))<br>                Store (BA1A, Index(TEMP, 0x1A))<br>                Store (BA1B, Index(TEMP, 0x1B))<br>                Store (BA1C, Index(TEMP, 0x1C))<br>                Store (BA1D, Index(TEMP, 0x1D))<br>                Store (BA1E, Index(TEMP, 0x1E))<br>                Store (BA1F, Index(TEMP, 0x1F))<br>                Return (TEMP)<br>            }<br>            Method (WRBA, 1, Serialized)<br>            {<br>                Name (TEMP, Buffer(0x20) { })<br>                Store (Arg0, TEMP)<br>                Store (DerefOf(Index(TEMP, 0x00)), BA00)<br>                Store (DerefOf(Index(TEMP, 0x01)), BA01)<br>                Store (DerefOf(Index(TEMP, 0x02)), BA02)<br>                Store (DerefOf(Index(TEMP, 0x03)), BA03)<br>                Store (DerefOf(Index(TEMP, 0x04)), BA04)<br>                Store (DerefOf(Index(TEMP, 0x05)), BA05)<br>                Store (DerefOf(Index(TEMP, 0x06)), BA06)<br>                Store (DerefOf(Index(TEMP, 0x07)), BA07)<br>                Store (DerefOf(Index(TEMP, 0x08)), BA08)<br>                Store (DerefOf(Index(TEMP, 0x09)), BA09)<br>                Store (DerefOf(Index(TEMP, 0x0A)), BA0A)<br>                Store (DerefOf(Index(TEMP, 0x0B)), BA0B)<br>                Store (DerefOf(Index(TEMP, 0x0C)), BA0C)<br>                Store (DerefOf(Index(TEMP, 0x0D)), BA0D)<br>                Store (DerefOf(Index(TEMP, 0x0E)), BA0E)<br>                Store (DerefOf(Index(TEMP, 0x0F)), BA0F)<br>                Store (DerefOf(Index(TEMP, 0x10)), BA10)<br>                Store (DerefOf(Index(TEMP, 0x11)), BA11)<br>                Store (DerefOf(Index(TEMP, 0x12)), BA12)<br>                Store (DerefOf(Index(TEMP, 0x13)), BA13)<br>                Store (DerefOf(Index(TEMP, 0x14)), BA14)<br>                Store (DerefOf(Index(TEMP, 0x15)), BA15)<br>                Store (DerefOf(Index(TEMP, 0x16)), BA16)<br>                Store (DerefOf(Index(TEMP, 0x17)), BA17)<br>                Store (DerefOf(Index(TEMP, 0x18)), BA18)<br>                Store (DerefOf(Index(TEMP, 0x19)), BA19)<br>                Store (DerefOf(Index(TEMP, 0x1A)), BA1A)<br>                Store (DerefOf(Index(TEMP, 0x1B)), BA1B)<br>                Store (DerefOf(Index(TEMP, 0x1C)), BA1C)<br>                Store (DerefOf(Index(TEMP, 0x1D)), BA1D)<br>                Store (DerefOf(Index(TEMP, 0x1E)), BA1E)<br>                Store (DerefOf(Index(TEMP, 0x1F)), BA1F)<br>            }<br>            Method (RDBB, 0, Serialized)<br>            {<br>                Name (TEMP, Buffer(0x20) { })<br>                Store (BB00, Index(TEMP, 0x00))<br>                Store (BB01, Index(TEMP, 0x01))<br>                Store (BB02, Index(TEMP, 0x02))<br>                Store (BB03, Index(TEMP, 0x03))<br>                Store (BB04, Index(TEMP, 0x04))<br>                Store (BB05, Index(TEMP, 0x05))<br>                Store (BB06, Index(TEMP, 0x06))<br>                Store (BB07, Index(TEMP, 0x07))<br>                Store (BB08, Index(TEMP, 0x08))<br>                Store (BB09, Index(TEMP, 0x09))<br>                Store (BB0A, Index(TEMP, 0x0A))<br>                Store (BB0B, Index(TEMP, 0x0B))<br>                Store (BB0C, Index(TEMP, 0x0C))<br>                Store (BB0D, Index(TEMP, 0x0D))<br>                Store (BB0E, Index(TEMP, 0x0E))<br>                Store (BB0F, Index(TEMP, 0x0F))<br>                Store (BB10, Index(TEMP, 0x10))<br>                Store (BB11, Index(TEMP, 0x11))<br>                Store (BB12, Index(TEMP, 0x12))<br>                Store (BB13, Index(TEMP, 0x13))<br>                Store (BB14, Index(TEMP, 0x14))<br>                Store (BB15, Index(TEMP, 0x15))<br>                Store (BB16, Index(TEMP, 0x16))<br>                Store (BB17, Index(TEMP, 0x17))<br>                Store (BB18, Index(TEMP, 0x18))<br>                Store (BB19, Index(TEMP, 0x19))<br>                Store (BB1A, Index(TEMP, 0x1A))<br>                Store (BB1B, Index(TEMP, 0x1B))<br>                Store (BB1C, Index(TEMP, 0x1C))<br>                Store (BB1D, Index(TEMP, 0x1D))<br>                Store (BB1E, Index(TEMP, 0x1E))<br>                Store (BB1F, Index(TEMP, 0x1F))<br>                Return (TEMP)<br>            }<br>            Method (WRBB, 1, Serialized)<br>            {<br>                Name (TEMP, Buffer(0x20) { })<br>                Store (Arg0, TEMP)<br>                Store (DerefOf(Index(TEMP, 0x00)), BB00)<br>                Store (DerefOf(Index(TEMP, 0x01)), BB01)<br>                Store (DerefOf(Index(TEMP, 0x02)), BB02)<br>                Store (DerefOf(Index(TEMP, 0x03)), BB03)<br>                Store (DerefOf(Index(TEMP, 0x04)), BB04)<br>                Store (DerefOf(Index(TEMP, 0x05)), BB05)<br>                Store (DerefOf(Index(TEMP, 0x06)), BB06)<br>                Store (DerefOf(Index(TEMP, 0x07)), BB07)<br>                Store (DerefOf(Index(TEMP, 0x08)), BB08)<br>                Store (DerefOf(Index(TEMP, 0x09)), BB09)<br>                Store (DerefOf(Index(TEMP, 0x0A)), BB0A)<br>                Store (DerefOf(Index(TEMP, 0x0B)), BB0B)<br>                Store (DerefOf(Index(TEMP, 0x0C)), BB0C)<br>                Store (DerefOf(Index(TEMP, 0x0D)), BB0D)<br>                Store (DerefOf(Index(TEMP, 0x0E)), BB0E)<br>                Store (DerefOf(Index(TEMP, 0x0F)), BB0F)<br>                Store (DerefOf(Index(TEMP, 0x10)), BB10)<br>                Store (DerefOf(Index(TEMP, 0x11)), BB11)<br>                Store (DerefOf(Index(TEMP, 0x12)), BB12)<br>                Store (DerefOf(Index(TEMP, 0x13)), BB13)<br>                Store (DerefOf(Index(TEMP, 0x14)), BB14)<br>                Store (DerefOf(Index(TEMP, 0x15)), BB15)<br>                Store (DerefOf(Index(TEMP, 0x16)), BB16)<br>                Store (DerefOf(Index(TEMP, 0x17)), BB17)<br>                Store (DerefOf(Index(TEMP, 0x18)), BB18)<br>                Store (DerefOf(Index(TEMP, 0x19)), BB19)<br>                Store (DerefOf(Index(TEMP, 0x1A)), BB1A)<br>                Store (DerefOf(Index(TEMP, 0x1B)), BB1B)<br>                Store (DerefOf(Index(TEMP, 0x1C)), BB1C)<br>                Store (DerefOf(Index(TEMP, 0x1D)), BB1D)<br>                Store (DerefOf(Index(TEMP, 0x1E)), BB1E)<br>                Store (DerefOf(Index(TEMP, 0x1F)), BB1F)<br>            }<br>        }<br>    }<br>}</p>
<p>And with B1B2 added:<br>Code (Text):</p>
<p>DefinitionBlock(“”, “SSDT”, 2, “hack”, “batt”, 0)<br>{<br>    Method (B1B2, 2, NotSerialized) { Return (Or (Arg0, ShiftLeft (Arg1, 8))) }</p>
<pre><code>// added methods (group 2)
Scope (_SB.PCI0.LPCB.EC0)
{
    Scope (EC0)
    {
        Method (RDBA, 0, Serialized)
        {
            Name (TEMP, Buffer(0x20) { })
            Store (BA00, Index(TEMP, 0x00))
            Store (BA01, Index(TEMP, 0x01))
            Store (BA02, Index(TEMP, 0x02))
            Store (BA03, Index(TEMP, 0x03))
            Store (BA04, Index(TEMP, 0x04))
            Store (BA05, Index(TEMP, 0x05))
            Store (BA06, Index(TEMP, 0x06))
            Store (BA07, Index(TEMP, 0x07))
            Store (BA08, Index(TEMP, 0x08))
            Store (BA09, Index(TEMP, 0x09))
            Store (BA0A, Index(TEMP, 0x0A))
            Store (BA0B, Index(TEMP, 0x0B))
            Store (BA0C, Index(TEMP, 0x0C))
            Store (BA0D, Index(TEMP, 0x0D))
            Store (BA0E, Index(TEMP, 0x0E))
            Store (BA0F, Index(TEMP, 0x0F))
            Store (BA10, Index(TEMP, 0x10))
            Store (BA11, Index(TEMP, 0x11))
            Store (BA12, Index(TEMP, 0x12))
            Store (BA13, Index(TEMP, 0x13))
            Store (BA14, Index(TEMP, 0x14))
            Store (BA15, Index(TEMP, 0x15))
            Store (BA16, Index(TEMP, 0x16))
            Store (BA17, Index(TEMP, 0x17))
            Store (BA18, Index(TEMP, 0x18))
            Store (BA19, Index(TEMP, 0x19))
            Store (BA1A, Index(TEMP, 0x1A))
            Store (BA1B, Index(TEMP, 0x1B))
            Store (BA1C, Index(TEMP, 0x1C))
            Store (BA1D, Index(TEMP, 0x1D))
            Store (BA1E, Index(TEMP, 0x1E))
            Store (BA1F, Index(TEMP, 0x1F))
            Return (TEMP)
        }
        Method (WRBA, 1, Serialized)
        {
            Name (TEMP, Buffer(0x20) { })
            Store (Arg0, TEMP)
            Store (DerefOf(Index(TEMP, 0x00)), BA00)
            Store (DerefOf(Index(TEMP, 0x01)), BA01)
            Store (DerefOf(Index(TEMP, 0x02)), BA02)
            Store (DerefOf(Index(TEMP, 0x03)), BA03)
            Store (DerefOf(Index(TEMP, 0x04)), BA04)
            Store (DerefOf(Index(TEMP, 0x05)), BA05)
            Store (DerefOf(Index(TEMP, 0x06)), BA06)
            Store (DerefOf(Index(TEMP, 0x07)), BA07)
            Store (DerefOf(Index(TEMP, 0x08)), BA08)
            Store (DerefOf(Index(TEMP, 0x09)), BA09)
            Store (DerefOf(Index(TEMP, 0x0A)), BA0A)
            Store (DerefOf(Index(TEMP, 0x0B)), BA0B)
            Store (DerefOf(Index(TEMP, 0x0C)), BA0C)
            Store (DerefOf(Index(TEMP, 0x0D)), BA0D)
            Store (DerefOf(Index(TEMP, 0x0E)), BA0E)
            Store (DerefOf(Index(TEMP, 0x0F)), BA0F)
            Store (DerefOf(Index(TEMP, 0x10)), BA10)
            Store (DerefOf(Index(TEMP, 0x11)), BA11)
            Store (DerefOf(Index(TEMP, 0x12)), BA12)
            Store (DerefOf(Index(TEMP, 0x13)), BA13)
            Store (DerefOf(Index(TEMP, 0x14)), BA14)
            Store (DerefOf(Index(TEMP, 0x15)), BA15)
            Store (DerefOf(Index(TEMP, 0x16)), BA16)
            Store (DerefOf(Index(TEMP, 0x17)), BA17)
            Store (DerefOf(Index(TEMP, 0x18)), BA18)
            Store (DerefOf(Index(TEMP, 0x19)), BA19)
            Store (DerefOf(Index(TEMP, 0x1A)), BA1A)
            Store (DerefOf(Index(TEMP, 0x1B)), BA1B)
            Store (DerefOf(Index(TEMP, 0x1C)), BA1C)
            Store (DerefOf(Index(TEMP, 0x1D)), BA1D)
            Store (DerefOf(Index(TEMP, 0x1E)), BA1E)
            Store (DerefOf(Index(TEMP, 0x1F)), BA1F)
        }
        Method (RDBB, 0, Serialized)
        {
            Name (TEMP, Buffer(0x20) { })
            Store (BB00, Index(TEMP, 0x00))
            Store (BB01, Index(TEMP, 0x01))
            Store (BB02, Index(TEMP, 0x02))
            Store (BB03, Index(TEMP, 0x03))
            Store (BB04, Index(TEMP, 0x04))
            Store (BB05, Index(TEMP, 0x05))
            Store (BB06, Index(TEMP, 0x06))
            Store (BB07, Index(TEMP, 0x07))
            Store (BB08, Index(TEMP, 0x08))
            Store (BB09, Index(TEMP, 0x09))
            Store (BB0A, Index(TEMP, 0x0A))
            Store (BB0B, Index(TEMP, 0x0B))
            Store (BB0C, Index(TEMP, 0x0C))
            Store (BB0D, Index(TEMP, 0x0D))
            Store (BB0E, Index(TEMP, 0x0E))
            Store (BB0F, Index(TEMP, 0x0F))
            Store (BB10, Index(TEMP, 0x10))
            Store (BB11, Index(TEMP, 0x11))
            Store (BB12, Index(TEMP, 0x12))
            Store (BB13, Index(TEMP, 0x13))
            Store (BB14, Index(TEMP, 0x14))
            Store (BB15, Index(TEMP, 0x15))
            Store (BB16, Index(TEMP, 0x16))
            Store (BB17, Index(TEMP, 0x17))
            Store (BB18, Index(TEMP, 0x18))
            Store (BB19, Index(TEMP, 0x19))
            Store (BB1A, Index(TEMP, 0x1A))
            Store (BB1B, Index(TEMP, 0x1B))
            Store (BB1C, Index(TEMP, 0x1C))
            Store (BB1D, Index(TEMP, 0x1D))
            Store (BB1E, Index(TEMP, 0x1E))
            Store (BB1F, Index(TEMP, 0x1F))
            Return (TEMP)
        }
        Method (WRBB, 1, Serialized)
        {
            Name (TEMP, Buffer(0x20) { })
            Store (Arg0, TEMP)
            Store (DerefOf(Index(TEMP, 0x00)), BB00)
            Store (DerefOf(Index(TEMP, 0x01)), BB01)
            Store (DerefOf(Index(TEMP, 0x02)), BB02)
            Store (DerefOf(Index(TEMP, 0x03)), BB03)
            Store (DerefOf(Index(TEMP, 0x04)), BB04)
            Store (DerefOf(Index(TEMP, 0x05)), BB05)
            Store (DerefOf(Index(TEMP, 0x06)), BB06)
            Store (DerefOf(Index(TEMP, 0x07)), BB07)
            Store (DerefOf(Index(TEMP, 0x08)), BB08)
            Store (DerefOf(Index(TEMP, 0x09)), BB09)
            Store (DerefOf(Index(TEMP, 0x0A)), BB0A)
            Store (DerefOf(Index(TEMP, 0x0B)), BB0B)
            Store (DerefOf(Index(TEMP, 0x0C)), BB0C)
            Store (DerefOf(Index(TEMP, 0x0D)), BB0D)
            Store (DerefOf(Index(TEMP, 0x0E)), BB0E)
            Store (DerefOf(Index(TEMP, 0x0F)), BB0F)
            Store (DerefOf(Index(TEMP, 0x10)), BB10)
            Store (DerefOf(Index(TEMP, 0x11)), BB11)
            Store (DerefOf(Index(TEMP, 0x12)), BB12)
            Store (DerefOf(Index(TEMP, 0x13)), BB13)
            Store (DerefOf(Index(TEMP, 0x14)), BB14)
            Store (DerefOf(Index(TEMP, 0x15)), BB15)
            Store (DerefOf(Index(TEMP, 0x16)), BB16)
            Store (DerefOf(Index(TEMP, 0x17)), BB17)
            Store (DerefOf(Index(TEMP, 0x18)), BB18)
            Store (DerefOf(Index(TEMP, 0x19)), BB19)
            Store (DerefOf(Index(TEMP, 0x1A)), BB1A)
            Store (DerefOf(Index(TEMP, 0x1B)), BB1B)
            Store (DerefOf(Index(TEMP, 0x1C)), BB1C)
            Store (DerefOf(Index(TEMP, 0x1D)), BB1D)
            Store (DerefOf(Index(TEMP, 0x1E)), BB1E)
            Store (DerefOf(Index(TEMP, 0x1F)), BB1F)
        }
    }
}
</code></pre><p>}</p>
<p>Don’t worry that the code does not compile at the moment. It is not expected at this point, due to the EC fields (and other identifiers) that are not defined in this file. They will need to be definined or referenced via External (eventually).</p>
<p>Now let’s add the patched methods. Just like the methods that were added methods, the patched methods are just copied from the DSDT_patched.dsl:<br>Code (Text):</p>
<p>DefinitionBlock(“”, “SSDT”, 2, “hack”, “batt”, 0)<br>{<br>    // patched methods<br>    Scope (_SB.PCI0)<br>    {<br>        Scope (BAT0)<br>        {<br>            Method (FBST, 4, NotSerialized)<br>            {<br>                And (Arg1, 0xFFFF, Local1)<br>                Store (Zero, Local0)<br>                If (^^LPCB.EC0.ACAP ())<br>                {<br>                    Store (One, Local0)<br>                }</p>
<pre><code>If (Local0)
{
    If (CHGS (Zero))
</code></pre><p>{<br>    Store (0x02, Local0)<br>}<br>Else<br>{<br>    Store (Zero, Local0)<br>}<br>                }<br>                Else<br>                {<br>                    Store (One, Local0)<br>                }</p>
<pre><code>            If (BLLO)
            {
                ShiftLeft (One, 0x02, Local2)
                Or (Local0, Local2, Local0)
            }

            If (And (^^LPCB.EC0.EB0S, 0x08))
            {
                ShiftLeft (One, 0x02, Local2)
                Or (Local0, Local2, Local0)
            }

            If (LGreaterEqual (Local1, 0x8000))
            {
                Subtract (0xFFFF, Local1, Local1)
            }

            Store (Arg2, Local2)
            If (LEqual (PUNT, Zero))
            {
                Multiply (Local1, ^^LPCB.EC0.B0DV, Local1)
                Multiply (Local2, 0x0A, Local2)
            }

            And (Local0, 0x02, Local3)
            If (LNot (Local3))
            {
                Subtract (LFCC, Local2, Local3)
                Divide (LFCC, 0xC8, Local4, Local5)
                If (LLess (Local3, Local5))
                {
                    Store (LFCC, Local2)
                }
            }
            Else
            {
                Divide (LFCC, 0xC8, Local4, Local5)
                Subtract (LFCC, Local5, Local4)
                If (LGreater (Local2, Local4))
                {
                    Store (Local4, Local2)
                }
            }

            If (LNot (^^LPCB.EC0.ACAP ()))
            {
                Divide (Local2, MBLF, Local3, Local4)
                If (LLess (Local1, Local4))
                {
                    Store (Local4, Local1)
                }
            }

            Store (Local0, Index (PBST, Zero))
            Store (Local1, Index (PBST, One))
            Store (Local2, Index (PBST, 0x02))
            Store (Arg3, Index (PBST, 0x03))
        }
        Method (_BIX, 0, NotSerialized)  // _BIX: Battery Information Extended
        {
            If (LNot (^^LPCB.EC0.BATP (Zero)))
            {
                Return (NBIX)
            }

            If (LEqual (^^LPCB.EC0.GBTT (Zero), 0xFF))
            {
                Return (NBIX)
            }

            _BIF ()
            Store (DerefOf (Index (PBIF, Zero)), Index (BIXT, One))
            Store (DerefOf (Index (PBIF, One)), Index (BIXT, 0x02))
            Store (DerefOf (Index (PBIF, 0x02)), Index (BIXT, 0x03))
            Store (DerefOf (Index (PBIF, 0x03)), Index (BIXT, 0x04))
            Store (DerefOf (Index (PBIF, 0x04)), Index (BIXT, 0x05))
            Store (DerefOf (Index (PBIF, 0x05)), Index (BIXT, 0x06))
            Store (DerefOf (Index (PBIF, 0x06)), Index (BIXT, 0x07))
            Store (DerefOf (Index (PBIF, 0x07)), Index (BIXT, 0x0E))
            Store (DerefOf (Index (PBIF, 0x08)), Index (BIXT, 0x0F))
            Store (DerefOf (Index (PBIF, 0x09)), Index (BIXT, 0x10))
            Store (DerefOf (Index (PBIF, 0x0A)), Index (BIXT, 0x11))
            Store (DerefOf (Index (PBIF, 0x0B)), Index (BIXT, 0x12))
            Store (DerefOf (Index (PBIF, 0x0C)), Index (BIXT, 0x13))
            If (LEqual (DerefOf (Index (BIXT, One)), One))
            {
                Store (Zero, Index (BIXT, One))
                Store (DerefOf (Index (BIXT, 0x05)), Local0)
                Multiply (DerefOf (Index (BIXT, 0x02)), Local0, Index (BIXT, 0x02))
                Multiply (DerefOf (Index (BIXT, 0x03)), Local0, Index (BIXT, 0x03))
                Multiply (DerefOf (Index (BIXT, 0x06)), Local0, Index (BIXT, 0x06))
                Multiply (DerefOf (Index (BIXT, 0x07)), Local0, Index (BIXT, 0x07))
                Multiply (DerefOf (Index (BIXT, 0x0E)), Local0, Index (BIXT, 0x0E))
                Multiply (DerefOf (Index (BIXT, 0x0F)), Local0, Index (BIXT, 0x0F))
                Divide (DerefOf (Index (BIXT, 0x02)), 0x03E8, Local0, Index (BIXT, 0x02))
                Divide (DerefOf (Index (BIXT, 0x03)), 0x03E8, Local0, Index (BIXT, 0x03))
                Divide (DerefOf (Index (BIXT, 0x06)), 0x03E8, Local0, Index (BIXT, 0x06))
                Divide (DerefOf (Index (BIXT, 0x07)), 0x03E8, Local0, Index (BIXT, 0x07))
                Divide (DerefOf (Index (BIXT, 0x0E)), 0x03E8, Local0, Index (BIXT, 0x0E))
                Divide (DerefOf (Index (BIXT, 0x0F)), 0x03E8, Local0, Index (BIXT, 0x0F))
            }

            Store (B1B2(^^LPCB.EC0.XC30,^^LPCB.EC0.XC31), Index (BIXT, 0x08))
            Store (0x0001869F, Index (BIXT, 0x09))
            Return (BIXT)
        }

}
}
Scope (_SB.PCI0.LPCB.EC0)
{
    Method (BIFA, 0, NotSerialized)
    {
        If (ECAV ())
        {
            If (BSLF)
            {
                Store (B1B2(B1S0,B1S1), Local0)
            }
            Else
            {
                Store (B1B2(B0S0,B0S1), Local0)
            }
        }
        Else
        {
            Store (Ones, Local0)
        }

        Return (Local0)
    }
}

Method (B1B2, 2, NotSerialized) { Return (Or (Arg0, ShiftLeft (Arg1, 8))) }

// added methods (group 2)
Scope (_SB.PCI0.LPCB.EC0)
{
    Scope (EC0)
    {
        Method (RDBA, 0, Serialized)
        {
            Name (TEMP, Buffer(0x20) { })
            Store (BA00, Index(TEMP, 0x00))
            Store (BA01, Index(TEMP, 0x01))
            Store (BA02, Index(TEMP, 0x02))
            Store (BA03, Index(TEMP, 0x03))
            Store (BA04, Index(TEMP, 0x04))
            Store (BA05, Index(TEMP, 0x05))
            Store (BA06, Index(TEMP, 0x06))
            Store (BA07, Index(TEMP, 0x07))
            Store (BA08, Index(TEMP, 0x08))
            Store (BA09, Index(TEMP, 0x09))
            Store (BA0A, Index(TEMP, 0x0A))
            Store (BA0B, Index(TEMP, 0x0B))
            Store (BA0C, Index(TEMP, 0x0C))
            Store (BA0D, Index(TEMP, 0x0D))
            Store (BA0E, Index(TEMP, 0x0E))
            Store (BA0F, Index(TEMP, 0x0F))
            Store (BA10, Index(TEMP, 0x10))
            Store (BA11, Index(TEMP, 0x11))
            Store (BA12, Index(TEMP, 0x12))
            Store (BA13, Index(TEMP, 0x13))
            Store (BA14, Index(TEMP, 0x14))
            Store (BA15, Index(TEMP, 0x15))
            Store (BA16, Index(TEMP, 0x16))
            Store (BA17, Index(TEMP, 0x17))
            Store (BA18, Index(TEMP, 0x18))
            Store (BA19, Index(TEMP, 0x19))
            Store (BA1A, Index(TEMP, 0x1A))
            Store (BA1B, Index(TEMP, 0x1B))
            Store (BA1C, Index(TEMP, 0x1C))
            Store (BA1D, Index(TEMP, 0x1D))
            Store (BA1E, Index(TEMP, 0x1E))
            Store (BA1F, Index(TEMP, 0x1F))
            Return (TEMP)
        }
        Method (WRBA, 1, Serialized)
        {
            Name (TEMP, Buffer(0x20) { })
            Store (Arg0, TEMP)
            Store (DerefOf(Index(TEMP, 0x00)), BA00)
            Store (DerefOf(Index(TEMP, 0x01)), BA01)
            Store (DerefOf(Index(TEMP, 0x02)), BA02)
            Store (DerefOf(Index(TEMP, 0x03)), BA03)
            Store (DerefOf(Index(TEMP, 0x04)), BA04)
            Store (DerefOf(Index(TEMP, 0x05)), BA05)
            Store (DerefOf(Index(TEMP, 0x06)), BA06)
            Store (DerefOf(Index(TEMP, 0x07)), BA07)
            Store (DerefOf(Index(TEMP, 0x08)), BA08)
            Store (DerefOf(Index(TEMP, 0x09)), BA09)
            Store (DerefOf(Index(TEMP, 0x0A)), BA0A)
            Store (DerefOf(Index(TEMP, 0x0B)), BA0B)
            Store (DerefOf(Index(TEMP, 0x0C)), BA0C)
            Store (DerefOf(Index(TEMP, 0x0D)), BA0D)
            Store (DerefOf(Index(TEMP, 0x0E)), BA0E)
            Store (DerefOf(Index(TEMP, 0x0F)), BA0F)
            Store (DerefOf(Index(TEMP, 0x10)), BA10)
            Store (DerefOf(Index(TEMP, 0x11)), BA11)
            Store (DerefOf(Index(TEMP, 0x12)), BA12)
            Store (DerefOf(Index(TEMP, 0x13)), BA13)
            Store (DerefOf(Index(TEMP, 0x14)), BA14)
            Store (DerefOf(Index(TEMP, 0x15)), BA15)
            Store (DerefOf(Index(TEMP, 0x16)), BA16)
            Store (DerefOf(Index(TEMP, 0x17)), BA17)
            Store (DerefOf(Index(TEMP, 0x18)), BA18)
            Store (DerefOf(Index(TEMP, 0x19)), BA19)
            Store (DerefOf(Index(TEMP, 0x1A)), BA1A)
            Store (DerefOf(Index(TEMP, 0x1B)), BA1B)
            Store (DerefOf(Index(TEMP, 0x1C)), BA1C)
            Store (DerefOf(Index(TEMP, 0x1D)), BA1D)
            Store (DerefOf(Index(TEMP, 0x1E)), BA1E)
            Store (DerefOf(Index(TEMP, 0x1F)), BA1F)
        }
        Method (RDBB, 0, Serialized)
        {
            Name (TEMP, Buffer(0x20) { })
            Store (BB00, Index(TEMP, 0x00))
            Store (BB01, Index(TEMP, 0x01))
            Store (BB02, Index(TEMP, 0x02))
            Store (BB03, Index(TEMP, 0x03))
            Store (BB04, Index(TEMP, 0x04))
            Store (BB05, Index(TEMP, 0x05))
            Store (BB06, Index(TEMP, 0x06))
            Store (BB07, Index(TEMP, 0x07))
            Store (BB08, Index(TEMP, 0x08))
            Store (BB09, Index(TEMP, 0x09))
            Store (BB0A, Index(TEMP, 0x0A))
            Store (BB0B, Index(TEMP, 0x0B))
            Store (BB0C, Index(TEMP, 0x0C))
            Store (BB0D, Index(TEMP, 0x0D))
            Store (BB0E, Index(TEMP, 0x0E))
            Store (BB0F, Index(TEMP, 0x0F))
            Store (BB10, Index(TEMP, 0x10))
            Store (BB11, Index(TEMP, 0x11))
            Store (BB12, Index(TEMP, 0x12))
            Store (BB13, Index(TEMP, 0x13))
            Store (BB14, Index(TEMP, 0x14))
            Store (BB15, Index(TEMP, 0x15))
            Store (BB16, Index(TEMP, 0x16))
            Store (BB17, Index(TEMP, 0x17))
            Store (BB18, Index(TEMP, 0x18))
            Store (BB19, Index(TEMP, 0x19))
            Store (BB1A, Index(TEMP, 0x1A))
            Store (BB1B, Index(TEMP, 0x1B))
            Store (BB1C, Index(TEMP, 0x1C))
            Store (BB1D, Index(TEMP, 0x1D))
            Store (BB1E, Index(TEMP, 0x1E))
            Store (BB1F, Index(TEMP, 0x1F))
            Return (TEMP)
        }
        Method (WRBB, 1, Serialized)
        {
            Name (TEMP, Buffer(0x20) { })
            Store (Arg0, TEMP)
            Store (DerefOf(Index(TEMP, 0x00)), BB00)
            Store (DerefOf(Index(TEMP, 0x01)), BB01)
            Store (DerefOf(Index(TEMP, 0x02)), BB02)
            Store (DerefOf(Index(TEMP, 0x03)), BB03)
            Store (DerefOf(Index(TEMP, 0x04)), BB04)
            Store (DerefOf(Index(TEMP, 0x05)), BB05)
            Store (DerefOf(Index(TEMP, 0x06)), BB06)
            Store (DerefOf(Index(TEMP, 0x07)), BB07)
            Store (DerefOf(Index(TEMP, 0x08)), BB08)
            Store (DerefOf(Index(TEMP, 0x09)), BB09)
            Store (DerefOf(Index(TEMP, 0x0A)), BB0A)
            Store (DerefOf(Index(TEMP, 0x0B)), BB0B)
            Store (DerefOf(Index(TEMP, 0x0C)), BB0C)
            Store (DerefOf(Index(TEMP, 0x0D)), BB0D)
            Store (DerefOf(Index(TEMP, 0x0E)), BB0E)
            Store (DerefOf(Index(TEMP, 0x0F)), BB0F)
            Store (DerefOf(Index(TEMP, 0x10)), BB10)
            Store (DerefOf(Index(TEMP, 0x11)), BB11)
            Store (DerefOf(Index(TEMP, 0x12)), BB12)
            Store (DerefOf(Index(TEMP, 0x13)), BB13)
            Store (DerefOf(Index(TEMP, 0x14)), BB14)
            Store (DerefOf(Index(TEMP, 0x15)), BB15)
            Store (DerefOf(Index(TEMP, 0x16)), BB16)
            Store (DerefOf(Index(TEMP, 0x17)), BB17)
            Store (DerefOf(Index(TEMP, 0x18)), BB18)
            Store (DerefOf(Index(TEMP, 0x19)), BB19)
            Store (DerefOf(Index(TEMP, 0x1A)), BB1A)
            Store (DerefOf(Index(TEMP, 0x1B)), BB1B)
            Store (DerefOf(Index(TEMP, 0x1C)), BB1C)
            Store (DerefOf(Index(TEMP, 0x1D)), BB1D)
            Store (DerefOf(Index(TEMP, 0x1E)), BB1E)
            Store (DerefOf(Index(TEMP, 0x1F)), BB1F)
        }
    }
}
</code></pre><p>}</p>
<p>Notice how FBST and _BIX were added to scope _SB.PCI0.BAT0, but BIFA was added to _SB.PCI0.LPCB.EC0. It is important to inject all methods into their original scope.</p>
<p>Now, we add SMBR, SMBW, ECSB, and TACH:<br>Code (Text):</p>
<p>DefinitionBlock(“”, “SSDT”, 2, “hack”, “batt”, 0)<br>{<br>    // patched methods<br>    Scope (_SB.PCI0)<br>    {<br>        Scope (BAT0)<br>        {<br>            Method (FBST, 4, NotSerialized)<br>            {<br>                And (Arg1, 0xFFFF, Local1)<br>                Store (Zero, Local0)<br>                If (^^LPCB.EC0.ACAP ())<br>                {<br>                    Store (One, Local0)<br>                }</p>
<pre><code>If (Local0)
{
    If (CHGS (Zero))
</code></pre><p>{<br>    Store (0x02, Local0)<br>}<br>Else<br>{<br>    Store (Zero, Local0)<br>}<br>                }<br>                Else<br>                {<br>                    Store (One, Local0)<br>                }</p>
<pre><code>            If (BLLO)
            {
                ShiftLeft (One, 0x02, Local2)
                Or (Local0, Local2, Local0)
            }

            If (And (^^LPCB.EC0.EB0S, 0x08))
            {
                ShiftLeft (One, 0x02, Local2)
                Or (Local0, Local2, Local0)
            }

            If (LGreaterEqual (Local1, 0x8000))
            {
                Subtract (0xFFFF, Local1, Local1)
            }

            Store (Arg2, Local2)
            If (LEqual (PUNT, Zero))
            {
                Multiply (Local1, ^^LPCB.EC0.B0DV, Local1)
                Multiply (Local2, 0x0A, Local2)
            }

            And (Local0, 0x02, Local3)
            If (LNot (Local3))
            {
                Subtract (LFCC, Local2, Local3)
                Divide (LFCC, 0xC8, Local4, Local5)
                If (LLess (Local3, Local5))
                {
                    Store (LFCC, Local2)
                }
            }
            Else
            {
                Divide (LFCC, 0xC8, Local4, Local5)
                Subtract (LFCC, Local5, Local4)
                If (LGreater (Local2, Local4))
                {
                    Store (Local4, Local2)
                }
            }

            If (LNot (^^LPCB.EC0.ACAP ()))
            {
                Divide (Local2, MBLF, Local3, Local4)
                If (LLess (Local1, Local4))
                {
                    Store (Local4, Local1)
                }
            }

            Store (Local0, Index (PBST, Zero))
            Store (Local1, Index (PBST, One))
            Store (Local2, Index (PBST, 0x02))
            Store (Arg3, Index (PBST, 0x03))
        }
        Method (_BIX, 0, NotSerialized)  // _BIX: Battery Information Extended
        {
            If (LNot (^^LPCB.EC0.BATP (Zero)))
            {
                Return (NBIX)
            }

            If (LEqual (^^LPCB.EC0.GBTT (Zero), 0xFF))
            {
                Return (NBIX)
            }

            _BIF ()
            Store (DerefOf (Index (PBIF, Zero)), Index (BIXT, One))
            Store (DerefOf (Index (PBIF, One)), Index (BIXT, 0x02))
            Store (DerefOf (Index (PBIF, 0x02)), Index (BIXT, 0x03))
            Store (DerefOf (Index (PBIF, 0x03)), Index (BIXT, 0x04))
            Store (DerefOf (Index (PBIF, 0x04)), Index (BIXT, 0x05))
            Store (DerefOf (Index (PBIF, 0x05)), Index (BIXT, 0x06))
            Store (DerefOf (Index (PBIF, 0x06)), Index (BIXT, 0x07))
            Store (DerefOf (Index (PBIF, 0x07)), Index (BIXT, 0x0E))
            Store (DerefOf (Index (PBIF, 0x08)), Index (BIXT, 0x0F))
            Store (DerefOf (Index (PBIF, 0x09)), Index (BIXT, 0x10))
            Store (DerefOf (Index (PBIF, 0x0A)), Index (BIXT, 0x11))
            Store (DerefOf (Index (PBIF, 0x0B)), Index (BIXT, 0x12))
            Store (DerefOf (Index (PBIF, 0x0C)), Index (BIXT, 0x13))
            If (LEqual (DerefOf (Index (BIXT, One)), One))
            {
                Store (Zero, Index (BIXT, One))
                Store (DerefOf (Index (BIXT, 0x05)), Local0)
                Multiply (DerefOf (Index (BIXT, 0x02)), Local0, Index (BIXT, 0x02))
                Multiply (DerefOf (Index (BIXT, 0x03)), Local0, Index (BIXT, 0x03))
                Multiply (DerefOf (Index (BIXT, 0x06)), Local0, Index (BIXT, 0x06))
                Multiply (DerefOf (Index (BIXT, 0x07)), Local0, Index (BIXT, 0x07))
                Multiply (DerefOf (Index (BIXT, 0x0E)), Local0, Index (BIXT, 0x0E))
                Multiply (DerefOf (Index (BIXT, 0x0F)), Local0, Index (BIXT, 0x0F))
                Divide (DerefOf (Index (BIXT, 0x02)), 0x03E8, Local0, Index (BIXT, 0x02))
                Divide (DerefOf (Index (BIXT, 0x03)), 0x03E8, Local0, Index (BIXT, 0x03))
                Divide (DerefOf (Index (BIXT, 0x06)), 0x03E8, Local0, Index (BIXT, 0x06))
                Divide (DerefOf (Index (BIXT, 0x07)), 0x03E8, Local0, Index (BIXT, 0x07))
                Divide (DerefOf (Index (BIXT, 0x0E)), 0x03E8, Local0, Index (BIXT, 0x0E))
                Divide (DerefOf (Index (BIXT, 0x0F)), 0x03E8, Local0, Index (BIXT, 0x0F))
            }

            Store (B1B2(^^LPCB.EC0.XC30,^^LPCB.EC0.XC31), Index (BIXT, 0x08))
            Store (0x0001869F, Index (BIXT, 0x09))
            Return (BIXT)
        }

}
}
Scope (_SB.PCI0.LPCB.EC0)
{
    Method (BIFA, 0, NotSerialized)
    {
        If (ECAV ())
        {
            If (BSLF)
            {
                Store (B1B2(B1S0,B1S1), Local0)
            }
            Else
            {
                Store (B1B2(B0S0,B0S1), Local0)
            }
        }
        Else
        {
            Store (Ones, Local0)
        }

        Return (Local0)
    }
    Method (SMBR, 3, Serialized)
    {
        Store (Package (0x03)
            {
                0x07,
                Zero,
                Zero
            }, Local0)
        If (LNot (ECAV ()))
        {
            Return (Local0)
        }

        If (LNotEqual (Arg0, RDBL))
        {
            If (LNotEqual (Arg0, RDWD))
            {
                If (LNotEqual (Arg0, RDBT))
                {
                    If (LNotEqual (Arg0, RCBT))
                    {
                        If (LNotEqual (Arg0, RDQK))
                        {
                            Return (Local0)
                        }
                    }
                }
            }
        }

        Acquire (MUEC, 0xFFFF)
        Store (PRTC, Local1)
        Store (Zero, Local2)
        While (LNotEqual (Local1, Zero))
        {
            Stall (0x0A)
            Increment (Local2)
            If (LGreater (Local2, 0x03E8))
            {
                Store (SBBY, Index (Local0, Zero))
                Store (Zero, Local1)
            }
            Else
            {
                Store (PRTC, Local1)
            }
        }

        If (LLessEqual (Local2, 0x03E8))
        {
            ShiftLeft (Arg1, One, Local3)
            Or (Local3, One, Local3)
            Store (Local3, ADDR)
            If (LNotEqual (Arg0, RDQK))
            {
                If (LNotEqual (Arg0, RCBT))
                {
                    Store (Arg2, CMDB)
                }
            }

            WRBA(Zero)
            Store (Arg0, PRTC)
            Store (SWTC (Arg0), Index (Local0, Zero))
            If (LEqual (DerefOf (Index (Local0, Zero)), Zero))
            {
                If (LEqual (Arg0, RDBL))
                {
                    Store (BCNT, Index (Local0, One))
                    Store (RDBA(), Index (Local0, 0x02))
                }

                If (LEqual (Arg0, RDWD))
                {
                    Store (0x02, Index (Local0, One))
                    Store (B1B2(T2B0,T2B1), Index (Local0, 0x02))
                }

                If (LEqual (Arg0, RDBT))
                {
                    Store (One, Index (Local0, One))
                    Store (DAT0, Index (Local0, 0x02))
                }

                If (LEqual (Arg0, RCBT))
                {
                    Store (One, Index (Local0, One))
                    Store (DAT0, Index (Local0, 0x02))
                }
            }
        }

        Release (MUEC)
        Return (Local0)
    }
    Method (SMBW, 5, Serialized)
    {
        Store (Package (0x01)
            {
                0x07
            }, Local0)
        If (LNot (ECAV ()))
        {
            Return (Local0)
        }

        If (LNotEqual (Arg0, WRBL))
        {
            If (LNotEqual (Arg0, WRWD))
            {
                If (LNotEqual (Arg0, WRBT))
                {
                    If (LNotEqual (Arg0, SDBT))
                    {
                        If (LNotEqual (Arg0, WRQK))
                        {
                            Return (Local0)
                        }
                    }
                }
            }
        }

        Acquire (MUEC, 0xFFFF)
        Store (PRTC, Local1)
        Store (Zero, Local2)
        While (LNotEqual (Local1, Zero))
        {
            Stall (0x0A)
            Increment (Local2)
            If (LGreater (Local2, 0x03E8))
            {
                Store (SBBY, Index (Local0, Zero))
                Store (Zero, Local1)
            }
            Else
            {
                Store (PRTC, Local1)
            }
        }

        If (LLessEqual (Local2, 0x03E8))
        {
            WRBA(Zero)
            ShiftLeft (Arg1, One, Local3)
            Store (Local3, ADDR)
            If (LNotEqual (Arg0, WRQK))
            {
                If (LNotEqual (Arg0, SDBT))
                {
                    Store (Arg2, CMDB)
                }
            }

            If (LEqual (Arg0, WRBL))
            {
                Store (Arg3, BCNT)
                WRBA(Arg4)
            }

            If (LEqual (Arg0, WRWD))
            {
                Store(Arg4,T2B0) Store(ShiftRight(Arg4,8),T2B1)
            }

            If (LEqual (Arg0, WRBT))
            {
                Store (Arg4, DAT0)
            }

            If (LEqual (Arg0, SDBT))
            {
                Store (Arg4, DAT0)
            }

            Store (Arg0, PRTC)
            Store (SWTC (Arg0), Index (Local0, Zero))
        }

        Release (MUEC)
        Return (Local0)
    }
    Method (ECSB, 7, NotSerialized)
    {
        Store (Package (0x05)
            {
                0x11,
                Zero,
                Zero,
                Zero,
                Buffer (0x20){}
            }, Local1)
        If (LGreater (Arg0, One))
        {
            Return (Local1)
        }

        If (ECAV ())
        {
            Acquire (MUEC, 0xFFFF)
            If (LEqual (Arg0, Zero))
            {
                Store (PRTC, Local0)
            }
            Else
            {
                Store (PRT2, Local0)
            }

            Store (Zero, Local2)
            While (LNotEqual (Local0, Zero))
            {
                Stall (0x0A)
                Increment (Local2)
                If (LGreater (Local2, 0x03E8))
                {
                    Store (SBBY, Index (Local1, Zero))
                    Store (Zero, Local0)
                }
                ElseIf (LEqual (Arg0, Zero))
                {
                    Store (PRTC, Local0)
                }
                Else
                {
                    Store (PRT2, Local0)
                }
            }

            If (LLessEqual (Local2, 0x03E8))
            {
                If (LEqual (Arg0, Zero))
                {
                    Store (Arg2, ADDR)
                    Store (Arg3, CMDB)
                    If (LOr (LEqual (Arg1, 0x0A), LEqual (Arg1, 0x0B)))
                    {
                        Store (DerefOf (Index (Arg6, Zero)), BCNT)
                        WRBA(DerefOf (Index (Arg6, One)))
                    }
                    Else
                    {
                        Store (Arg4, DAT0)
                        Store (Arg5, DAT1)
                    }

                    Store (Arg1, PRTC)
                }
                Else
                {
                    Store (Arg2, ADD2)
                    Store (Arg3, CMD2)
                    If (LOr (LEqual (Arg1, 0x0A), LEqual (Arg1, 0x0B)))
                    {
                        Store (DerefOf (Index (Arg6, Zero)), BCN2)
                        WRBB(DerefOf (Index (Arg6, One)))
                    }
                    Else
                    {
                        Store (Arg4, DA20)
                        Store (Arg5, DA21)
                    }

                    Store (Arg1, PRT2)
                }

                Store (0x7F, Local0)
                If (LEqual (Arg0, Zero))
                {
                    While (PRTC)
                    {
                        Sleep (One)
                        Decrement (Local0)
                    }
                }
                Else
                {
                    While (PRT2)
                    {
                        Sleep (One)
                        Decrement (Local0)
                    }
                }

                If (Local0)
                {
                    If (LEqual (Arg0, Zero))
                    {
                        Store (SSTS, Local0)
                        Store (DAT0, Index (Local1, One))
                        Store (DAT1, Index (Local1, 0x02))
                        Store (BCNT, Index (Local1, 0x03))
                        Store (RDBA(), Index (Local1, 0x04))
                    }
                    Else
                    {
                        Store (SST2, Local0)
                        Store (DA20, Index (Local1, One))
                        Store (DA21, Index (Local1, 0x02))
                        Store (BCN2, Index (Local1, 0x03))
                        Store (RDBB(), Index (Local1, 0x04))
                    }

                    And (Local0, 0x1F, Local0)
                    If (Local0)
                    {
                        Add (Local0, 0x10, Local0)
                    }

                    Store (Local0, Index (Local1, Zero))
                }
                Else
                {
                    Store (0x10, Index (Local1, Zero))
                }
            }

            Release (MUEC)
        }

        Return (Local1)
    }
    Method (TACH, 1, Serialized)
    {
        If (ECAV ())
        {
            Switch (Arg0)
            {
                Case (Zero)
                {
                    Store (B1B2(TH00,TH01), Local0)
                    Break
                }
                Case (One)
                {
                    Store (B1B2(TH10,TH11), Local0)
                    Break
                }
                Default
                {
                    Return (Ones)
                }

            }

            Multiply (Local0, 0x02, Local0)
            If (LNotEqual (Local0, Zero))
            {
                Divide (0x0041CDB4, Local0, Local1, Local0)
                Return (Local0)
            }
            Else
            {
                Return (Ones)
            }
        }
        Else
        {
            Return (Ones)
        }
    }    
}

Method (B1B2, 2, NotSerialized) { Return (Or (Arg0, ShiftLeft (Arg1, 8))) }

// added methods (group 2)
Scope (_SB.PCI0.LPCB)
{
    Scope (EC0)
    {
        Method (RDBA, 0, Serialized)
        {
            Name (TEMP, Buffer(0x20) { })
            Store (BA00, Index(TEMP, 0x00))
            Store (BA01, Index(TEMP, 0x01))
            Store (BA02, Index(TEMP, 0x02))
            Store (BA03, Index(TEMP, 0x03))
            Store (BA04, Index(TEMP, 0x04))
            Store (BA05, Index(TEMP, 0x05))
            Store (BA06, Index(TEMP, 0x06))
            Store (BA07, Index(TEMP, 0x07))
            Store (BA08, Index(TEMP, 0x08))
            Store (BA09, Index(TEMP, 0x09))
            Store (BA0A, Index(TEMP, 0x0A))
            Store (BA0B, Index(TEMP, 0x0B))
            Store (BA0C, Index(TEMP, 0x0C))
            Store (BA0D, Index(TEMP, 0x0D))
            Store (BA0E, Index(TEMP, 0x0E))
            Store (BA0F, Index(TEMP, 0x0F))
            Store (BA10, Index(TEMP, 0x10))
            Store (BA11, Index(TEMP, 0x11))
            Store (BA12, Index(TEMP, 0x12))
            Store (BA13, Index(TEMP, 0x13))
            Store (BA14, Index(TEMP, 0x14))
            Store (BA15, Index(TEMP, 0x15))
            Store (BA16, Index(TEMP, 0x16))
            Store (BA17, Index(TEMP, 0x17))
            Store (BA18, Index(TEMP, 0x18))
            Store (BA19, Index(TEMP, 0x19))
            Store (BA1A, Index(TEMP, 0x1A))
            Store (BA1B, Index(TEMP, 0x1B))
            Store (BA1C, Index(TEMP, 0x1C))
            Store (BA1D, Index(TEMP, 0x1D))
            Store (BA1E, Index(TEMP, 0x1E))
            Store (BA1F, Index(TEMP, 0x1F))
            Return (TEMP)
        }
        Method (WRBA, 1, Serialized)
        {
            Name (TEMP, Buffer(0x20) { })
            Store (Arg0, TEMP)
            Store (DerefOf(Index(TEMP, 0x00)), BA00)
            Store (DerefOf(Index(TEMP, 0x01)), BA01)
            Store (DerefOf(Index(TEMP, 0x02)), BA02)
            Store (DerefOf(Index(TEMP, 0x03)), BA03)
            Store (DerefOf(Index(TEMP, 0x04)), BA04)
            Store (DerefOf(Index(TEMP, 0x05)), BA05)
            Store (DerefOf(Index(TEMP, 0x06)), BA06)
            Store (DerefOf(Index(TEMP, 0x07)), BA07)
            Store (DerefOf(Index(TEMP, 0x08)), BA08)
            Store (DerefOf(Index(TEMP, 0x09)), BA09)
            Store (DerefOf(Index(TEMP, 0x0A)), BA0A)
            Store (DerefOf(Index(TEMP, 0x0B)), BA0B)
            Store (DerefOf(Index(TEMP, 0x0C)), BA0C)
            Store (DerefOf(Index(TEMP, 0x0D)), BA0D)
            Store (DerefOf(Index(TEMP, 0x0E)), BA0E)
            Store (DerefOf(Index(TEMP, 0x0F)), BA0F)
            Store (DerefOf(Index(TEMP, 0x10)), BA10)
            Store (DerefOf(Index(TEMP, 0x11)), BA11)
            Store (DerefOf(Index(TEMP, 0x12)), BA12)
            Store (DerefOf(Index(TEMP, 0x13)), BA13)
            Store (DerefOf(Index(TEMP, 0x14)), BA14)
            Store (DerefOf(Index(TEMP, 0x15)), BA15)
            Store (DerefOf(Index(TEMP, 0x16)), BA16)
            Store (DerefOf(Index(TEMP, 0x17)), BA17)
            Store (DerefOf(Index(TEMP, 0x18)), BA18)
            Store (DerefOf(Index(TEMP, 0x19)), BA19)
            Store (DerefOf(Index(TEMP, 0x1A)), BA1A)
            Store (DerefOf(Index(TEMP, 0x1B)), BA1B)
            Store (DerefOf(Index(TEMP, 0x1C)), BA1C)
            Store (DerefOf(Index(TEMP, 0x1D)), BA1D)
            Store (DerefOf(Index(TEMP, 0x1E)), BA1E)
            Store (DerefOf(Index(TEMP, 0x1F)), BA1F)
        }
        Method (RDBB, 0, Serialized)
        {
            Name (TEMP, Buffer(0x20) { })
            Store (BB00, Index(TEMP, 0x00))
            Store (BB01, Index(TEMP, 0x01))
            Store (BB02, Index(TEMP, 0x02))
            Store (BB03, Index(TEMP, 0x03))
            Store (BB04, Index(TEMP, 0x04))
            Store (BB05, Index(TEMP, 0x05))
            Store (BB06, Index(TEMP, 0x06))
            Store (BB07, Index(TEMP, 0x07))
            Store (BB08, Index(TEMP, 0x08))
            Store (BB09, Index(TEMP, 0x09))
            Store (BB0A, Index(TEMP, 0x0A))
            Store (BB0B, Index(TEMP, 0x0B))
            Store (BB0C, Index(TEMP, 0x0C))
            Store (BB0D, Index(TEMP, 0x0D))
            Store (BB0E, Index(TEMP, 0x0E))
            Store (BB0F, Index(TEMP, 0x0F))
            Store (BB10, Index(TEMP, 0x10))
            Store (BB11, Index(TEMP, 0x11))
            Store (BB12, Index(TEMP, 0x12))
            Store (BB13, Index(TEMP, 0x13))
            Store (BB14, Index(TEMP, 0x14))
            Store (BB15, Index(TEMP, 0x15))
            Store (BB16, Index(TEMP, 0x16))
            Store (BB17, Index(TEMP, 0x17))
            Store (BB18, Index(TEMP, 0x18))
            Store (BB19, Index(TEMP, 0x19))
            Store (BB1A, Index(TEMP, 0x1A))
            Store (BB1B, Index(TEMP, 0x1B))
            Store (BB1C, Index(TEMP, 0x1C))
            Store (BB1D, Index(TEMP, 0x1D))
            Store (BB1E, Index(TEMP, 0x1E))
            Store (BB1F, Index(TEMP, 0x1F))
            Return (TEMP)
        }
        Method (WRBB, 1, Serialized)
        {
            Name (TEMP, Buffer(0x20) { })
            Store (Arg0, TEMP)
            Store (DerefOf(Index(TEMP, 0x00)), BB00)
            Store (DerefOf(Index(TEMP, 0x01)), BB01)
            Store (DerefOf(Index(TEMP, 0x02)), BB02)
            Store (DerefOf(Index(TEMP, 0x03)), BB03)
            Store (DerefOf(Index(TEMP, 0x04)), BB04)
            Store (DerefOf(Index(TEMP, 0x05)), BB05)
            Store (DerefOf(Index(TEMP, 0x06)), BB06)
            Store (DerefOf(Index(TEMP, 0x07)), BB07)
            Store (DerefOf(Index(TEMP, 0x08)), BB08)
            Store (DerefOf(Index(TEMP, 0x09)), BB09)
            Store (DerefOf(Index(TEMP, 0x0A)), BB0A)
            Store (DerefOf(Index(TEMP, 0x0B)), BB0B)
            Store (DerefOf(Index(TEMP, 0x0C)), BB0C)
            Store (DerefOf(Index(TEMP, 0x0D)), BB0D)
            Store (DerefOf(Index(TEMP, 0x0E)), BB0E)
            Store (DerefOf(Index(TEMP, 0x0F)), BB0F)
            Store (DerefOf(Index(TEMP, 0x10)), BB10)
            Store (DerefOf(Index(TEMP, 0x11)), BB11)
            Store (DerefOf(Index(TEMP, 0x12)), BB12)
            Store (DerefOf(Index(TEMP, 0x13)), BB13)
            Store (DerefOf(Index(TEMP, 0x14)), BB14)
            Store (DerefOf(Index(TEMP, 0x15)), BB15)
            Store (DerefOf(Index(TEMP, 0x16)), BB16)
            Store (DerefOf(Index(TEMP, 0x17)), BB17)
            Store (DerefOf(Index(TEMP, 0x18)), BB18)
            Store (DerefOf(Index(TEMP, 0x19)), BB19)
            Store (DerefOf(Index(TEMP, 0x1A)), BB1A)
            Store (DerefOf(Index(TEMP, 0x1B)), BB1B)
            Store (DerefOf(Index(TEMP, 0x1C)), BB1C)
            Store (DerefOf(Index(TEMP, 0x1D)), BB1D)
            Store (DerefOf(Index(TEMP, 0x1E)), BB1E)
            Store (DerefOf(Index(TEMP, 0x1F)), BB1F)
        }
    }
}
</code></pre><p>}</p>
<p>With all the nodes expanded in MaciASL, our work looks like this:<br>ssd_with_nodes_expanded.png</p>
<p>Resolving errors</p>
<p>Now we need to start resolving errors by using External or defining the patched EC fields as necessary.<br>We can use the compiler to help.<br>Clicking Compile will show the first error: “3, 6085, Object not found or not accessible from scope (_SB.PCI0)”<br>It is at this line:<br>Code (Text):</p>
<pre><code>Scope (_SB.PCI0)
</code></pre><p>The compiler is indicating that _SB.PCI0 is not declared, so you can’t use it in a Scope operator.</p>
<p>We need to declare it with External, as the scope is actually defined in another file (DSDT.aml):<br>Add it to the top of the file:<br>Code (Text):</p>
<p>DefinitionBlock(“”, “SSDT”, 2, “hack”, “batt”, 0)<br>{<br>    External(_SB.PCI0, DeviceObj)<br>    Scope (_SB.PCI0)<br>    {<br>…</p>
<p>Now the next error is at “Scope(BAT0)”, so, again:<br>Code (Text):</p>
<p>DefinitionBlock(“”, “SSDT”, 2, “hack”, “batt”, 0)<br>{<br>    External(_SB.PCI0, DeviceObj)<br>    External(_SB.PCI0.BAT0, DeviceObj)<br>    Scope (_SB.PCI0)<br>    {<br>        Scope (BAT0)<br>        {<br>…</p>
<p>The next error is “13, 6085, Object not found or not accessible from scope (^^LPCB.EC0.ACAP)”<br>We can tell from the code referencing ACAP that it is a method:<br>Code (Text):</p>
<pre><code>If (^^LPCB.EC0.ACAP ())
</code></pre><p>Note: Method calls are indicated by the “()” (in this case, an empty parameter list).</p>
<p>So, we know we can add an External as MethodObj:<br>Code (Text):</p>
<p>DefinitionBlock(“”, “SSDT”, 2, “hack”, “batt”, 0)<br>{<br>    External(_SB.PCI0, DeviceObj)<br>    External(_SB.PCI0.BAT0, DeviceObj)<br>    External(_SB.PCI0.LPCB.EC0.ACAP, MethodObj)<br>…<br>}</p>
<p>Note: The path ^^LPCB.EC0.ACAP is equivalent to _SB.PCI0.LPCB.EC0.ACAP because the reference was in scope _SB.PCI0.BAT0.FBST (the path of the FBST method). Each ^ (parent of) operator walks up the current scope by one item, so ^ is _SB.PCI0.BAT0, and ^^ is _SB.PCI0.</p>
<p>In some cases, you need to look at the DSDT to find the path and/or type of a given identifier. For example, the next error has to do with CHGS. Again, we know it is a method as it is the target of a method call, but for the path, we must refer to the DSDT:<br>Code (Text):</p>
<pre><code>Scope (\)
{
    Method (CHGS, 1, Serialized)
    {
        Store (\_SB.PCI0.LPCB.EC0.BCHG (Arg0), Local0)
        Return (Local0)
    }
</code></pre><p>So, it is in the root:<br>Code (Text):</p>
<p>DefinitionBlock(“”, “SSDT”, 2, “hack”, “batt”, 0)<br>{<br>    External(_SB.PCI0, DeviceObj)<br>    External(_SB.PCI0.BAT0, DeviceObj)<br>    External(_SB.PCI0.LPCB.EC0.ACAP, MethodObj)<br>    External(CHGS, MethodObj)<br>…</p>
<p>The next undefined symbol, BLLO, is something other than a method:<br>Code (Text):</p>
<pre><code>If (BLLO)
{
</code></pre><p>Looking in DSDT, we find it is defined with Name (and it happens to be in root scope):<br>Code (Text):</p>
<pre><code>Name (BLLO, Zero)
</code></pre><p>Which makes it an IntObj:<br>Code (Text):</p>
<p>DefinitionBlock(“”, “SSDT”, 2, “hack”, “batt”, 0)<br>{<br>    External(_SB.PCI0, DeviceObj)<br>    External(_SB.PCI0.BAT0, DeviceObj)<br>    External(_SB.PCI0.LPCB.EC0.ACAP, MethodObj)<br>    External(CHGS, MethodObj)<br>    External(BLLO, IntObj)<br>…</p>
<p>Fixing all the errors in the FBST method:<br>Code (Text):</p>
<p>DefinitionBlock(“”, “SSDT”, 2, “hack”, “batt”, 0)<br>{<br>    External(_SB.PCI0, DeviceObj)<br>    External(_SB.PCI0.BAT0, DeviceObj)<br>    External(_SB.PCI0.LPCB.EC0.ACAP, MethodObj)<br>    External(CHGS, MethodObj)<br>    External(BLLO, IntObj)<br>    External(_SB.PCI0.LPCB.EC0.EB0S, FieldUnitObj)<br>    External(_SB.PCI0.BAT0.PUNT, IntObj)<br>    External(_SB.PCI0.LPCB.EC0.B0DV, FieldUnitObj)<br>    External(_SB.PCI0.BAT0.LFCC, IntObj)<br>    External(MBLF, IntObj)<br>    External(_SB.PCI0.BAT0.PBST, PkgObj)<br>…</p>
<p>And now continue with the same process.</p>
<p>Eventually, you will have:<br>Code (Text):</p>
<p>DefinitionBlock(“”, “SSDT”, 2, “hack”, “batt”, 0)<br>{<br>    External(_SB.PCI0, DeviceObj)<br>    External(_SB.PCI0.BAT0, DeviceObj)<br>    External(_SB.PCI0.LPCB.EC0.ACAP, MethodObj)<br>    External(CHGS, MethodObj)<br>    External(BLLO, IntObj)<br>    External(_SB.PCI0.LPCB.EC0.EB0S, FieldUnitObj)<br>    External(_SB.PCI0.BAT0.PUNT, IntObj)<br>    External(_SB.PCI0.LPCB.EC0.B0DV, FieldUnitObj)<br>    External(_SB.PCI0.BAT0.LFCC, IntObj)<br>    External(MBLF, IntObj)<br>    External(_SB.PCI0.BAT0.PBST, PkgObj)<br>    External(_SB.PCI0.LPCB.EC0.BATP, MethodObj)<br>    External(_SB.PCI0.BAT0.NBIX, PkgObj)<br>    External(_SB.PCI0.LPCB.EC0.GBTT, MethodObj)<br>    External(_SB.PCI0.BAT0._BIF, MethodObj)<br>    External(_SB.PCI0.BAT0.PBIF, PkgObj)<br>    External(_SB.PCI0.BAT0.BIXT, PkgObj)<br>…</p>
<p>And will come to an error with XC30/XC31: “153, 6085, Object not found or not accessible from scope (^^LPCB.EC0.XC30)”</p>
<p>This is one of the 16-bit fields that was broken into two.<br>And this is where it is necessary to create the EC overlay.</p>
<p>To do this, we use another OperationRegion within EC scope, that has a different name than what we find in DSDT:<br>Code (Text):</p>
<pre><code>External(_SB.PCI0.LPCB, DeviceObj)
External(_SB.PCI0.LPCB.EC0, DeviceObj)
Scope(_SB.PCI0.LPCB.EC0)
{
    OperationRegion (ERM2, EmbeddedControl, Zero, 0xFF)
    Field(ERM2, ByteAcc, NoLock, Preserve)
    {
    }
}
</code></pre><p>And from DSDT_patched.dsl, we can get the various patched fields (again refer to the diffmerge).<br>This is the entire set from ECOR in the DSDT_patched.dsl<br>Code (Text):</p>
<pre><code>Offset (0x04),
CMD1,   8,
CDT1,   8,
CDT2,   8,
CDT3,   8,
Offset (0x80),
Offset (0x81),
Offset (0x82),
Offset (0x83),
EB0R,   8,
EB1R,   8,
EPWF,   8,
Offset (0x87),
Offset (0x88),
Offset (0x89),
Offset (0x8A),
HKEN,   1,
Offset (0x93),
TH00,8,TH01,8,
TH10,8,TH11,8,
TSTP,   8,
Offset (0x9C),
CDT4,   8,
CDT5,   8,
Offset (0xA0),
Offset (0xA1),
Offset (0xA2),
Offset (0xA3),
EACT,   8,
TH1R,   8,
TH1L,   8,
TH0R,   8,
TH0L,   8,
Offset (0xB0),
B0PN,   16,
Offset (0xB4),
Offset (0xB6),
Offset (0xB8),
Offset (0xBA),
Offset (0xBC),
Offset (0xBE),
B0TM,   16,
B0C1,   16,
B0C2,   16,
XC30,8,XC31,8,
B0C4,   16,
Offset (0xD0),
B1PN,   16,
Offset (0xD4),
Offset (0xD6),
Offset (0xD8),
Offset (0xDA),
Offset (0xDC),
Offset (0xDE),
B1TM,   16,
B1C1,   16,
B1C2,   16,
YC30,8,YC31,8,
B1C4,   16,
Offset (0xF0),
Offset (0xF2),
Offset (0xF4),
B0S0,8,B0S1,8,
Offset (0xF8),
Offset (0xFA),
Offset (0xFC),
B1S0,8,B1S1,8
</code></pre><p>And if we strip the unpatched identifiers, but keep the offsets correct (very important!):<br>Code (Text):</p>
<pre><code>Offset (0x93),
TH00,8,TH01,8,
TH10,8,TH11,8,
Offset (0xBE),
/*B0TM*/,   16,
/*B0C1*/,   16,
/*B0C2*/,   16,
XC30,8,XC31,8,
Offset (0xDE),
/*B1TM*/,   16,
/*B1C1*/,   16,
/*B1C2*/,   16,
YC30,8,YC31,8,
Offset (0xF4),
B0S0,8,B0S1,8,
Offset (0xFC),
B1S0,8,B1S1,8
</code></pre><p>The same thing can be written as follows:<br>Code (Text):</p>
<pre><code>Offset (0x93),
TH00,8,TH01,8,
TH10,8,TH11,8,
Offset (0xc4),
XC30,8,XC31,8,
Offset (0xe4),
YC30,8,YC31,8,
Offset (0xF4),
B0S0,8,B0S1,8,
Offset (0xFC),
B1S0,8,B1S1,8
</code></pre><p>So, into our SSDT:<br>Code (Text):</p>
<p>DefinitionBlock(“”, “SSDT”, 2, “hack”, “batt”, 0)<br>{<br>    External(_SB.PCI0, DeviceObj)<br>    External(_SB.PCI0.BAT0, DeviceObj)<br>    External(_SB.PCI0.LPCB.EC0.ACAP, MethodObj)<br>    External(CHGS, MethodObj)<br>    External(BLLO, IntObj)<br>    External(_SB.PCI0.LPCB.EC0.EB0S, FieldUnitObj)<br>    External(_SB.PCI0.BAT0.PUNT, IntObj)<br>    External(_SB.PCI0.LPCB.EC0.B0DV, FieldUnitObj)<br>    External(_SB.PCI0.BAT0.LFCC, IntObj)<br>    External(MBLF, IntObj)<br>    External(_SB.PCI0.BAT0.PBST, PkgObj)<br>    External(_SB.PCI0.LPCB.EC0.BATP, MethodObj)<br>    External(_SB.PCI0.BAT0.NBIX, PkgObj)<br>    External(_SB.PCI0.LPCB.EC0.GBTT, MethodObj)<br>    External(_SB.PCI0.BAT0._BIF, MethodObj)<br>    External(_SB.PCI0.BAT0.PBIF, PkgObj)<br>    External(_SB.PCI0.BAT0.BIXT, PkgObj)</p>
<pre><code>External(_SB.PCI0.LPCB, DeviceObj)
External(_SB.PCI0.LPCB.EC0, DeviceObj)
Scope(_SB.PCI0.LPCB.EC0)
{
    OperationRegion (ERM2, EmbeddedControl, Zero, 0xFF)
    Field(ERM2, ByteAcc, NoLock, Preserve)
    {
            Offset (0x93),
            TH00,8,TH01,8,
            TH10,8,TH11,8,
            Offset (0xc4),
            XC30,8,XC31,8,
            Offset (0xe4),
            YC30,8,YC31,8,
            Offset (0xF4),
            B0S0,8,B0S1,8,
            Offset (0xFC),
            B1S0,8,B1S1,8
    }
}
</code></pre><p>And then on to fixing more errors, we add some more External:<br>Code (Text):</p>
<p>DefinitionBlock(“”, “SSDT”, 2, “hack”, “batt”, 0)<br>{<br>    External(_SB.PCI0, DeviceObj)<br>    External(_SB.PCI0.BAT0, DeviceObj)<br>    External(_SB.PCI0.LPCB.EC0.ACAP, MethodObj)<br>    External(CHGS, MethodObj)<br>    External(BLLO, IntObj)<br>    External(_SB.PCI0.LPCB.EC0.EB0S, FieldUnitObj)<br>    External(_SB.PCI0.BAT0.PUNT, IntObj)<br>    External(_SB.PCI0.LPCB.EC0.B0DV, FieldUnitObj)<br>    External(_SB.PCI0.BAT0.LFCC, IntObj)<br>    External(MBLF, IntObj)<br>    External(_SB.PCI0.BAT0.PBST, PkgObj)<br>    External(_SB.PCI0.LPCB.EC0.BATP, MethodObj)<br>    External(_SB.PCI0.BAT0.NBIX, PkgObj)<br>    External(_SB.PCI0.LPCB.EC0.GBTT, MethodObj)<br>    External(_SB.PCI0.BAT0._BIF, MethodObj)<br>    External(_SB.PCI0.BAT0.PBIF, PkgObj)<br>    External(_SB.PCI0.BAT0.BIXT, PkgObj)<br>    External(_SB.PCI0.LPCB.EC0.ECAV, MethodObj)<br>    External(BSLF, IntObj)<br>    External(_SB.PCI0.LPCB.EC0.RDBL, IntObj)<br>    External(_SB.PCI0.LPCB.EC0.RDWD, IntObj)<br>    External(_SB.PCI0.LPCB.EC0.RDBT, IntObj)<br>    External(_SB.PCI0.LPCB.EC0.RCBT, IntObj)<br>    External(_SB.PCI0.LPCB.EC0.RDQK, IntObj)<br>    External(_SB.PCI0.LPCB.EC0.MUEC, MutexObj)<br>    External(_SB.PCI0.LPCB.EC0.PRTC, FieldUnitObj)<br>    External(_SB.PCI0.LPCB.EC0.SBBY, IntObj)<br>    External(_SB.PCI0.LPCB.EC0.ADDR, FieldUnitObj)<br>    External(_SB.PCI0.LPCB.EC0.CMDB, FieldUnitObj)<br>    External(_SB.PCI0.LPCB.EC0.SWTC, MethodObj)<br>    External(_SB.PCI0.LPCB.EC0.BCNT, FieldUnitObj)</p>
<pre><code>External(_SB.PCI0.LPCB, DeviceObj)
External(_SB.PCI0.LPCB.EC0, DeviceObj)
Scope(_SB.PCI0.LPCB.EC0)
{
</code></pre><p>…</p>
<p>And then we have errors with T2B0 and T2B1. These are again broken down 16-bit EC fields that need to be defined in our EC overlay. In fact, might as well define the rest we know we need (from diffmerge data).</p>
<p>There is patched data in SMBX:<br>Code (Text):</p>
<pre><code>OperationRegion (SMBX, EmbeddedControl, 0x18, 0x28)
</code></pre><p>So, we create a similar overlay, with a unique name:<br>Code (Text):</p>
<pre><code>OperationRegion (RMB1, EmbeddedControl, 0x18, 0x28)
Field (RMB1, ByteAcc, NoLock, Preserve)
{
</code></pre><p>/<em> Note: disabling these fields (already defined in DSDT, referenced with External if needed,<br>     but keeping the correct offset! (very important!) </em>/<br>/<em><br>                PRTC,   8,<br>                SSTS,   5,<br>                    ,   1,<br>                ALFG,   1,<br>                CDFG,   1,<br>                ADDR,   8,<br>                CMDB,   8, </em>/<br>         Offset(4), // the data above is 4 bytes offset from the start of this region!<br>                //BDAT, 256,<br>BA00,8,BA01,8,BA02,8,BA03,8,<br>BA04,8,BA05,8,BA06,8,BA07,8,<br>BA08,8,BA09,8,BA0A,8,BA0B,8,<br>BA0C,8,BA0D,8,BA0E,8,BA0F,8,<br>BA10,8,BA11,8,BA12,8,BA13,8,<br>BA14,8,BA15,8,BA16,8,BA17,8,<br>BA18,8,BA19,8,BA1A,8,BA1B,8,<br>BA1C,8,BA1D,8,BA1E,8,BA1F,8<br>            }</p>
<p>And similar withe SMB2 region:<br>Code (Text):</p>
<pre><code>OperationRegion(RMB2, EmbeddedControl, 0x40, 0x28)
Field (RMB2, ByteAcc, NoLock, Preserve)
{
</code></pre><p>/<em><br>                PRT2,   8,<br>                SST2,   5,<br>                    ,   1,<br>                ALF2,   1,<br>                CDF2,   1,<br>                ADD2,   8,<br>                CMD2,   8, </em>/<br>      Offset(4),<br>                //BDA2, 256,<br>BB00,8,BB01,8,BB02,8,BB03,8,<br>BB04,8,BB05,8,BB06,8,BB07,8,<br>BB08,8,BB09,8,BB0A,8,BB0B,8,<br>BB0C,8,BB0D,8,BB0E,8,BB0F,8,<br>BB10,8,BB11,8,BB12,8,BB13,8,<br>BB14,8,BB15,8,BB16,8,BB17,8,<br>BB18,8,BB19,8,BB1A,8,BB1B,8,<br>BB1C,8,BB1D,8,BB1E,8,BB1F,8<br>            }</p>
<p>And the T2B0 and T2B1 that are in orginal SMBX, but now RMB1:<br>Code (Text):</p>
<pre><code>Field (RMB1, ByteAcc, NoLock, Preserve)
{
    Offset (0x04),
    T2B0,8,T2B1,8
}
</code></pre><p>And now we have:<br>Code (Text):</p>
<pre><code>External(_SB.PCI0, DeviceObj)
External(_SB.PCI0.BAT0, DeviceObj)
External(_SB.PCI0.LPCB.EC0.ACAP, MethodObj)
External(CHGS, MethodObj)
External(BLLO, IntObj)
External(_SB.PCI0.LPCB.EC0.EB0S, FieldUnitObj)
External(_SB.PCI0.BAT0.PUNT, IntObj)
External(_SB.PCI0.LPCB.EC0.B0DV, FieldUnitObj)
External(_SB.PCI0.BAT0.LFCC, IntObj)
External(MBLF, IntObj)
External(_SB.PCI0.BAT0.PBST, PkgObj)
External(_SB.PCI0.LPCB.EC0.BATP, MethodObj)
External(_SB.PCI0.BAT0.NBIX, PkgObj)
External(_SB.PCI0.LPCB.EC0.GBTT, MethodObj)
External(_SB.PCI0.BAT0._BIF, MethodObj)
External(_SB.PCI0.BAT0.PBIF, PkgObj)
External(_SB.PCI0.BAT0.BIXT, PkgObj)
External(_SB.PCI0.LPCB.EC0.ECAV, MethodObj)
External(BSLF, IntObj)
External(_SB.PCI0.LPCB.EC0.RDBL, IntObj)
External(_SB.PCI0.LPCB.EC0.RDWD, IntObj)
External(_SB.PCI0.LPCB.EC0.RDBT, IntObj)
External(_SB.PCI0.LPCB.EC0.RCBT, IntObj)
External(_SB.PCI0.LPCB.EC0.RDQK, IntObj)
External(_SB.PCI0.LPCB.EC0.MUEC, MutexObj)
External(_SB.PCI0.LPCB.EC0.PRTC, FieldUnitObj)
External(_SB.PCI0.LPCB.EC0.SBBY, IntObj)
External(_SB.PCI0.LPCB.EC0.ADDR, FieldUnitObj)
External(_SB.PCI0.LPCB.EC0.CMDB, FieldUnitObj)
External(_SB.PCI0.LPCB.EC0.SWTC, MethodObj)
External(_SB.PCI0.LPCB.EC0.BCNT, FieldUnitObj)

External(_SB.PCI0.LPCB, DeviceObj)
External(_SB.PCI0.LPCB.EC0, DeviceObj)
Scope(_SB.PCI0.LPCB.EC0)
{
        OperationRegion (ERM2, EmbeddedControl, Zero, 0xFF)
        Field(ERM2, ByteAcc, NoLock, Preserve)
        {
            Offset (0x93),
            TH00,8,TH01,8,
            TH10,8,TH11,8,
            Offset (0xc4),
            XC30,8,XC31,8,
            Offset (0xe4),
            YC30,8,YC31,8,
            Offset (0xF4),
            B0S0,8,B0S1,8,
            Offset (0xFC),
            B1S0,8,B1S1,8
        }
        OperationRegion (RMB1, EmbeddedControl, 0x18, 0x28)
        Field (RMB1, ByteAcc, NoLock, Preserve)
        {
</code></pre><p>/<em> Note: disabling these fields (already defined in DSDT, referenced with External if needed,<br>     but keeping the correct offset! (very important!) </em>/<br>/<em><br>                PRTC,   8,<br>                SSTS,   5,<br>                    ,   1,<br>                ALFG,   1,<br>                CDFG,   1,<br>                ADDR,   8,<br>                CMDB,   8, </em>/<br>         Offset(4), // the data above is 4 bytes offset from the start of this region!<br>                //BDAT, 256,<br>BA00,8,BA01,8,BA02,8,BA03,8,<br>BA04,8,BA05,8,BA06,8,BA07,8,<br>BA08,8,BA09,8,BA0A,8,BA0B,8,<br>BA0C,8,BA0D,8,BA0E,8,BA0F,8,<br>BA10,8,BA11,8,BA12,8,BA13,8,<br>BA14,8,BA15,8,BA16,8,BA17,8,<br>BA18,8,BA19,8,BA1A,8,BA1B,8,<br>BA1C,8,BA1D,8,BA1E,8,BA1F,8<br>            }<br>            OperationRegion(RMB2, EmbeddedControl, 0x40, 0x28)<br>            Field (RMB2, ByteAcc, NoLock, Preserve)<br>            {<br>/<em><br>                PRT2,   8,<br>                SST2,   5,<br>                    ,   1,<br>                ALF2,   1,<br>                CDF2,   1,<br>                ADD2,   8,<br>                CMD2,   8, </em>/<br>      Offset(4),<br>                //BDA2, 256,<br>BB00,8,BB01,8,BB02,8,BB03,8,<br>BB04,8,BB05,8,BB06,8,BB07,8,<br>BB08,8,BB09,8,BB0A,8,BB0B,8,<br>BB0C,8,BB0D,8,BB0E,8,BB0F,8,<br>BB10,8,BB11,8,BB12,8,BB13,8,<br>BB14,8,BB15,8,BB16,8,BB17,8,<br>BB18,8,BB19,8,BB1A,8,BB1B,8,<br>BB1C,8,BB1D,8,BB1E,8,BB1F,8<br>            }<br>            Field (RMB1, ByteAcc, NoLock, Preserve)<br>            {<br>                Offset (0x04),<br>                T2B0,8,T2B1,8<br>            }<br>    }</p>
<p>Then continue on with fixing more errors with External (it ends eventually!), by adding these External declarations:<br>Code (Text):</p>
<pre><code>External(_SB.PCI0.LPCB.EC0.DAT0, FieldUnitObj)
External(_SB.PCI0.LPCB.EC0.WRBL, IntObj)
External(_SB.PCI0.LPCB.EC0.WRWD, IntObj)
External(_SB.PCI0.LPCB.EC0.WRBT, IntObj)
External(_SB.PCI0.LPCB.EC0.SDBT, IntObj)
External(_SB.PCI0.LPCB.EC0.WRQK, IntObj)
External(_SB.PCI0.LPCB.EC0.PRT2, FieldUnitObj)
External(_SB.PCI0.LPCB.EC0.DAT1, FieldUnitObj)
External(_SB.PCI0.LPCB.EC0.ADD2, FieldUnitObj)
External(_SB.PCI0.LPCB.EC0.CMD2, FieldUnitObj)
External(_SB.PCI0.LPCB.EC0.BCN2, FieldUnitObj)
External(_SB.PCI0.LPCB.EC0.DA20, FieldUnitObj)
External(_SB.PCI0.LPCB.EC0.DA21, FieldUnitObj)
External(_SB.PCI0.LPCB.EC0.SSTS, FieldUnitObj)
External(_SB.PCI0.LPCB.EC0.SST2, FieldUnitObj)
</code></pre><p>Note: With DAT0, don’t be confused at the “other” DAT0 in a different scope!</p>
<p>At this point, the SSDT compiles without any errors:<br>Code (Text):</p>
<p>DefinitionBlock(“”, “SSDT”, 2, “hack”, “batt”, 0)<br>{<br>    External(_SB.PCI0, DeviceObj)<br>    External(_SB.PCI0.BAT0, DeviceObj)<br>    External(_SB.PCI0.LPCB.EC0.ACAP, MethodObj)<br>    External(CHGS, MethodObj)<br>    External(BLLO, IntObj)<br>    External(_SB.PCI0.LPCB.EC0.EB0S, FieldUnitObj)<br>    External(_SB.PCI0.BAT0.PUNT, IntObj)<br>    External(_SB.PCI0.LPCB.EC0.B0DV, FieldUnitObj)<br>    External(_SB.PCI0.BAT0.LFCC, IntObj)<br>    External(MBLF, IntObj)<br>    External(_SB.PCI0.BAT0.PBST, PkgObj)<br>    External(_SB.PCI0.LPCB.EC0.BATP, MethodObj)<br>    External(_SB.PCI0.BAT0.NBIX, PkgObj)<br>    External(_SB.PCI0.LPCB.EC0.GBTT, MethodObj)<br>    External(_SB.PCI0.BAT0._BIF, MethodObj)<br>    External(_SB.PCI0.BAT0.PBIF, PkgObj)<br>    External(_SB.PCI0.BAT0.BIXT, PkgObj)<br>    External(_SB.PCI0.LPCB.EC0.ECAV, MethodObj)<br>    External(BSLF, IntObj)<br>    External(_SB.PCI0.LPCB.EC0.RDBL, IntObj)<br>    External(_SB.PCI0.LPCB.EC0.RDWD, IntObj)<br>    External(_SB.PCI0.LPCB.EC0.RDBT, IntObj)<br>    External(_SB.PCI0.LPCB.EC0.RCBT, IntObj)<br>    External(_SB.PCI0.LPCB.EC0.RDQK, IntObj)<br>    External(_SB.PCI0.LPCB.EC0.MUEC, MutexObj)<br>    External(_SB.PCI0.LPCB.EC0.PRTC, FieldUnitObj)<br>    External(_SB.PCI0.LPCB.EC0.SBBY, IntObj)<br>    External(_SB.PCI0.LPCB.EC0.ADDR, FieldUnitObj)<br>    External(_SB.PCI0.LPCB.EC0.CMDB, FieldUnitObj)<br>    External(_SB.PCI0.LPCB.EC0.SWTC, MethodObj)<br>    External(_SB.PCI0.LPCB.EC0.BCNT, FieldUnitObj)<br>    External(_SB.PCI0.LPCB.EC0.DAT0, FieldUnitObj)<br>    External(_SB.PCI0.LPCB.EC0.WRBL, IntObj)<br>    External(_SB.PCI0.LPCB.EC0.WRWD, IntObj)<br>    External(_SB.PCI0.LPCB.EC0.WRBT, IntObj)<br>    External(_SB.PCI0.LPCB.EC0.SDBT, IntObj)<br>    External(_SB.PCI0.LPCB.EC0.WRQK, IntObj)<br>    External(_SB.PCI0.LPCB.EC0.PRT2, FieldUnitObj)<br>    External(_SB.PCI0.LPCB.EC0.DAT1, FieldUnitObj)<br>    External(_SB.PCI0.LPCB.EC0.ADD2, FieldUnitObj)<br>    External(_SB.PCI0.LPCB.EC0.CMD2, FieldUnitObj)<br>    External(_SB.PCI0.LPCB.EC0.BCN2, FieldUnitObj)<br>    External(_SB.PCI0.LPCB.EC0.DA20, FieldUnitObj)<br>    External(_SB.PCI0.LPCB.EC0.DA21, FieldUnitObj)<br>    External(_SB.PCI0.LPCB.EC0.SSTS, FieldUnitObj)<br>    External(_SB.PCI0.LPCB.EC0.SST2, FieldUnitObj)</p>
<pre><code>External(_SB.PCI0.LPCB, DeviceObj)
External(_SB.PCI0.LPCB.EC0, DeviceObj)
Scope(_SB.PCI0.LPCB.EC0)
{
        OperationRegion (ERM2, EmbeddedControl, Zero, 0xFF)
        Field(ERM2, ByteAcc, NoLock, Preserve)
        {
            Offset (0x93),
            TH00,8,TH01,8,
            TH10,8,TH11,8,
            Offset (0xc4),
            XC30,8,XC31,8,
            Offset (0xe4),
            YC30,8,YC31,8,
            Offset (0xF4),
            B0S0,8,B0S1,8,
            Offset (0xFC),
            B1S0,8,B1S1,8
        }
        OperationRegion (RMB1, EmbeddedControl, 0x18, 0x28)
        Field (RMB1, ByteAcc, NoLock, Preserve)
        {
</code></pre><p>/<em> Note: disabling these fields (already defined in DSDT, referenced with External if needed,<br>     but keeping the correct offset! (very important!) </em>/<br>/<em><br>                PRTC,   8,<br>                SSTS,   5,<br>                    ,   1,<br>                ALFG,   1,<br>                CDFG,   1,<br>                ADDR,   8,<br>                CMDB,   8, </em>/<br>         Offset(4), // the data above is 4 bytes offset from the start of this region!<br>                //BDAT, 256,<br>BA00,8,BA01,8,BA02,8,BA03,8,<br>BA04,8,BA05,8,BA06,8,BA07,8,<br>BA08,8,BA09,8,BA0A,8,BA0B,8,<br>BA0C,8,BA0D,8,BA0E,8,BA0F,8,<br>BA10,8,BA11,8,BA12,8,BA13,8,<br>BA14,8,BA15,8,BA16,8,BA17,8,<br>BA18,8,BA19,8,BA1A,8,BA1B,8,<br>BA1C,8,BA1D,8,BA1E,8,BA1F,8<br>            }<br>            OperationRegion(RMB2, EmbeddedControl, 0x40, 0x28)<br>            Field (RMB2, ByteAcc, NoLock, Preserve)<br>            {<br>/<em><br>                PRT2,   8,<br>                SST2,   5,<br>                    ,   1,<br>                ALF2,   1,<br>                CDF2,   1,<br>                ADD2,   8,<br>                CMD2,   8, </em>/<br>      Offset(4),<br>                //BDA2, 256,<br>BB00,8,BB01,8,BB02,8,BB03,8,<br>BB04,8,BB05,8,BB06,8,BB07,8,<br>BB08,8,BB09,8,BB0A,8,BB0B,8,<br>BB0C,8,BB0D,8,BB0E,8,BB0F,8,<br>BB10,8,BB11,8,BB12,8,BB13,8,<br>BB14,8,BB15,8,BB16,8,BB17,8,<br>BB18,8,BB19,8,BB1A,8,BB1B,8,<br>BB1C,8,BB1D,8,BB1E,8,BB1F,8<br>            }<br>            Field (RMB1, ByteAcc, NoLock, Preserve)<br>            {<br>                Offset (0x04),<br>                T2B0,8,T2B1,8<br>            }<br>    }</p>
<pre><code>Scope (_SB.PCI0)
{
    Scope (BAT0)
    {
        Method (FBST, 4, NotSerialized)
        {
            And (Arg1, 0xFFFF, Local1)
            Store (Zero, Local0)
            If (^^LPCB.EC0.ACAP ())
            {
                Store (One, Local0)
            }

            If (Local0)
            {
                If (CHGS (Zero))
</code></pre><p>{<br>    Store (0x02, Local0)<br>}<br>Else<br>{<br>    Store (Zero, Local0)<br>}<br>                }<br>                Else<br>                {<br>                    Store (One, Local0)<br>                }</p>
<pre><code>            If (BLLO)
            {
                ShiftLeft (One, 0x02, Local2)
                Or (Local0, Local2, Local0)
            }

            If (And (^^LPCB.EC0.EB0S, 0x08))
            {
                ShiftLeft (One, 0x02, Local2)
                Or (Local0, Local2, Local0)
            }

            If (LGreaterEqual (Local1, 0x8000))
            {
                Subtract (0xFFFF, Local1, Local1)
            }

            Store (Arg2, Local2)
            If (LEqual (PUNT, Zero))
            {
                Multiply (Local1, ^^LPCB.EC0.B0DV, Local1)
                Multiply (Local2, 0x0A, Local2)
            }

            And (Local0, 0x02, Local3)
            If (LNot (Local3))
            {
                Subtract (LFCC, Local2, Local3)
                Divide (LFCC, 0xC8, Local4, Local5)
                If (LLess (Local3, Local5))
                {
                    Store (LFCC, Local2)
                }
            }
            Else
            {
                Divide (LFCC, 0xC8, Local4, Local5)
                Subtract (LFCC, Local5, Local4)
                If (LGreater (Local2, Local4))
                {
                    Store (Local4, Local2)
                }
            }

            If (LNot (^^LPCB.EC0.ACAP ()))
            {
                Divide (Local2, MBLF, Local3, Local4)
                If (LLess (Local1, Local4))
                {
                    Store (Local4, Local1)
                }
            }

            Store (Local0, Index (PBST, Zero))
            Store (Local1, Index (PBST, One))
            Store (Local2, Index (PBST, 0x02))
            Store (Arg3, Index (PBST, 0x03))
        }
        Method (_BIX, 0, NotSerialized)  // _BIX: Battery Information Extended
        {
            If (LNot (^^LPCB.EC0.BATP (Zero)))
            {
                Return (NBIX)
            }

            If (LEqual (^^LPCB.EC0.GBTT (Zero), 0xFF))
            {
                Return (NBIX)
            }

            _BIF ()
            Store (DerefOf (Index (PBIF, Zero)), Index (BIXT, One))
            Store (DerefOf (Index (PBIF, One)), Index (BIXT, 0x02))
            Store (DerefOf (Index (PBIF, 0x02)), Index (BIXT, 0x03))
            Store (DerefOf (Index (PBIF, 0x03)), Index (BIXT, 0x04))
            Store (DerefOf (Index (PBIF, 0x04)), Index (BIXT, 0x05))
            Store (DerefOf (Index (PBIF, 0x05)), Index (BIXT, 0x06))
            Store (DerefOf (Index (PBIF, 0x06)), Index (BIXT, 0x07))
            Store (DerefOf (Index (PBIF, 0x07)), Index (BIXT, 0x0E))
            Store (DerefOf (Index (PBIF, 0x08)), Index (BIXT, 0x0F))
            Store (DerefOf (Index (PBIF, 0x09)), Index (BIXT, 0x10))
            Store (DerefOf (Index (PBIF, 0x0A)), Index (BIXT, 0x11))
            Store (DerefOf (Index (PBIF, 0x0B)), Index (BIXT, 0x12))
            Store (DerefOf (Index (PBIF, 0x0C)), Index (BIXT, 0x13))
            If (LEqual (DerefOf (Index (BIXT, One)), One))
            {
                Store (Zero, Index (BIXT, One))
                Store (DerefOf (Index (BIXT, 0x05)), Local0)
                Multiply (DerefOf (Index (BIXT, 0x02)), Local0, Index (BIXT, 0x02))
                Multiply (DerefOf (Index (BIXT, 0x03)), Local0, Index (BIXT, 0x03))
                Multiply (DerefOf (Index (BIXT, 0x06)), Local0, Index (BIXT, 0x06))
                Multiply (DerefOf (Index (BIXT, 0x07)), Local0, Index (BIXT, 0x07))
                Multiply (DerefOf (Index (BIXT, 0x0E)), Local0, Index (BIXT, 0x0E))
                Multiply (DerefOf (Index (BIXT, 0x0F)), Local0, Index (BIXT, 0x0F))
                Divide (DerefOf (Index (BIXT, 0x02)), 0x03E8, Local0, Index (BIXT, 0x02))
                Divide (DerefOf (Index (BIXT, 0x03)), 0x03E8, Local0, Index (BIXT, 0x03))
                Divide (DerefOf (Index (BIXT, 0x06)), 0x03E8, Local0, Index (BIXT, 0x06))
                Divide (DerefOf (Index (BIXT, 0x07)), 0x03E8, Local0, Index (BIXT, 0x07))
                Divide (DerefOf (Index (BIXT, 0x0E)), 0x03E8, Local0, Index (BIXT, 0x0E))
                Divide (DerefOf (Index (BIXT, 0x0F)), 0x03E8, Local0, Index (BIXT, 0x0F))
            }

            Store (B1B2(^^LPCB.EC0.XC30,^^LPCB.EC0.XC31), Index (BIXT, 0x08))
            Store (0x0001869F, Index (BIXT, 0x09))
            Return (BIXT)
        }

}
}
Scope (_SB.PCI0.LPCB.EC0)
{
    Method (BIFA, 0, NotSerialized)
    {
        If (ECAV ())
        {
            If (BSLF)
            {
                Store (B1B2(B1S0,B1S1), Local0)
            }
            Else
            {
                Store (B1B2(B0S0,B0S1), Local0)
            }
        }
        Else
        {
            Store (Ones, Local0)
        }

        Return (Local0)
    }
    Method (SMBR, 3, Serialized)
    {
        Store (Package (0x03)
            {
                0x07,
                Zero,
                Zero
            }, Local0)
        If (LNot (ECAV ()))
        {
            Return (Local0)
        }

        If (LNotEqual (Arg0, RDBL))
        {
            If (LNotEqual (Arg0, RDWD))
            {
                If (LNotEqual (Arg0, RDBT))
                {
                    If (LNotEqual (Arg0, RCBT))
                    {
                        If (LNotEqual (Arg0, RDQK))
                        {
                            Return (Local0)
                        }
                    }
                }
            }
        }

        Acquire (MUEC, 0xFFFF)
        Store (PRTC, Local1)
        Store (Zero, Local2)
        While (LNotEqual (Local1, Zero))
        {
            Stall (0x0A)
            Increment (Local2)
            If (LGreater (Local2, 0x03E8))
            {
                Store (SBBY, Index (Local0, Zero))
                Store (Zero, Local1)
            }
            Else
            {
                Store (PRTC, Local1)
            }
        }

        If (LLessEqual (Local2, 0x03E8))
        {
            ShiftLeft (Arg1, One, Local3)
            Or (Local3, One, Local3)
            Store (Local3, ADDR)
            If (LNotEqual (Arg0, RDQK))
            {
                If (LNotEqual (Arg0, RCBT))
                {
                    Store (Arg2, CMDB)
                }
            }

            WRBA(Zero)
            Store (Arg0, PRTC)
            Store (SWTC (Arg0), Index (Local0, Zero))
            If (LEqual (DerefOf (Index (Local0, Zero)), Zero))
            {
                If (LEqual (Arg0, RDBL))
                {
                    Store (BCNT, Index (Local0, One))
                    Store (RDBA(), Index (Local0, 0x02))
                }

                If (LEqual (Arg0, RDWD))
                {
                    Store (0x02, Index (Local0, One))
                    Store (B1B2(T2B0,T2B1), Index (Local0, 0x02))
                }

                If (LEqual (Arg0, RDBT))
                {
                    Store (One, Index (Local0, One))
                    Store (DAT0, Index (Local0, 0x02))
                }

                If (LEqual (Arg0, RCBT))
                {
                    Store (One, Index (Local0, One))
                    Store (DAT0, Index (Local0, 0x02))
                }
            }
        }

        Release (MUEC)
        Return (Local0)
    }
    Method (SMBW, 5, Serialized)
    {
        Store (Package (0x01)
            {
                0x07
            }, Local0)
        If (LNot (ECAV ()))
        {
            Return (Local0)
        }

        If (LNotEqual (Arg0, WRBL))
        {
            If (LNotEqual (Arg0, WRWD))
            {
                If (LNotEqual (Arg0, WRBT))
                {
                    If (LNotEqual (Arg0, SDBT))
                    {
                        If (LNotEqual (Arg0, WRQK))
                        {
                            Return (Local0)
                        }
                    }
                }
            }
        }

        Acquire (MUEC, 0xFFFF)
        Store (PRTC, Local1)
        Store (Zero, Local2)
        While (LNotEqual (Local1, Zero))
        {
            Stall (0x0A)
            Increment (Local2)
            If (LGreater (Local2, 0x03E8))
            {
                Store (SBBY, Index (Local0, Zero))
                Store (Zero, Local1)
            }
            Else
            {
                Store (PRTC, Local1)
            }
        }

        If (LLessEqual (Local2, 0x03E8))
        {
            WRBA(Zero)
            ShiftLeft (Arg1, One, Local3)
            Store (Local3, ADDR)
            If (LNotEqual (Arg0, WRQK))
            {
                If (LNotEqual (Arg0, SDBT))
                {
                    Store (Arg2, CMDB)
                }
            }

            If (LEqual (Arg0, WRBL))
            {
                Store (Arg3, BCNT)
                WRBA(Arg4)
            }

            If (LEqual (Arg0, WRWD))
            {
                Store(Arg4,T2B0) Store(ShiftRight(Arg4,8),T2B1)
            }

            If (LEqual (Arg0, WRBT))
            {
                Store (Arg4, DAT0)
            }

            If (LEqual (Arg0, SDBT))
            {
                Store (Arg4, DAT0)
            }

            Store (Arg0, PRTC)
            Store (SWTC (Arg0), Index (Local0, Zero))
        }

        Release (MUEC)
        Return (Local0)
    }
    Method (ECSB, 7, NotSerialized)
    {
        Store (Package (0x05)
            {
                0x11,
                Zero,
                Zero,
                Zero,
                Buffer (0x20){}
            }, Local1)
        If (LGreater (Arg0, One))
        {
            Return (Local1)
        }

        If (ECAV ())
        {
            Acquire (MUEC, 0xFFFF)
            If (LEqual (Arg0, Zero))
            {
                Store (PRTC, Local0)
            }
            Else
            {
                Store (PRT2, Local0)
            }

            Store (Zero, Local2)
            While (LNotEqual (Local0, Zero))
            {
                Stall (0x0A)
                Increment (Local2)
                If (LGreater (Local2, 0x03E8))
                {
                    Store (SBBY, Index (Local1, Zero))
                    Store (Zero, Local0)
                }
                ElseIf (LEqual (Arg0, Zero))
                {
                    Store (PRTC, Local0)
                }
                Else
                {
                    Store (PRT2, Local0)
                }
            }

            If (LLessEqual (Local2, 0x03E8))
            {
                If (LEqual (Arg0, Zero))
                {
                    Store (Arg2, ADDR)
                    Store (Arg3, CMDB)
                    If (LOr (LEqual (Arg1, 0x0A), LEqual (Arg1, 0x0B)))
                    {
                        Store (DerefOf (Index (Arg6, Zero)), BCNT)
                        WRBA(DerefOf (Index (Arg6, One)))
                    }
                    Else
                    {
                        Store (Arg4, DAT0)
                        Store (Arg5, DAT1)
                    }

                    Store (Arg1, PRTC)
                }
                Else
                {
                    Store (Arg2, ADD2)
                    Store (Arg3, CMD2)
                    If (LOr (LEqual (Arg1, 0x0A), LEqual (Arg1, 0x0B)))
                    {
                        Store (DerefOf (Index (Arg6, Zero)), BCN2)
                        WRBB(DerefOf (Index (Arg6, One)))
                    }
                    Else
                    {
                        Store (Arg4, DA20)
                        Store (Arg5, DA21)
                    }

                    Store (Arg1, PRT2)
                }

                Store (0x7F, Local0)
                If (LEqual (Arg0, Zero))
                {
                    While (PRTC)
                    {
                        Sleep (One)
                        Decrement (Local0)
                    }
                }
                Else
                {
                    While (PRT2)
                    {
                        Sleep (One)
                        Decrement (Local0)
                    }
                }

                If (Local0)
                {
                    If (LEqual (Arg0, Zero))
                    {
                        Store (SSTS, Local0)
                        Store (DAT0, Index (Local1, One))
                        Store (DAT1, Index (Local1, 0x02))
                        Store (BCNT, Index (Local1, 0x03))
                        Store (RDBA(), Index (Local1, 0x04))
                    }
                    Else
                    {
                        Store (SST2, Local0)
                        Store (DA20, Index (Local1, One))
                        Store (DA21, Index (Local1, 0x02))
                        Store (BCN2, Index (Local1, 0x03))
                        Store (RDBB(), Index (Local1, 0x04))
                    }

                    And (Local0, 0x1F, Local0)
                    If (Local0)
                    {
                        Add (Local0, 0x10, Local0)
                    }

                    Store (Local0, Index (Local1, Zero))
                }
                Else
                {
                    Store (0x10, Index (Local1, Zero))
                }
            }

            Release (MUEC)
        }

        Return (Local1)
    }
    Method (TACH, 1, Serialized)
    {
        If (ECAV ())
        {
            Switch (Arg0)
            {
                Case (Zero)
                {
                    Store (B1B2(TH00,TH01), Local0)
                    Break
                }
                Case (One)
                {
                    Store (B1B2(TH10,TH11), Local0)
                    Break
                }
                Default
                {
                    Return (Ones)
                }

            }

            Multiply (Local0, 0x02, Local0)
            If (LNotEqual (Local0, Zero))
            {
                Divide (0x0041CDB4, Local0, Local1, Local0)
                Return (Local0)
            }
            Else
            {
                Return (Ones)
            }
        }
        Else
        {
            Return (Ones)
        }
    }    
}

Method (B1B2, 2, NotSerialized) { Return (Or (Arg0, ShiftLeft (Arg1, 8))) }

Scope (_SB.PCI0.LPCB)
{
    Scope (EC0)
    {
        Method (RDBA, 0, Serialized)
        {
            Name (TEMP, Buffer(0x20) { })
            Store (BA00, Index(TEMP, 0x00))
            Store (BA01, Index(TEMP, 0x01))
            Store (BA02, Index(TEMP, 0x02))
            Store (BA03, Index(TEMP, 0x03))
            Store (BA04, Index(TEMP, 0x04))
            Store (BA05, Index(TEMP, 0x05))
            Store (BA06, Index(TEMP, 0x06))
            Store (BA07, Index(TEMP, 0x07))
            Store (BA08, Index(TEMP, 0x08))
            Store (BA09, Index(TEMP, 0x09))
            Store (BA0A, Index(TEMP, 0x0A))
            Store (BA0B, Index(TEMP, 0x0B))
            Store (BA0C, Index(TEMP, 0x0C))
            Store (BA0D, Index(TEMP, 0x0D))
            Store (BA0E, Index(TEMP, 0x0E))
            Store (BA0F, Index(TEMP, 0x0F))
            Store (BA10, Index(TEMP, 0x10))
            Store (BA11, Index(TEMP, 0x11))
            Store (BA12, Index(TEMP, 0x12))
            Store (BA13, Index(TEMP, 0x13))
            Store (BA14, Index(TEMP, 0x14))
            Store (BA15, Index(TEMP, 0x15))
            Store (BA16, Index(TEMP, 0x16))
            Store (BA17, Index(TEMP, 0x17))
            Store (BA18, Index(TEMP, 0x18))
            Store (BA19, Index(TEMP, 0x19))
            Store (BA1A, Index(TEMP, 0x1A))
            Store (BA1B, Index(TEMP, 0x1B))
            Store (BA1C, Index(TEMP, 0x1C))
            Store (BA1D, Index(TEMP, 0x1D))
            Store (BA1E, Index(TEMP, 0x1E))
            Store (BA1F, Index(TEMP, 0x1F))
            Return (TEMP)
        }
        Method (WRBA, 1, Serialized)
        {
            Name (TEMP, Buffer(0x20) { })
            Store (Arg0, TEMP)
            Store (DerefOf(Index(TEMP, 0x00)), BA00)
            Store (DerefOf(Index(TEMP, 0x01)), BA01)
            Store (DerefOf(Index(TEMP, 0x02)), BA02)
            Store (DerefOf(Index(TEMP, 0x03)), BA03)
            Store (DerefOf(Index(TEMP, 0x04)), BA04)
            Store (DerefOf(Index(TEMP, 0x05)), BA05)
            Store (DerefOf(Index(TEMP, 0x06)), BA06)
            Store (DerefOf(Index(TEMP, 0x07)), BA07)
            Store (DerefOf(Index(TEMP, 0x08)), BA08)
            Store (DerefOf(Index(TEMP, 0x09)), BA09)
            Store (DerefOf(Index(TEMP, 0x0A)), BA0A)
            Store (DerefOf(Index(TEMP, 0x0B)), BA0B)
            Store (DerefOf(Index(TEMP, 0x0C)), BA0C)
            Store (DerefOf(Index(TEMP, 0x0D)), BA0D)
            Store (DerefOf(Index(TEMP, 0x0E)), BA0E)
            Store (DerefOf(Index(TEMP, 0x0F)), BA0F)
            Store (DerefOf(Index(TEMP, 0x10)), BA10)
            Store (DerefOf(Index(TEMP, 0x11)), BA11)
            Store (DerefOf(Index(TEMP, 0x12)), BA12)
            Store (DerefOf(Index(TEMP, 0x13)), BA13)
            Store (DerefOf(Index(TEMP, 0x14)), BA14)
            Store (DerefOf(Index(TEMP, 0x15)), BA15)
            Store (DerefOf(Index(TEMP, 0x16)), BA16)
            Store (DerefOf(Index(TEMP, 0x17)), BA17)
            Store (DerefOf(Index(TEMP, 0x18)), BA18)
            Store (DerefOf(Index(TEMP, 0x19)), BA19)
            Store (DerefOf(Index(TEMP, 0x1A)), BA1A)
            Store (DerefOf(Index(TEMP, 0x1B)), BA1B)
            Store (DerefOf(Index(TEMP, 0x1C)), BA1C)
            Store (DerefOf(Index(TEMP, 0x1D)), BA1D)
            Store (DerefOf(Index(TEMP, 0x1E)), BA1E)
            Store (DerefOf(Index(TEMP, 0x1F)), BA1F)
        }
        Method (RDBB, 0, Serialized)
        {
            Name (TEMP, Buffer(0x20) { })
            Store (BB00, Index(TEMP, 0x00))
            Store (BB01, Index(TEMP, 0x01))
            Store (BB02, Index(TEMP, 0x02))
            Store (BB03, Index(TEMP, 0x03))
            Store (BB04, Index(TEMP, 0x04))
            Store (BB05, Index(TEMP, 0x05))
            Store (BB06, Index(TEMP, 0x06))
            Store (BB07, Index(TEMP, 0x07))
            Store (BB08, Index(TEMP, 0x08))
            Store (BB09, Index(TEMP, 0x09))
            Store (BB0A, Index(TEMP, 0x0A))
            Store (BB0B, Index(TEMP, 0x0B))
            Store (BB0C, Index(TEMP, 0x0C))
            Store (BB0D, Index(TEMP, 0x0D))
            Store (BB0E, Index(TEMP, 0x0E))
            Store (BB0F, Index(TEMP, 0x0F))
            Store (BB10, Index(TEMP, 0x10))
            Store (BB11, Index(TEMP, 0x11))
            Store (BB12, Index(TEMP, 0x12))
            Store (BB13, Index(TEMP, 0x13))
            Store (BB14, Index(TEMP, 0x14))
            Store (BB15, Index(TEMP, 0x15))
            Store (BB16, Index(TEMP, 0x16))
            Store (BB17, Index(TEMP, 0x17))
            Store (BB18, Index(TEMP, 0x18))
            Store (BB19, Index(TEMP, 0x19))
            Store (BB1A, Index(TEMP, 0x1A))
            Store (BB1B, Index(TEMP, 0x1B))
            Store (BB1C, Index(TEMP, 0x1C))
            Store (BB1D, Index(TEMP, 0x1D))
            Store (BB1E, Index(TEMP, 0x1E))
            Store (BB1F, Index(TEMP, 0x1F))
            Return (TEMP)
        }
        Method (WRBB, 1, Serialized)
        {
            Name (TEMP, Buffer(0x20) { })
            Store (Arg0, TEMP)
            Store (DerefOf(Index(TEMP, 0x00)), BB00)
            Store (DerefOf(Index(TEMP, 0x01)), BB01)
            Store (DerefOf(Index(TEMP, 0x02)), BB02)
            Store (DerefOf(Index(TEMP, 0x03)), BB03)
            Store (DerefOf(Index(TEMP, 0x04)), BB04)
            Store (DerefOf(Index(TEMP, 0x05)), BB05)
            Store (DerefOf(Index(TEMP, 0x06)), BB06)
            Store (DerefOf(Index(TEMP, 0x07)), BB07)
            Store (DerefOf(Index(TEMP, 0x08)), BB08)
            Store (DerefOf(Index(TEMP, 0x09)), BB09)
            Store (DerefOf(Index(TEMP, 0x0A)), BB0A)
            Store (DerefOf(Index(TEMP, 0x0B)), BB0B)
            Store (DerefOf(Index(TEMP, 0x0C)), BB0C)
            Store (DerefOf(Index(TEMP, 0x0D)), BB0D)
            Store (DerefOf(Index(TEMP, 0x0E)), BB0E)
            Store (DerefOf(Index(TEMP, 0x0F)), BB0F)
            Store (DerefOf(Index(TEMP, 0x10)), BB10)
            Store (DerefOf(Index(TEMP, 0x11)), BB11)
            Store (DerefOf(Index(TEMP, 0x12)), BB12)
            Store (DerefOf(Index(TEMP, 0x13)), BB13)
            Store (DerefOf(Index(TEMP, 0x14)), BB14)
            Store (DerefOf(Index(TEMP, 0x15)), BB15)
            Store (DerefOf(Index(TEMP, 0x16)), BB16)
            Store (DerefOf(Index(TEMP, 0x17)), BB17)
            Store (DerefOf(Index(TEMP, 0x18)), BB18)
            Store (DerefOf(Index(TEMP, 0x19)), BB19)
            Store (DerefOf(Index(TEMP, 0x1A)), BB1A)
            Store (DerefOf(Index(TEMP, 0x1B)), BB1B)
            Store (DerefOf(Index(TEMP, 0x1C)), BB1C)
            Store (DerefOf(Index(TEMP, 0x1D)), BB1D)
            Store (DerefOf(Index(TEMP, 0x1E)), BB1E)
            Store (DerefOf(Index(TEMP, 0x1F)), BB1F)
        }
    }
}
</code></pre><p>}<br>//EOF</p>
<p>The resulting file can be saved as AML (suggested name: SSDT-BATT.aml), and placed in ACPI/patched.</p>
<p>But you can’t expect battery status to work with native DSDT yet!</p>
<p>Renaming existing methods</p>
<p>For now, there are duplicate methods in DSDT and this SSDT-BATT.aml. For each method in DSDT that the SSDT-BATT.aml version will replace, we must rename the method in DSDT to something else, which will allow the SSDT version to override.</p>
<p>Just as in post #1, this part follows the “Rename/Replace” pattern.<br>The methods that need replacements are FBST, _BIX, BIFA, SMBR, SMBW, ECSB, and TACH.</p>
<p>For this step, it is useful to create a mixed bytecode listing for the native DSDT.aml.<br>It can be created with: “iasl -l -dl DSDT.aml”, which creates a mixed listing in DSDT.dsl</p>
<p>For the FBST method:<br>Code (Text):</p>
<pre><code>Method (FBST, 4, NotSerialized)
{
    And (Arg1, 0xFFFF, Local1)
    Store (Zero, Local0)
</code></pre><p>  FF74: 14 43 12 46 42 53 54 04 7B 69 0B FF FF 61 70 00  // .C.FBST.{i…ap.<br>  FF84: 60</p>
<p>A potential rename patch (FBST-&gt;XBST):<br>Find: <46 42="" 53="" 54="" 04=""><br>Replace: <58 42="" 53="" 54="" 04=""></58></46></p>
<p>It is a good idea to verify that there is only one match for the Find hex data by searching for it in a hex editor such as Hex Fiend. Because the patch should ONLY apply to the method definition, not other code that may be present in the DSDT (or native SSDTs).</p>
<p>The target name you choose must be unique within the scope that the method resides. Creating a duplicate method will cause kernel panic. Changing the first letter to ‘X’ is usually ok, but no guarantee.</p>
<p>Patches for the rest of the methods:<br>_BIX-&gt;XBIX:<br>Find: <5f 42="" 49="" 58="" 00=""><br>Replace: <58 42="" 49="" 58="" 00=""></58></5f></p>
<p>BIFA-&gt;XIFA:<br>Find: <42 41="" 46="" 49="" 00=""><br>Replace: <58 41="" 46="" 49="" 00=""></58></42></p>
<p>SMBR-&gt;XMBR:<br>Find: <53 42="" 52="" 4d="" 0b=""><br>Replace: <58 42="" 52="" 4d="" 0b=""></58></53></p>
<p>SMBW-&gt;XMBW:<br>Find: <53 42="" 57="" 4d="" 0d=""><br>Replace: <58 42="" 57="" 4d="" 0d=""></58></53></p>
<p>ECSB-&gt;XCSB:<br>Find: <45 42="" 43="" 53="" 07=""><br>Replace: <58 42="" 43="" 53="" 07=""></58></45></p>
<p>TACH-&gt;XACH:<br>Find: <54 41="" 43="" 48="" 09=""><br>Replace: <58 41="" 43="" 48="" 09=""></58></54></p>
<p>After adding those patches to config.plist/ACPI/DSDT/Patches, the methods in native DSDT will be renamed by Clover. And as a result of the renaming, the patched methods defined in SSDT-BATT.aml will override.</p>
<p>Conclusion</p>
<p>Hotpatching for battery status is one of the most complex hotpatch tasks possible. The process of writing all the ‘External’ refernences is tedious and boring.</p>
<p>It will take some time (several hours into the text you’re reading here). Do not rush it.</p>
<p>Disabling discrete/switched GPU with Hotpatch</p>
<p>This third post is dedicated to hotpatching required for disabling the discrete GPU in a switched dual-GPU laptop, using the same example ACPI fils as the static patch guide.</p>
<p><a href="https://www.tonymacx86.com/threads/guide-disabling-discrete-graphics-in-dual-gpu-laptops.163772/" target="_blank" rel="external">https://www.tonymacx86.com/threads/guide-disabling-discrete-graphics-in-dual-gpu-laptops.163772/</a></p>
<p>You should download the ACPI/origin files that are attached to that guide, so you can follow along.</p>
<p>As in the static patch guide, the goal is relatively simple: call the _OFF method (from an _INI method) for the discrete GPU during ACPI initialization. But the details make it more complex due to the fact that _OFF can contain EC related code which needs to be executed in _REG instead of _INI.</p>
<p>Building the replacement _INI/_OFF/_REG methods</p>
<p>In the example, the target _INI method is in SSDT-7, _OFF is in SSDT-8. The path of the discrete device is _SB.PCI0.RP05.PEGP. In the example files, _OFF contains EC related code that must be moved to _REG. To complete this patching process, we need to replace _INI, _OFF, and _REG, therefore each will need to be renamed to XINI, XOFF, and XREG</p>
<p>Note: The methods you need to patch may in fact be different. It all depends on the code within the _OFF path. For example, with other ACPI sets, it happens that SGOF (may be some other name) has EC related code that must be moved to _REG. In that case, you would need to use rename/replace for the SGOF, and perhaps not the _OFF method. Analyze your existing code carefully.</p>
<p>The Clover config.plist patches will be worked out later. For now, lets look at the SSDT for the replacement methods.</p>
<p>The SSDT will consist of the patched methods:<br>Code (Text):</p>
<p>DefinitionBlock(“”, “SSDT”, 2, “hack”, “D-GPU”, 0)<br>{<br>    External(_SB.PCI0.RP05.PEGP, DeviceObj)<br>    External(_SB.PCI0.RP05.PEGP.XINI, MethodObj)<br>    External(_SB.PCI0.RP05.PEGP.XOFF, MethodObj)<br>    External(_SB.PCI0.RP05.PEGP.XINI, MethodObj)<br>    External(_SB.PCI0.LPCB.EC0, DeviceObj)<br>    External(_SB.PCI0.LPCB.EC0.XREG, MethodObj)<br>    External(_SB.PCI0.LPCB.EC0.SPIN, MethodObj)</p>
<pre><code>Scope(_SB.PCI0.RP05.PEGP)
{
    Method(_INI)
    {
        XINI() // call original _INI, now renamed XINI
        _OFF() // call (patched) _OFF
    }
    Method(_OFF, 0, Serialized)
    {
        If (LEqual (CTXT, Zero))
        {
            /* \_SB.PCI0.LPCB.EC0.SPIN (0x96, Zero) */
            If (LNotEqual (GPRF, One))
            {
                Store (VGAR, VGAB)
            }
            Store (One, CTXT)
        }
        SGOF ()
    }
}
Scope(_SB.PCI0.LPCB.EC0)
{
    Method(_REG, 2)
    {
        XREG(Arg0, Arg1) // call original _REG, now renamed XREG
        If (3 == Arg0 &amp;&amp; 1 == Arg1) // EC ready?
        {
            \_SB.PCI0.LPCB.EC0.SPIN (0x96, Zero) // code that was removed from _OFF
        }
    }
}
</code></pre><p>}</p>
<p>At this point, the code won’t compile, as some of the symbols referenced in _OFF are not available.<br>Just like the battery patching guide, we must add the appropriate External declarations.</p>
<p>Use the compiler errors to determine which symbols you need to find, then add the appropriate External declartions. In the example case:<br>Code (Text):</p>
<pre><code>External(_SB.PCI0.RP05.PEGP.CTXT, IntObj)
External(_SB.PCI0.RP05.PEGP.GPRF, IntObj)
External(_SB.PCI0.RP05.PEGP.VGAR, FieldUnitObj)
External(_SB.PCI0.RP05.PEGP.VGAB, BuffObj)
External(_SB.PCI0.RP05.PEGP.SGOF, MethodObj)
</code></pre><p>The resulting SSDT:<br>Code (Text):</p>
<p>DefinitionBlock(“”, “SSDT”, 2, “hack”, “D-GPU”, 0)<br>{<br>    External(_SB.PCI0.RP05.PEGP, DeviceObj)<br>    External(_SB.PCI0.RP05.PEGP.XINI, MethodObj)<br>    External(_SB.PCI0.RP05.PEGP.XOFF, MethodObj)<br>    External(_SB.PCI0.RP05.PEGP.XINI, MethodObj)<br>    External(_SB.PCI0.LPCB.EC0, DeviceObj)<br>    External(_SB.PCI0.LPCB.EC0.XREG, MethodObj)<br>    External(_SB.PCI0.LPCB.EC0.SPIN, MethodObj)<br>    External(_SB.PCI0.RP05.PEGP.CTXT, IntObj)<br>    External(_SB.PCI0.RP05.PEGP.GPRF, IntObj)<br>    External(_SB.PCI0.RP05.PEGP.VGAR, FieldUnitObj)<br>    External(_SB.PCI0.RP05.PEGP.VGAB, BuffObj)<br>    External(_SB.PCI0.RP05.PEGP.SGOF, MethodObj)</p>
<pre><code>Scope(_SB.PCI0.RP05.PEGP)
{
    Method(_INI)
    {
        XINI() // call original _INI, now renamed XINI
        _OFF() // call (patched) _OFF
    }
    Method(_OFF, 0, Serialized)
    {
        If (LEqual (CTXT, Zero))
        {
            /* \_SB.PCI0.LPCB.EC0.SPIN (0x96, Zero) */
            If (LNotEqual (GPRF, One))
            {
                Store (VGAR, VGAB)
            }
            Store (One, CTXT)
        }
        SGOF ()
    }
}
Scope(_SB.PCI0.LPCB.EC0)
{
    Method(_REG, 2)
    {
        XREG(Arg0, Arg1) // call original _REG, now renamed XREG
        If (3 == Arg0 &amp;&amp; 1 == Arg1) // EC ready?
        {
            \_SB.PCI0.LPCB.EC0.SPIN (0x96, Zero) // code that was removed from _OFF
        }
    }
}
</code></pre><p>}</p>
<p>Now it compiles without error, but there is one warning: “39, 3079, _REG has no corresponding Operation Region”. And this warning is important. The _REG will not be called unless we add a dummy EC OperationRegion.</p>
<p>We can add it:<br>Code (Text):</p>
<p>…<br>    Scope(_SB.PCI0.LPCB.EC0)<br>    {<br>        OperationRegion(RME3, EmbeddedControl, 0x00, 0xFF)<br>        Method(_REG, 2)<br>        {<br>…</p>
<p>Resulting complete SSDT:<br>Code (Text):</p>
<p>DefinitionBlock(“”, “SSDT”, 2, “hack”, “D-GPU”, 0)<br>{<br>    External(_SB.PCI0.RP05.PEGP, DeviceObj)<br>    External(_SB.PCI0.RP05.PEGP.XINI, MethodObj)<br>    External(_SB.PCI0.RP05.PEGP.XOFF, MethodObj)<br>    External(_SB.PCI0.RP05.PEGP.XINI, MethodObj)<br>    External(_SB.PCI0.LPCB.EC0, DeviceObj)<br>    External(_SB.PCI0.LPCB.EC0.XREG, MethodObj)<br>    External(_SB.PCI0.LPCB.EC0.SPIN, MethodObj)<br>    External(_SB.PCI0.RP05.PEGP.CTXT, IntObj)<br>    External(_SB.PCI0.RP05.PEGP.GPRF, IntObj)<br>    External(_SB.PCI0.RP05.PEGP.VGAR, FieldUnitObj)<br>    External(_SB.PCI0.RP05.PEGP.VGAB, BuffObj)<br>    External(_SB.PCI0.RP05.PEGP.SGOF, MethodObj)</p>
<pre><code>Scope(_SB.PCI0.RP05.PEGP)
{
    Method(_INI)
    {
        XINI() // call original _INI, now renamed XINI
        _OFF() // call (patched) _OFF
    }
    Method(_OFF, 0, Serialized)
    {
        If (LEqual (CTXT, Zero))
        {
            /* \_SB.PCI0.LPCB.EC0.SPIN (0x96, Zero) */
            If (LNotEqual (GPRF, One))
            {
                Store (VGAR, VGAB)
            }
            Store (One, CTXT)
        }
        SGOF ()
    }
}
Scope(_SB.PCI0.LPCB.EC0)
{
    OperationRegion(RME3, EmbeddedControl, 0x00, 0xFF)
    Method(_REG, 2)
    {
        XREG(Arg0, Arg1) // call original _REG, now renamed XREG
        If (3 == Arg0 &amp;&amp; 1 == Arg1) // EC ready?
        {
            \_SB.PCI0.LPCB.EC0.SPIN (0x96, Zero) // code that was removed from _OFF
        }
    }
}
</code></pre><p>}</p>
<p>At this point, you can save the SSDT (suggestion: SSDT-DGPU.aml).<br>It is ready to go to ACPI/patched.</p>
<p>But we still need to rename the original methods in native ACPI.</p>
<p>Renaming the methods</p>
<p>As mentioned earlier, the following methods need renaming:<br>_SB.PCI0.RP05.PEGP._INI -&gt; XINI<br>_SB.PCI0.RP05.PEGP._OFF -&gt; XOFF<br>_SB.PCI0.LPCB.EC0._REG -&gt; XREG</p>
<p>To determine the binary patches needed, we need a mixed listing of DSDT.aml, SSDT-7.aml, and SSDT-8.aml.<br>Create with:<br>Code (Text):</p>
<p>iasl -dl -l DSDT.aml SSDT-7.aml SSDT-8.aml</p>
<p>The resulting mixed listing is in DSDT.dsl, SSDT-7.dsl, and SSDT-8.dsl.</p>
<p>Here is the mixed listing for _REG in DSDT.dsl:<br>Code (Text):</p>
<pre><code>Method (_REG, 2, NotSerialized)  // _REG: Region Availability
{
</code></pre><p>  D2B8: 14 12 5F 52 45 47 02                             // .._REG.</p>
<pre><code>If (LEqual (Arg0, 0x03))
{
</code></pre><p>  D2BF: A0 0B 93 68 0A 03                                // …h..</p>
<pre><code>                Store (Arg1, ECFL)
            }
        }
    }
}
</code></pre><p>  D2C5: 70 69 45 43 46 4C</p>
<p>The patch used should rename only this _REG, not other _REG methods in the ACPI set. We can rename it by grabbing the name/header plus a few bytes from the code.</p>
<p>This pattern grabs enough bytes to be unique for sure:<br>Find: <5f 43="" 45="" 46="" 47="" 52="" 68="" 69="" 70="" 93="" 02="" a0="" 0b="" 0a="" 03="" 4c=""><br>Replace: <58 43="" 45="" 46="" 47="" 52="" 68="" 69="" 70="" 93="" 02="" a0="" 0b="" 0a="" 03="" 4c=""></58></5f></p>
<p>And the mixed listing for the target _INI in SSDT-7.dsl:</p>
<p>Code (Text):</p>
<pre><code>Method (_INI, 0, NotSerialized)  // _INI: Initialize
{
</code></pre><p>  03D1: 14 1F 5F 49 4E 49 00                             // .._INI.</p>
<pre><code>    Store (Zero, \_SB.PCI0.RP05.PEGP._ADR)
}
</code></pre><p>  03D8: 70 00 5C 2F 05 5F 53 42 5F 50 43 49 30 52 50 30  // p.\/._SB_PCI0RP0<br>  03E8: 35 50 45 47 50 5F 41 44 52                       // 5PEGP_ADR</p>
<p>Resulting patch…<br>Find: <5f 30="" 35="" 42="" 43="" 45="" 47="" 49="" 50="" 52="" 53="" 70="" 4e="" 00="" 5c="" 2f="" 05="" 5f=""><br>Replace: <58 30="" 35="" 42="" 43="" 45="" 47="" 49="" 50="" 52="" 53="" 70="" 4e="" 00="" 5c="" 2f="" 05="" 5f=""></58></5f></p>
<p>And the _OFF in SSDT-8.dsl:<br>Code (Text):</p>
<pre><code>Method (_OFF, 0, Serialized)  // _OFF: Power Off
{
</code></pre><p>  032B: 14 45 04 5F 4F 46 46 08                          // .E._OFF.</p>
<pre><code>If (LEqual (CTXT, Zero))
{
    \_SB.PCI0.LPCB.EC0.SPIN (0x96, Zero)
</code></pre><p>  0333: A0 39 93 43 54 58 54 00 5C 2F 05 5F 53 42 5F 50  // .9.CTXT.\/._SB_P<br>  0343: 43 49 30 4C 50 43 42 45 43 30 5F 53 50 49 4E 0A  // CI0LPCBEC0_SPIN.<br>  0353: 96 00</p>
<p>The patch…<br>Find: <5f 39="" 43="" 46="" 54="" 58="" 93="" 4f="" 08="" a0=""><br>Replace: <58 39="" 43="" 46="" 54="" 58="" 93="" 4f="" 08="" a0=""></58></5f></p>
<p>Note: Each of these patches could probably be reduced, but you would need to check carefully in all native DSDT and SSDTs for the Find pattern as you don’t want to match on any methods but the target methods. Because _REG, _INI and _OFF are very common names for methods in other scopes, we need to be careful.</p>
<p>A simple example</p>
<p>The files for the ASUS mentioned above were complex due to the need to patch _OFF, _INI, and _REG.</p>
<p>But let’s take a look at an example that is much simpler. The files are for an Asus K550VX-DM406T, and they are attached to this post. Please download them so you can follow along.</p>
<p>When we look at the _OFF method in SSDT-14, there is no EC related code. And it calls PGOF, but the PGOF method, defined in SSDT-3, also has no EC related code:<br>Code (Text):</p>
<pre><code>Method (_OFF, 0, Serialized)  // _OFF: Power Off
{
    If (LEqual (CTXT, Zero))
    {
        If (LNotEqual (GPRF, One))
        {
            Store (VGAR, VGAB)
        }

        Store (One, CTXT)
    }

    PGOF (Zero)
}
</code></pre><p>This means _OFF can be called directly from an _INI.</p>
<p>If you look at all the _INI methods in the ACPI set, you will find there is no _INI at the path of _OFF (_SB.PCI0.PEG0.PEGP). Which means we can simply add an SSDT that has an _INI at the correct path, and that _INI simply calls _OFF.</p>
<p>It is a one-liner method:<br>Code (Text):</p>
<p>DefinitionBlock(“”, “SSDT”, 2, “hack”, “DGPU”, 0)<br>{<br>    External(_SB.PCI0.PEG0.PEGP._OFF, MethodObj)<br>    Method(_SB.PCI0.PEG0.PEGP._INI) { _OFF() }<br>}</p>
<p>Just as mentioned in the main discrete disable guide (static patch), sometimes you need to call _PS3 instead of _OFF. It is a trial and error process to determine which is best.</p>
<p>Same code as above, but calling _PS3:<br>Code (Text):</p>
<p>DefinitionBlock(“”, “SSDT”, 2, “hack”, “DGPU”, 0)<br>{<br>    External(_SB.PCI0.PEG0.PEGP._PS3, MethodObj)<br>    Method(_SB.PCI0.PEG0.PEGP._INI) { _PS3() }<br>}</p>
<p>Save it as SSDT-DGPU.aml and the Nvidia should be disabled.</p>
<p>The simple example turned not so simple</p>
<p>Although the method mentioned above will usually work in this scenario (even with other laptops that present the same scenario: no EC access in _OFF path, no existing _INI at the path), this specific laptop needed additional patching in order to turn off the dedicated Nvidia fan.</p>
<p>A little investigation was needed. As we can see by looking at the _OFF code, it calls PGOF(Zero) to do most of the work. And if we search for other examples of PGOF being called with Arg0==Zero, we find this code in SSDT-3.dsl:<br>Code (Text):</p>
<pre><code>ElseIf (LAnd (LGreater (OSYS, 0x07D9), PEGS ()))
{
    FAOF ()
    PGOF (Zero)
</code></pre><p>…</p>
<p>Note the call to FAOF. Could that be for “FAN OFF”? Seems likely.</p>
<p>And look, we have FAOF and FAON in SSDT-3:<br>Code (Text):</p>
<pre><code>Method (FAON, 0, Serialized)
{
    \_SB.PCI0.LPCB.EC0.WRAM (0x052B, 0x9E)
    \_SB.PCI0.LPCB.EC0.WRAM (0x0520, 0x8B)
    Store (\_SB.PCI0.LPCB.EC0.RRAM (0x0521), Local0)
    And (Local0, 0xCF, Local0)
    Or (Local0, 0x20, Local0)
    \_SB.PCI0.LPCB.EC0.WRAM (0x0521, Local0)
}

Method (FAOF, 0, Serialized)
{
    Store (\_SB.PCI0.LPCB.EC0.RRAM (0x0521), Local0)
    And (Local0, 0xCF, Local0)
    \_SB.PCI0.LPCB.EC0.WRAM (0x0521, Local0)
    \_SB.PCI0.LPCB.EC0.WRAM (0x0520, 0x89)
    \_SB.PCI0.LPCB.EC0.WRAM (0x03A4, Zero)
    \_SB.PCI0.LPCB.EC0.WRAM (0x03A5, Zero)
}
</code></pre><p>And you can see it does a bunch of EC manipulations. Typically the EC controls the system fans, so this seems to confirm these methods are for “FAN ON”, and “FAN OFF”.</p>
<p>Since these methods manipulate the EC, we cannot call FAOF without the EC being ready. To do that, we need to patch _REG.</p>
<p>So, adding the necessary code to our SSDT:<br>Code (Text):</p>
<p>DefinitionBlock(“”, “SSDT”, 2, “hack”, “DGPU”, 0)<br>{<br>    External(_SB.PCI0.PEG0.PEGP._OFF, MethodObj)<br>    Method(_SB.PCI0.PEG0.PEGP._INI) { _OFF() }</p>
<pre><code>External(_SB.PCI0.LPCB.EC0, DeviceObj)
External(_SB.PCI0.LPCB.EC0.XREG, MethodObj)
External(_SB.PCI0.PEG0.FAOF, MethodObj)
Scope(_SB.PCI0.LPCB.EC0)
{
    OperationRegion(RME3, EmbeddedControl, 0x00, 0xFF)
    Method(_REG, 2)
    {
        XREG(Arg0, Arg1) // call original _REG, now renamed XREG
        If (3 == Arg0 &amp;&amp; 1 == Arg1) // EC ready?
        {
             \_SB.PCI0.PEG0.FAOF() // turn dedicated Nvidia fan off
        }
    }
}
</code></pre><p>}</p>
<p>And the patch we need to rename _REG to XREG (again, based on a mixed listing of DSDT.aml):</p>
<p>Find: <5f 45="" 47="" 52="" 68="" 93="" 02="" a0="" 0b="" 0a="" 03=""><br>Replace: <58 45="" 47="" 52="" 68="" 93="" 02="" a0="" 0b="" 0a="" 03=""></58></5f></p>
<p>With the patch in config.plist, EC0._REG is renamed XREG. The eventual call to _REG by the system lands in our modified _REG, which, in turn, calls the original _REG (renamed to XREG) and calls FAOF to turn the fan off.</p>
<p>Conclusion</p>
<p>Hotpatching discrete GPU disable code is a bit simpler than battery status, but involves similar concepts.</p>
<p>###Credits<br><a href="https://github.com/RehabMan/OS-X-Clover-Laptop-Config" target="_blank" rel="external">https://github.com/RehabMan/OS-X-Clover-Laptop-Config</a><br><a href="https://www.tonymacx86.com/threads/guide-using-clover-to-hotpatch-acpi.200137/" target="_blank" rel="external">https://www.tonymacx86.com/threads/guide-using-clover-to-hotpatch-acpi.200137/</a></p>

      
    </div>
    
    
    

    

    
      <div>
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
      </div>
    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>支持站长</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.jpg" alt="athlonreg/套陆 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt="athlonreg/套陆 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Hacintosh/" rel="tag"><i class="fa fa-tag"></i> Hacintosh</a>
          
            <a href="/tags/SSDT/" rel="tag"><i class="fa fa-tag"></i> SSDT</a>
          
            <a href="/tags/hotpatch/" rel="tag"><i class="fa fa-tag"></i> hotpatch</a>
          
            <a href="/tags/ACPI/" rel="tag"><i class="fa fa-tag"></i> ACPI</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/12/13/HP-OMEN-by-HP-Laptop/" rel="next" title="HP OMEN by HP Laptop">
                <i class="fa fa-chevron-left"></i> HP OMEN by HP Laptop
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        
<script>
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='//bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="SOHUCS"></div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          
            <img class="site-author-image" itemprop="image"
              src="/uploads/avatar.jpg"
              alt="athlonreg/套陆" />
          
            <p class="site-author-name" itemprop="name">athlonreg/套陆</p>
            <p class="site-description motion-element" itemprop="description">欢迎来到我的博客，我会在这里分享我的黑苹果经验和一些算法！</p>
        </div>

        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
            
              <a href="/archives/">
            
                <span class="site-state-item-count">37</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">56</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/athlonreg" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>GitHub</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="mailto:qingyingairen@gmail.com" target="_blank" title="E-Mail">
                  
                    <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.jianshu.com/u/a918c9e67dc2" target="_blank" title="简书">
                  
                    <i class="fa fa-fw fa-heartbeat"></i>简书</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://i.pcbeta.com/space-uid-157829.html" target="_blank" title="pcbeta">
                  
                    <i class="fa fa-fw fa-meh-o"></i>pcbeta</a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Preface–序言"><span class="nav-number">1.</span> <span class="nav-text">Preface–序言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Brief-description-for-hotpatch–hotpatch概要"><span class="nav-number">2.</span> <span class="nav-text">Brief description for hotpatch–hotpatch概要</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#A-brief-description-of-each-hotpatch-SSDT-is-provided-below–下面是每一个-hotpatch-SSDT-的概要"><span class="nav-number">2.1.</span> <span class="nav-text">A brief description of each hotpatch SSDT is provided below–下面是每一个 hotpatch SSDT 的概要</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Battery-Status-Hotpatch"><span class="nav-number">3.</span> <span class="nav-text">Battery Status Hotpatch</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      
      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">athlonreg/套陆</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">
      39.7k
    </span>
  
</div>

<div class="powered-by">
<i class="fa fa-user-md"></i>
<span id="busuanzi_container_site_pv">
  本站访客数:<span id="busuanzi_value_site_pv"></span>
</span>
</div>


  <div class="powered-by">由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">主题 &mdash; <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.2</div>


<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共39.7k字</span>
</div>

        







        
      </div>
    </footer>

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>


  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("UvfjEEwG1cCMWwMoSfmFPHsp-gzGzoHsz", "05veilg20psiTa5NPUhOxz6I");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  
  


  

  

</body>
</html>
